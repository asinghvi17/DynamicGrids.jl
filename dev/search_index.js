var documenterSearchIndex = {"docs":
[{"location":"#DynamicGrids","page":"DynamicGrids","title":"DynamicGrids","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids","category":"page"},{"location":"#DynamicGrids","page":"DynamicGrids","title":"DynamicGrids","text":"(Image: DynamicGrids)\n\n(Image: ) (Image: ) (Image: Build Status)  (Image: codecov.io) (Image: Aqua.jl Quality Assurance)\n\nDynamicGrids is a generalised framework for building high-performance grid-based spatial simulations, including cellular automata, but also allowing a wider range of behaviours like random jumps and interactions between multiple grids. It is extended by Dispersal.jl for modelling organism dispersal processes.\n\nDynamicGridsGtk.jl provides a simple live  interface, while DynamicGridsInteract.jl  also has live control over model parameters while the simulation runs: real-time visual feedback for manual parametrisation and model exploration.\n\nDynamicGrids can run rules on single CPUs, threaded CPUs, and on CUDA GPUs.  Simulation run-time is usually measured in fractions of a second.\n\n(Image: Dispersal quarantine)\n\nA dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from DynamicGridsGtk.  Note that this is indicative of the real-time frame-rate on a laptop.\n\nA DynamicGrids.jl simulation is run with a script like this one running the included game of life model Life():\n\nusing DynamicGrids, Crayons\n\ninit = rand(Bool, 150, 200)\noutput = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))\nsim!(output, Life())\n\n# Or define it from scratch (yes this is actually the whole implementation!)\nconst sum_states = (false, false, true, false, false, false, false, false, false), \n                   (false, false, true, true,  false, false, false, false, false)\nlife = Neighbors(Moore(1)) do hood, state\n    sum_states[state + 1][sum(hood) + 1]\nend\nsim!(output, life)\n\n(Image: REPL life)\n\nA game of life simulation being displayed directly in a terminal.\n\nConcepts\n\nThe framework is highly customisable, but there are some central ideas that define how a simulation works: grids, rules, and outputs.\n\nGrids\n\nSimulations run over one or many grids, derived from init of a single AbstractArray or a NamedTuple of multiple AbstractArray. Grids (GridData types) are, however not a single array but both source and destination arrays, to maintain independence between cell reads and writes where required. These may be padded or otherwise altered for specific performance optimisations. However, broadcasted getindex operations are guaranteed to work on them as if the grid is a regular array. This may be useful running simulations manually with step!.\n\nUsually grids contain values of Number, but other types are possible, such as SArray, FieldVector or other custom structs. Grids are updated by Rules that are run for every cell, at every timestep. \n\nThe init grid/s contain whatever initialisation data is required to start a simulation: the array type, size and element type, as well as providing the initial conditions:\n\ninit = rand(Float32, 100, 100)\n\nAn init grid can be attached to an Output: \n\noutput = ArrayOutput(init; tspan=1:100)\n\nor passed in to sim!, where it will take preference over the init attached to the Output, but must be the same type and size:\n\nsim!(output, ruleset; init=init)\n\nFor multiple grids, init is a NamedTuple of equal-sized arrays matching the names used in each Ruleset :\n\ninit = (predator=rand(100, 100), prey=(rand(100, 100))\n\nHandling and passing of the correct grids to a Rule is automated by DynamicGrids.jl, as a no-cost abstraction. Rules specify which grids they require in what order using the first two (R and W) type parameters.\n\nDimensional or spatial init grids from DimensionalData.jl or GeoData.jl will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using Plots.jl, to which shape files and observation points can be easily added.\n\nNon-Number Grids\n\nGrids containing custom and non-Number types are possible, with some caveats. They must define Base.zero for their element type, and should be a bitstype for performance.  Tuple does not define zero. Array is not a bitstype, and does not define zero.  SArray from StaticArrays.jl is both, and can be used as the contents of a grid.  Custom structs that defne zero should also work. \n\nHowever, for any multi-values grid element type, you will need to define a method of  DynamicGrids.to_rgb that returns an ARGB32 for them to work in ImageOutputs, and  isless for the REPLoutput to work. A definition for multiplication by a scalar Real  and addition are required to use Convolution kernels.\n\nRules\n\nRules hold the parameters for running a simulation, and are applied in applyrule method that is called for each of the active cells in the grid. Rules come in a number of flavours (outlined in the docs), which allow assumptions to be made about running them that can greatly improve performance. Rules can be collected in a Ruleset, with some additional arguments to control the simulation:\n\nruleset = Ruleset(Life(2, 3); opt=SparseOpt(), proc=CuGPU())\n\nMultiple rules can be combined in a Ruleset or simply passed to sim!. Each rule  will be run for the whole grid, in sequence, using appropriate optimisations depending  on the parent types of each rule:\n\nruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt(), proc=ThreadedCPU())\n\nOutput\n\nOutputs are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: ArrayOutput is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the init array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.\n\noutput = ArrayOutput(init; tspan=1:10)\n\nThe REPLOutput shown above is a GraphicOutput that can be useful for checking a simulation when working in a terminal or over ssh:\n\noutput = REPLOutput(init; tspan=1:100)\n\nImageOutput is the most complex class of outputs, allowing full color visual simulations using ColorSchemes.jl. It can also display multiple grids using color  composites or layouts, as shown above in the quarantine simulation.\n\nDynamicGridsInteract.jl provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters, using  ModelParameters.jl. DynamicGridsGtk.jl is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. \n\nOutputs are also easy to write, and high performance applications may benefit from writing a custom output to reduce memory use, or using TransformedOuput.  Performance of DynamicGrids.jl is dominated by cache interactions, so reducing  memory use has positive effects.\n\nExample\n\nThis example implements the classic stochastic forest fire model in a few different ways, and benchmarks them.\n\nFirst we will define a Forest Fire algorithm that sets the current cell to burning, if a neighbor is burning. Dead cells can come back to life, and living cells can spontaneously catch fire:\n\nusing DynamicGrids, ColorSchemes, Colors, BenchmarkTools\n\nconst DEAD, ALIVE, BURNING = 1, 2, 3\n\nneighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01\n    Neighbors(Moore(1)) do data, neighborhood, cell, I\n        if cell == ALIVE\n            if BURNING in neighborhood\n                BURNING\n            else\n                rand() <= prob_combustion ? BURNING : ALIVE\n            end\n        elseif cell == BURNING\n            DEAD\n        else\n            rand() <= prob_regrowth ? ALIVE : DEAD\n        end\n    end\nend\n\n# Set up the init array and output (using a Gtk window)\ninit = fill(ALIVE, 400, 400)\noutput = GifOutput(init; \n    filename=\"forestfire.gif\", tspan=1:200, fps=25, \n    minval=DEAD, maxval=BURNING, \n    imagegen=Image(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))\n)\n\n# Run the simulation, which will save a gif when it completes\nsim!(output, neighbors_rule)\n\n(Image: forestfire)\n\nTiming the simulation for 200 steps, the performance is quite good. This particular CPU has six cores, and we get a 5.25x speedup by using all of them, which indicates good scaling:\n\nbench_output = ResultOutput(init; tspan=1:200)\n\njulia> @btime sim!($bench_output, $neighbors_rule);\n  477.183 ms (903 allocations: 2.57 MiB)\n\njulia> @btime sim!($bench_output, $neighbors_rule; proc=ThreadedCPU());\n  91.321 ms (15188 allocations: 4.07 MiB)\n\nWe can also invert the algorithm, setting cells in the neighborhood to burning if the current cell is burning, by using the SetNeighbors rule:\n\nsetneighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01\n    SetNeighbors(Moore(1)) do data, neighborhood, cell, I\n        if cell == DEAD\n            if rand() <= prob_regrowth\n                data[I...] = ALIVE\n            end\n        elseif cell == BURNING\n            for pos in positions(neighborhood, I)\n                if data[pos...] == ALIVE\n                    data[pos...] = BURNING\n                end\n            end\n            data[I...] = DEAD\n        elseif cell == ALIVE\n            if rand() <= prob_combustion \n                data[I...] = BURNING\n            end\n        end\n    end\nend\n\nNote: we are not using add!, instead we just set the grid value directly. This usually risks errors if multiple cells set different values. Here they only ever set a currently living cell to burning in the next timestep. It doesn't matter if this happens multiple times, the result is the same.\n\nAnd in this case (a fairly sparse simulation), this rule is faster:\n\njulia> @btime sim!($bench_output, $setneighbors_rule);\n  261.969 ms (903 allocations: 2.57 MiB)\n\njulia> @btime sim!($bench_output, $setneighbors_rule; proc=ThreadedCPU());\n  65.489 ms (7154 allocations: 3.17 MiB)\n\nBut the scaling is not quite as good, at 3.9x for 6 cores. The first method may be better on a machine with a lot of cores.\n\nLast, we can slightly rewrite these rules for GPU, as rand is not available within a GPU kernel. Instead we call CUDA.rand! on the entire parent array of the :rand grid, using a SetGrid rule:\n\nusing CUDAKernels, CUDA\n\nrandomiser = SetGrid{Tuple{},:rand}() do randgrid\n    CUDA.rand!(parent(randgrid))\nend\n\nNow we define a Neighbors version for GPU, using the :rand grid values instead of rand():\n\nneighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01\n    Neighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do data, neighborhood, (cell, rand), I\n        if cell == ALIVE\n            if BURNING in neighborhood\n                BURNING\n            else\n                rand <= prob_combustion ? BURNING : ALIVE\n            end\n        elseif cell == BURNING\n            DEAD\n        else\n            rand <= prob_regrowth ? ALIVE : DEAD\n        end\n    end\nend\n\nAnd a SetNeighbors version for GPU:\n\nsetneighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01\n    SetNeighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do data, neighborhood, (cell, rand), I\n        if cell == DEAD\n            if rand <= prob_regrowth\n                data[:ff][I...] = ALIVE\n            end\n        elseif cell == BURNING\n            for pos in positions(neighborhood, I)\n                if data[:ff][pos...] == ALIVE\n                    data[:ff][pos...] = BURNING\n                end\n            end\n            data[:ff][I...] = DEAD\n        elseif cell == ALIVE\n            if rand <= prob_combustion \n                data[:ff][I...] = BURNING\n            end\n        end\n    end\nend\n\nNow we benchmark both version on a GTX 1080. Despite the overhead of reading and writing two grids, this turns out to be even faster again:\n\nbench_output_rand = ResultOutput((ff=init, rand=zeros(size(init))); tspan=1:200)\n\njulia> @btime sim!($bench_output_rand, $randomiser, $neighbors_gpu; proc=CuGPU());\n  30.621 ms (186284 allocations: 17.19 MiB)\n\njulia> @btime sim!($bench_output_rand, $randomiser, $setneighbors_gpu; proc=CuGPU());\n  22.685 ms (147339 allocations: 15.61 MiB)\n\nThat is, we are running the rule at a rate of 1.4 billion times per second. These timings could be improved (maybe 10-20%) by using grids of Int32 or Int16 to use less memory and cache. But we will stop here!\n\n\n\n\n\n","category":"module"},{"location":"#Running-simulations","page":"DynamicGrids","title":"Running simulations","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"sim!\nresume!\nstep!","category":"page"},{"location":"#DynamicGrids.sim!","page":"DynamicGrids","title":"DynamicGrids.sim!","text":"sim!(output, rules::Rule...; kw...)\nsim!(output, rules::Tuple{<:Rule,Vararg}; kw...)\nsim!(output, [ruleset::Ruleset=ruleset(output)]; kw...)\n\nRuns the simulation, passing the destination aray to the passed in output for each time-step.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one or more Rules. If the output has a Ruleset attached, it will be used.\n\nKeywords\n\nTheses are the taken from the output argument by default:\n\ninit: optional array or NamedTuple of arrays.\nmask: a Bool array matching the init array size. false cells do not run.\naux: a NamedTuple of auxilary data to be used by rules.\ntspan: a tuple holding the start and end of the timespan the simulaiton will run for.\nfps: the frames per second to display. Will be taken from the output if not passed in.\n\nTheses are the taken from the ruleset argument by default:\n\nproc: a Processor to specificy the hardware to run simulations on,    like SingleCPU, ThreadedCPU or CuGPU when    KernelAbstractions.jl and a CUDA gpu is available. \nopt: a PerformanceOpt to specificy optimisations like   SparseOpt or NoOpt. Defaults to NoOpt().\nboundary: what to do with boundary of grid edges.  Options are Remove or Wrap, defaulting to Remove().\ncellsize: the size of cells, which may be accessed by rules.\ntimestep: fixed timestep where this is required for some rules.   eg. Month(1) or 1u\"s\".\n\nOther:\n\nsimdata: a SimData object. Keeping it between simulations can reduce memory allocation a little, when that is important.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.resume!","page":"DynamicGrids","title":"DynamicGrids.resume!","text":"resume!(output::GraphicOutput, ruleset::Ruleset=ruleset(output); tstop, kw...)\n\nRestart the simulation from where you stopped last time. For arguments see sim!. The keyword arg tstop can be used to extend the length of the simulation.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one ore more Rules. These will each be run in sequence.\n\nKeyword Arguments (optional\n\ninit: an optional initialisation array\ntstop: the new stop time for the simulation. Taken from the output length by default.\nfps: the frames per second to display. Taken from the output by default.\nsimdata: a SimData object. Keeping it between simulations can improve performance   when that is important\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.step!","page":"DynamicGrids","title":"DynamicGrids.step!","text":"step!(sd::AbstractSimData, rules=rules(sd))\n\nAllows stepping a simulation one frame at a time, for a more manual approach to simulation that sim!. This may be useful if other processes need to be run  between steps, or the simulation is of variable length. step! also removes the use of Outputs, meaning storing of grid data must be handled manually, if that is  required. Of course, an output can also be updated manually, using:\n\nDynmicGrids.storeframe!(output, simdata)\n\nInstead of an Output, the internal SimData objects are used directly,  and can be defined using a Extent object and a Ruleset.\n\nExample\n\nruleset = Ruleset(myrules; proc=ThreadedCPU())\nextent = Extent(; init=(a=A, b=B), aux=aux, tspan=tspan)\nsimdata = SimData(extent, ruleset)\n# Run a single step, which returns an updated SimData object\nsimdata = step!(simdata)\n# Get a view of the grid without padding, for NeighborhoodRule/SetNeighborhoodRule\nDynmicGrids.gridview(simdata[:a])\n\nThis example returns a GridData object for the :a grid, which is <: AbstractAray.\n\n\n\n\n\n","category":"function"},{"location":"#Rulesets","page":"DynamicGrids","title":"Rulesets","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"AbstractRuleset\nRuleset","category":"page"},{"location":"#DynamicGrids.AbstractRuleset","page":"DynamicGrids","title":"DynamicGrids.AbstractRuleset","text":"AbstractRuleset <: ModelParameters.AbstractModel\n\nAbstract supertype for Ruleset objects and variants.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Ruleset","page":"DynamicGrids","title":"DynamicGrids.Ruleset","text":"Rulseset <: AbstractRuleset\n\nRuleset(rules...; kw...)\nRuleset(rules, settings)\n\nA container for holding a sequence of Rules and simulation details like boundary handing and optimisation. Rules will be run in the order they are passed, ie. Ruleset(rule1, rule2, rule3).\n\nKeywords\n\nproc: a Processor to specificy the hardware to run simulations on,    like SingleCPU, ThreadedCPU or CuGPU when    KernelAbstractions.jl and a CUDA gpu is available. \nopt: a PerformanceOpt to specificy optimisations like   SparseOpt. Defaults to NoOpt.\nboundary: what to do with boundary of grid edges.   Options are Remove() or Wrap(), defaulting to Remove.\ncellsize: size of cells.\ntimestep: fixed timestep where this is required for some rules.    eg. Month(1) or 1u\"s\".\n\n\n\n\n\n","category":"type"},{"location":"#Options/Flags","page":"DynamicGrids","title":"Options/Flags","text":"","category":"section"},{"location":"#Boundary-conditions","page":"DynamicGrids","title":"Boundary conditions","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"BoundaryCondition\nWrap\nRemove","category":"page"},{"location":"#DynamicGrids.BoundaryCondition","page":"DynamicGrids","title":"DynamicGrids.BoundaryCondition","text":"BoundaryCondition\n\nAbstract supertype for flags that specify the boundary conditions used in the simulation, used in inbounds and to update NeighborhoodRule grid padding. These determine what happens when a neighborhood or jump extends outside of the grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Wrap","page":"DynamicGrids","title":"DynamicGrids.Wrap","text":"Wrap <: BoundaryCondition\n\nWrap()\n\nBoundaryCondition flag to wrap cordinates that boundary boundaries back to the opposite side of the grid.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; boundary=Wrap())\n# or\noutput = sim!(output, rule; boundary=Wrap())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Remove","page":"DynamicGrids","title":"DynamicGrids.Remove","text":"Remove <: BoundaryCondition\n\nRemove()\n\nBoundaryCondition flag that specifies to assign padval to cells that overflow  grid boundaries. padval defaults to zero(eltype(grid)) but can be assigned as a keyword argument to an Output.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; boundary=Remove())\n# or\noutput = sim!(output, rule; boundary=Remove())\n\n\n\n\n\n","category":"type"},{"location":"#Hardware-selection","page":"DynamicGrids","title":"Hardware selection","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.Processor\nDynamicGrids.CPU\nSingleCPU\nThreadedCPU\nDynamicGrids.GPU\nCuGPU\nCPUGPU","category":"page"},{"location":"#DynamicGrids.Processor","page":"DynamicGrids","title":"DynamicGrids.Processor","text":"Processor\n\nAbstract supertype for selecting a hardware processor, such as ia CPU or GPU.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CPU","page":"DynamicGrids","title":"DynamicGrids.CPU","text":"CPU <: Processor\n\nAbstract supertype for CPU processors.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleCPU","page":"DynamicGrids","title":"DynamicGrids.SingleCPU","text":"SingleCPU <: CPU\n\nSingleCPU()\n\nProcessor flag that specifies to use a single thread on a single CPU.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; proc=SingleCPU())\n# or\noutput = sim!(output, rule; proc=SingleCPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ThreadedCPU","page":"DynamicGrids","title":"DynamicGrids.ThreadedCPU","text":"ThreadedCPU <: CPU\n\nThreadedCPU()\n\nProcessor flag that specifies to use a Threads.nthreads() CPUs.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; proc=ThreadedCPU())\n# or\noutput = sim!(output, rule; proc=ThreadedCPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GPU","page":"DynamicGrids","title":"DynamicGrids.GPU","text":"GPU <: Processor\n\nAbstract supertype for GPU processors.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CuGPU","page":"DynamicGrids","title":"DynamicGrids.CuGPU","text":"CuGPU <: GPU\n\nCuGPU()\nCuGPU{threads_per_block}()\n\nruleset = Ruleset(rule; proc=CuGPU())\n# or\noutput = sim!(output, rule; proc=CuGPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CPUGPU","page":"DynamicGrids","title":"DynamicGrids.CPUGPU","text":"CPUGPU <: GPU\n\nCPUGPU()\n\nUses the CUDA GPU code on CPU using KernelAbstractions, to test it.\n\n\n\n\n\n","category":"type"},{"location":"#Performance-optimisation","page":"DynamicGrids","title":"Performance optimisation","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"PerformanceOpt\nNoOpt\nSparseOpt","category":"page"},{"location":"#DynamicGrids.PerformanceOpt","page":"DynamicGrids","title":"DynamicGrids.PerformanceOpt","text":"PerformanceOpt\n\nAbstract supertype for performance optimisation flags.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.NoOpt","page":"DynamicGrids","title":"DynamicGrids.NoOpt","text":"NoOpt <: PerformanceOpt\n\nNoOpt()\n\nFlag to run a simulation without performance optimisations besides basic high performance programming. Still fast, but not intelligent about the work that it does: all cells are run for all rules.\n\nNoOpt is the default opt method.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOpt","page":"DynamicGrids","title":"DynamicGrids.SparseOpt","text":"SparseOpt <: PerformanceOpt\n\nSparseOpt()\n\nAn optimisation flag that ignores all zero values in the grid.\n\nFor low-density simulations performance may improve by orders of magnitude, as only used cells are run.\n\nThis is complicated for optimising neighborhoods - they must run if they contain just one non-zero cell.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; opt=SparseOpt())\n# or\noutput = sim!(output, rule; opt=SparseOpt())\n\nSparseOpt is best demonstrated with this simulation, where the grey areas do not run except where the neighborhood partially hangs over an area that is not grey:\n\n(Image: SparseOpt demonstration)\n\n\n\n\n\n","category":"type"},{"location":"#Rules","page":"DynamicGrids","title":"Rules","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Rule\nDynamicGrids.SetRule","category":"page"},{"location":"#DynamicGrids.Rule","page":"DynamicGrids","title":"DynamicGrids.Rule","text":"Rule\n\nA Rule object contains the information required to apply an applyrule method to every cell of every timestep of a simulation.\n\nThe applyrule method follows the form:\n\n@inline applyrule(data::AbstractSimData, rule::YourRule, state, I::Tuple{Int,Int}) = ...\n\nWhere I is the cell index, and state is a single value, or a NamedTuple if multiple grids are requested. the AbstractSimData object can be used to access  current timestep and other simulation data and metadata.\n\nRules can be updated from the original rule before each timestep, in modifyrule:\n\nmodifyrule(rule::YourRule, data::AbstractSimData) = ...\n\nRules can also be run in sequence, as a Tuple or in a Rulesets.\n\nDynamicGrids guarantees that:\n\nmodifyrule is run once for every rule for every timestep.   The result is passed to applyrule, but not retained after that.\napplyrule is run once for every rule, for every cell, for every timestep, unless an   optimisation like SparseOpt is enable to skips empty cells.\nthe output of running a rule for any cell does not affect the input of the   same rule running anywhere else in the grid.\nrules later in the sequence are passed grid state updated by the earlier rules.\nmasked areas and wrapped or removed boundary regions are updated between all rules and    timesteps.\n\nMultiple grids\n\nThe NamedTuple keys will match the grid keys in R, which is a type like  Tuple{:key1,:key1}. Note the names are user-specified, and should never be fixed by a Rule.\n\nRead grid names be retrieved from the type here as R1 and R2, while write grids are W1 and W2.\n\napplyrule(data::AbstractSimData, rule::YourCellRule{Tuple{R1,R2},Tuple{W1,W2}}, state, I) where {R1,R2,W1,W2}\n\nBy default the output is written to the current cell in the specified W write grid/s. Rules writing to multiple grids, simply return a Tuple in the order specified by the W type params.\n\nRule Performance\n\nRules may run many millions of times during a simulation. They need to be fast. Some basic guidlines for writing rules are:\n\nNever allocate memory in a Rule if you can help it.\nType stability is essential. isinferred is useful to check   if your rule is type-stable.\nUsing the @inline macro on applyrule can help force inlining your   code into the simulation.\nReading and writing from multiple grids is expensive due to additional load   on fast cahce memory. Try to limit the number of grids you use.\nUse a graphical profiler, like ProfileView.jl, to check your rules overall   performance when run with sim!.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetRule","page":"DynamicGrids","title":"DynamicGrids.SetRule","text":"SetRule <: Rule\n\nAbstract supertype for rules that manually write to the grid in some way.\n\nThese must define methods of applyrule!.\n\n\n\n\n\n","category":"type"},{"location":"#CellRule","page":"DynamicGrids","title":"CellRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"CellRule\nCell\nCopyTo","category":"page"},{"location":"#DynamicGrids.CellRule","page":"DynamicGrids","title":"DynamicGrids.CellRule","text":"Cellrule <: Rule\n\nA Rule that only writes and uses a state from single cell of the read grids, and has its return value written back to the same cell(s).\n\nThis limitation can be useful for performance optimisation, such as wrapping rules in Chain so that no writes occur between rules.\n\nCellRule is defined with :\n\nstruct YourCellRule{R,W} <: CellRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule(data::AbstractSimData, rule::YourCellRule{R,W}, state, I) where {R,W}\n    state * 2\nend\n\nAs the index I is provided in applyrule, you can use it to look up Aux data. \n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Cell","page":"DynamicGrids","title":"DynamicGrids.Cell","text":"Call <: CellRule\n\nCell(f)\nCell{R,W}(f)\n\nA CellRule that applies a function f to the R grid value,  or Tuple of values, and returns the W grid value or Tuple of values.\n\nEspecially convenient with do notation.\n\nExample\n\nDouble the cell value in grid :a:\n\nsimplerule = Cell{Tuple{:a}() do a\n    2a\nend\n\nIf you need to use multiple grids (a and b), use the R and W type parameters. If you want to use external variables, wrap the whole thing in a let block, for performance. This rule sets the new value of b to the value of a to b times scalar y:\n\nrule = let y = y\n    rule = Cell{Tuple{:a,:b},:b}() do (a, b)\n        a + b * y\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CopyTo","page":"DynamicGrids","title":"DynamicGrids.CopyTo","text":"CopyTo <: CellRule\n\nCopyTo{W}(from)\nCopyTo{W}(; from)\n\nA simple rule that copies aux array slices to a grid over time. This can be used for comparing simulation dynamics to aux data dynamics.\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodRule","page":"DynamicGrids","title":"NeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"NeighborhoodRule\nNeighbors\nConvolution\nLife","category":"page"},{"location":"#DynamicGrids.NeighborhoodRule","page":"DynamicGrids","title":"DynamicGrids.NeighborhoodRule","text":"NeighborhoodRule <: Rule\n\nA Rule that only accesses a neighborhood centered around the current cell. NeighborhoodRule is applied with the method:\n\napplyrule(data::AbstractSimData, rule::YourNeighborhoodRule, state, I::Tuple{Int,Int})\n\nNeighborhoodRule must have a neighborhood method or field, that holds a Neighborhood object. neighbors(rule) returns an iterator over the surrounding cell pattern defined by the Neighborhood.\n\nFor each cell in the grids the neighborhood buffer will be updated for use in the applyrule method, managed to minimise array reads.\n\nThis allows memory optimisations and the use of high-perforance routines on the neighborhood buffer. It also means that and no bounds checking is required in neighborhood code.\n\nFor neighborhood rules with multiple read grids, the first is always the one used for the neighborhood, the others are passed in as additional state for the cell. Any grids can be written to, but only for the current cell.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Neighbors","page":"DynamicGrids","title":"DynamicGrids.Neighbors","text":"Neighbors <: NeighborhoodRule\n\nNeighbors(f, neighborhood=Moor(1))\nNeighbors{R,W}(f, neighborhood=Moore())\n\nA NeighborhoodRule that receives a Neighborhood object  for the first R grid, followed by the cell value/s for the required grids,  as with Cell.\n\nReturned value(s) are written to the W grid/s.\n\nAs with all NeighborhoodRule, you do not have to check bounds at grid edges, that is handled for you internally.\n\nUsing SparseOpt may improve neighborhood performance when a specific value (often zero) is common and can be safely ignored.\n\nExample\n\nRuns the game of life on grid :a:\n\nconst sum_states = (0, 0, 1, 0, 0, 0, 0, 0, 0), \n                   (0, 0, 1, 1,  0, 0, 0, 0, 0)\nlife = Neighbors{:a}(Moore(1)) do hood, a\n    sum_states[a + 1][sum(hood) + 1]\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Convolution","page":"DynamicGrids","title":"DynamicGrids.Convolution","text":"Convolution <: NeighborhoodRule\n\nConvolution(kernel::AbstractArray)\nConvolution{R,W}(kernel::AbstractArray)\n\nA NeighborhoodRule that runs a convolution kernel over the grid.\n\nkernel must be a square matrix.\n\nPerformance\n\nSmall radius convolutions in DynamicGrids.jl will be comparable or even faster than using DSP.jl or ImageConvolutions.jl. As the radius increases these packages will be a lot faster.\n\nBut Convolution is convenient to chain into a simulation, and combined with some other rules. It should perform reasonably well with all but very large kernels.\n\nExample\n\nrule = Convolution([0.05 0.1 0.05; 0.1 0.4 0.1; 0.05 0.1 0.05])\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Life","page":"DynamicGrids","title":"DynamicGrids.Life","text":"Life <: NeighborhoodRule\n\nLife(neighborhood, born=3, survive=(2, 3))\n\nRule for game-of-life style cellular automata. This is a demonstration of Cellular Automata more than a seriously optimised game of life rule.\n\nCells becomes active if it is empty and the number of neightbors is a number in the born, and remains active the cell is active and the number of neightbors is in survive.\n\nExamples (gleaned from CellularAutomata.jl)\n\nusing DynamicGrids, Distributions\n\n# Use `Binomial` to tweak the density random true values\ninit = Bool.(rand(Binomial(1, 0.5), 70, 70))\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:red)\n\n# Morley\nsim!(output, Ruleset(Life(born=[3, 6, 8], survive=[2, 4, 5])))\n\n# 2x2\nsim!(output, Ruleset(Life(born=[3, 6], survive=[1, 2, 5])))\n\n# Dimoeba\ninit = rand(Bool, 400, 300)\ninit[:, 100:200] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:blue, style=Braile())\nsim!(output, Life(born=(3, 5, 6, 7, 8),  survive=(5, 6, 7, 8)))\n\n## No death\nsim!(output, Life(born=(3,),  survive=(0, 1, 2, 3, 4, 5, 6, 7, 8)))\n\n## 34 life\nsim!(output, Life(born=(3, 4), survive=(3, 4)))\n\n# Replicator\ninit = fill(true, 300,300)\ninit[:, 100:200] .= false\ninit[10, :] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:yellow)\nsim!(output, Life(born=(1, 3, 5, 7),  survive=(1, 3, 5, 7)))\nnothing\n\n# output\n\n\n(Image: REPL Life)\n\n\n\n\n\n","category":"type"},{"location":"#SetCellRule","page":"DynamicGrids","title":"SetCellRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetCellRule\nSetCell","category":"page"},{"location":"#DynamicGrids.SetCellRule","page":"DynamicGrids","title":"DynamicGrids.SetCellRule","text":"SetCellRule <: Rule\n\nAbstract supertype for rules that can manually write to any cells of the grid that they need to.\n\nSetCellRule is applied with a method like this, that simply adds 1 to the current cell:\n\nfunction applyrule!(data::AbstractSimData, rule::YourSetCellRule, state, I)\n    add!(data, 1, I...)\n    return nothing\nend\n\nNote the ! bang - this method alters the state of data.\n\nTo update the grid, you can use atomic operators add!, sub!, min!, max!, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nIt there are multiple write grids, you will need to get the grid keys from type parameters, here W1 and W2:\n\nfunction applyrule(data, rule::YourSetCellRule{R,Tuple{W1,W2}}, state, I) where {R,W1,W2}\n     add!(data[W1], 1, I...)\n     add!(data[W2], 2, I...)\n     return nothing\nend\n\nDynamicGrids guarantees that:\n\nvalues written to anywhere on the grid do not affect other cells in   the same rule at the same timestep.\nvalues written to anywhere on the grid are available to the next rule in the   sequence, or the next timestep.\nif atomic operators are always used, race conditions will not occur on any hardware.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetCell","page":"DynamicGrids","title":"DynamicGrids.SetCell","text":"SetCell <: SetCellRule\n\nSetCell(f)\nSetCell{R,W}(f)\n\nA SetCellRule to manually write to the array where you need to. f is passed a AbstractSimData object, the grid state or Tuple of grid  states for the cell and a Tuple{Int,Int} index of the current cell.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nExample\n\nChoose a destination cell and if it is in the grid, update it based on the  state of both grids:\n\nrule = SetCell{Tuple{:a,:b},:b}() do data, (a, b), I \n    dest = your_dest_pos_func(I)\n    if isinbounds(data, dest)\n        destval = your_dest_val_func(a, b)\n        add!(data[:b], destval, dest...)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#SetNeighborhoodRule","page":"DynamicGrids","title":"SetNeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetNeighborhoodRule\nSetNeighbors","category":"page"},{"location":"#DynamicGrids.SetNeighborhoodRule","page":"DynamicGrids","title":"DynamicGrids.SetNeighborhoodRule","text":"SetNeighborhoodRule <: SetRule\n\nA SetRule that only writes to its neighborhood, and does not need to bounds-check.\n\npositions and offsets are useful iterators for modifying neighborhood values. \n\nSetNeighborhoodRule rules must return a Neighborhood object from the function  neighborhood(rule). By default this is rule.neighborhood. If this property exists,  no interface methods are required.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetNeighbors","page":"DynamicGrids","title":"DynamicGrids.SetNeighbors","text":"SetNeighbors <: SetNeighborhoodRule\n\nSetNeighbors(f, neighborhood=Moor(1))\nSetNeighbors{R,W}(f, neighborhood=Moor(1))\n\nA SetCellRule to manually write to the array with the specified neighborhood. Indexing outside the neighborhood is undefined behaviour.\n\nFunction f is passed four arguments: a SimData object, the specified Neighborhood object, the grid state or Tuple of grid states for the cell,  and the Tuple{Int,Int} index of the current cell.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods can be safely combined writes from all grid cells.\n\nDirectly using setindex! is possible, but may cause bugs as multiple cells may write to the same location in an unpredicatble order. As a rule, directly setting a neighborhood index should only be done if it always sets the samevalue - then it can be guaranteed that any writes from othe grid cells reach the same result.\n\nneighbors, offsets and positions are useful methods for SetNeighbors rules.\n\nExample\n\nThis example adds a value to all neighbors:\n\nrule = SetNeighbors{:a}() do data, neighborhood, a, I\n    add_to_neighbors = your_func(a)\n    for pos in positions(neighborhood)\n        add!(data[:b], add_to_neighbors, pos...)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#SetGridRule","page":"DynamicGrids","title":"SetGridRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetGridRule\nSetGrid","category":"page"},{"location":"#DynamicGrids.SetGridRule","page":"DynamicGrids","title":"DynamicGrids.SetGridRule","text":"SetGridRule <: Rule\n\nA Rule applies to whole grids. This is used for operations that don't benefit from having neighborhood buffering or looping over the grid handled for them, or any specific optimisations. Best suited to simple functions like rand!(grid) or using convolutions from other packages like DSP.jl. They may also be useful for doing other custom things that don't fit into the DynamicGrids.jl framework during the simulation.\n\nGrid rules specify the grids they want and are sequenced just like any other grid.\n\nstruct YourSetGridRule{R,W} <: SetGridRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule!(data::AbstractSimData, rule::YourSetGridRule{R,W}) where {R,W}\n    rand!(data[W])\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetGrid","page":"DynamicGrids","title":"DynamicGrids.SetGrid","text":"SetGrid{R,W}(f)\n\nApply a function f to fill whole grid/s.\n\nExample\n\nThis example sets grid a to equal grid b:\n\nrule = SetGrid{:a,:b}() do a, b\n    b .= a\nend\n\n\n\n\n\n","category":"type"},{"location":"#Rule-wrappers","page":"DynamicGrids","title":"Rule wrappers","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"RuleWrapper\nChain\nRunIf\nRunAt","category":"page"},{"location":"#DynamicGrids.RuleWrapper","page":"DynamicGrids","title":"DynamicGrids.RuleWrapper","text":"RuleWrapper <: Rule\n\nA Rule that wraps other rules, altering their behaviour or how they are run.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Chain","page":"DynamicGrids","title":"DynamicGrids.Chain","text":"Chain(rules...)\nChain(rules::Tuple)\n\nChains allow chaining rules together to be completed in a single processing step, without intermediate reads or writes from grids.\n\nThey are potentially compiled together into a single function call, especially if you use @inline on all applyrule methods. Chain can hold either all CellRule or NeighborhoodRule followed by CellRule.\n\nSetRule can't be used in Chain, as it doesn't have a return value.\n\n(Image: Chain rule diagram)\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RunIf","page":"DynamicGrids","title":"DynamicGrids.RunIf","text":"RunIf(f, rule)\n\nRunIfs allows wrapping a rule in a condition, passed the SimData object and the cell state and index.\n\n`julia RunIf(dispersal) do data state I     state = oneunit(state) end `\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RunAt","page":"DynamicGrids","title":"DynamicGrids.RunAt","text":"RunAt(rules...)\nRunAt(rules::Tuple)\n\nRunAts allow running a Rule or multiple Rules at a lower frequeny than the main simulation, using a range matching the main tspan but with a larger span, or specific events - by using a vector of arbitrary times in tspan.\n\n\n\n\n\n","category":"type"},{"location":"#Parameter-sources","page":"DynamicGrids","title":"Parameter sources","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"ParameterSource\nAux\nGrid\nDynamicGrids.AbstractDelay\nDelay\nFrame\nLag","category":"page"},{"location":"#DynamicGrids.ParameterSource","page":"DynamicGrids","title":"DynamicGrids.ParameterSource","text":"ParameterSource\n\nAbstract supertypes for parameter source wrappers. These allow parameters to be retreived from auxilliary data or from other grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Aux","page":"DynamicGrids","title":"DynamicGrids.Aux","text":"Aux <: ParameterSource\n\nAux{K}()\nAux(K::Symbol)\n\nUse auxilary array with key K as a parameter source.\n\nImplemented in rules with:\n\nget(data, rule.myparam, index...)\n\nWhen an Aux param is specified at rule construction with:\n\nrule = SomeRule(; myparam=Aux{:myaux})\noutput = ArrayOutput(init; aux=(myaux=myauxarray,))\n\nIf the array is a DimensionalData.jl DimArray with a Ti (time) dimension, the correct interval will be selected automatically, precalculated for each timestep so it has no significant overhead.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Grid","page":"DynamicGrids","title":"DynamicGrids.Grid","text":"Grid <: ParameterSource\n\nGrid{K}()\nGrid(K::Symbol)\n\nUse grid with key K as a parameter source.\n\nImplemented in rules with:\n\nget(data, rule.myparam, index...)\n\nAnd specified at rule construction with:\n\nSomeRule(; myparam=Grid{:somegrid})\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractDelay","page":"DynamicGrids","title":"DynamicGrids.AbstractDelay","text":"AbstractDelay <: ParameterSource\n\nAbstract supertype for ParameterSources that use data from a grid with a time delay.\n\nWARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Delay","page":"DynamicGrids","title":"DynamicGrids.Delay","text":"Delay <: AbstractDelay\n\nDelay{K}(steps)\n\nDelay allows using a Grid from previous timesteps as a parameter source as  a field in any Rule that uses get to retrieve it's parameters.\n\nIt must be coupled with an output that stores all frames, so that @assert  DynamicGrids.isstored(output) == true.  With GraphicOutputs this may be  acheived by using the keyword argument store=true when constructing the output object.\n\nType Parameters\n\nK::Symbol: matching the name of a grid in init.\n\nArguments\n\nsteps: As a user supplied parameter, this is a multiple of the step size of the output    tspan. This is automatically replaced with an integer for each step. Used within the    code in a rule, it must be an Int number of frames, for performance.\n\nExample\n\n`julia SomeRule(     someparam=Delay(grid_a Month(3))     otherparam=1075 ) `\n\nWARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Frame","page":"DynamicGrids","title":"DynamicGrids.Frame","text":"Frame <: AbstractDelay\n\nFrame{K}(frame)\n\nFrame allows using a Grid from a specific previous timestep from within  a rule, using get. It should only be used within rule code, not as a parameter.\n\nType Parameter\n\nK::Symbol: matching the name of a grid in init.\n\nArgument\n\nframe::Int: the exact frame number to use.\n\nWARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Lag","page":"DynamicGrids","title":"DynamicGrids.Lag","text":"Lag <: AbstractDelay\n\nLag{K}(frames::Int)\n\nLag allows using a Grid from a specific previous frame from within a rule,  using get. It is similar to Delay, but an integer amount of steps should be  used, instead of a quantity related to the simulation tspan. Used within rule code, the lower bound will not be checked. Do this manually, or use Frame instead.\n\nType Parameter\n\nK::Symbol: matching the name of a grid in init.\n\nArgument\n\nframes::Int: number of frames to lag by, 1 or larger.\n\nExample\n\n`julia SomeRule(     someparam=Delay(grid_a Month(3))     otherparam=1075 ) `\n\nWARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"type"},{"location":"#Custom-Rule-interface-and-helpers","page":"DynamicGrids","title":"Custom Rule interface and helpers","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.applyrule\nDynamicGrids.applyrule!\nDynamicGrids.modifyrule\nisinferred","category":"page"},{"location":"#DynamicGrids.applyrule","page":"DynamicGrids","title":"DynamicGrids.applyrule","text":"applyrule(data::AbstractSimData, rule::Rule{R,W}, state, index::Tuple{Int,Int}) -> cell value(s)\n\nApply a rule to the cell state and return values to write to the grid(s).\n\nThis is called in maprule! methods during the simulation, not by the user. Custom Rule implementations must define this method.\n\nArguments:\n\ndata : AbstractSimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates\n\nReturns the value(s) to be written to the current cell(s) of the grids specified by the W type parameter.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.applyrule!","page":"DynamicGrids","title":"DynamicGrids.applyrule!","text":"applyrule!(data::AbstractSimData, rule::{R,W}, state, index::Tuple{Int,Int}) -> Nothing\n\nApply a rule to the cell state and manually write to the grid data array. Used in all rules inheriting from SetCellRule.\n\nThis is called in internal maprule! methods during the simulation, not by the user. Custom SetCellRule implementations must define this method.\n\nOnly grids specified with the W type parameter will be writable from data.\n\nArguments:\n\ndata : AbstractSimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates - t: the current time step\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.modifyrule","page":"DynamicGrids","title":"DynamicGrids.modifyrule","text":"modifyrule(rule::Rule, data::AbstractSimData) -> Rule\n\nPrecalculates rule fields at each timestep. Define this method if a Rule has fields that need to be updated over time.\n\nRules are usually immutable (it's faster), so precalc is expected to returns a new rule object with changes applied to it.  Setfield.jl or Acessors.jl may help with updating the immutable struct.\n\nThe default behaviour is to return the existing rule without change.\n\nUpdated rules are be discarded, and the rule argument is always be the original object passed in.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinferred","page":"DynamicGrids","title":"DynamicGrids.isinferred","text":"isinferred(output::Output, ruleset::Ruleset)\nisinferred(output::Output, rules::Rule...)\n\nTest if a custom rule is inferred and the return type is correct when applyrule or applyrule! is run.\n\nType-stability can give orders of magnitude improvements in performance.\n\n\n\n\n\n","category":"function"},{"location":"#Methods-and-objects-for-use-in-applyrule-and/or-modifyrule","page":"DynamicGrids","title":"Methods and objects for use in applyrule and/or modifyrule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"get\nDynamicGrids.isinbounds\nDynamicGrids.inbounds\nDynamicGrids.ismasked\nDynamicGrids.init\nDynamicGrids.aux\nDynamicGrids.mask\nDynamicGrids.tspan\nDynamicGrids.timestep\nDynamicGrids.currenttimestep\nDynamicGrids.currenttime\nDynamicGrids.currentframe\nDynamicGrids.AbstractSimData\nDynamicGrids.SimData\nDynamicGrids.RuleData\nDynamicGrids.GridData\nDynamicGrids.ReadableGridData\nDynamicGrids.WritableGridData\nDynamicGrids.AbstractSimSettings\nDynamicGrids.SimSettings","category":"page"},{"location":"#Base.get","page":"DynamicGrids","title":"Base.get","text":"Base.get(data::AbstractSimData, key::Union{Symbol,Aux,Grid}, I...)\n\nAllows parameters to be taken from a single value, another grid or an aux array.\n\nIf aux arrays are a DimArray time sequence (with a Ti dim) the currect date will be  calculated automatically.\n\nCurrently this is cycled by default, but will use Cyclic mode in DiensionalData.jl in future.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinbounds","page":"DynamicGrids","title":"DynamicGrids.isinbounds","text":"isinbounds(data, I::Tuple) -> Bool\nisinbounds(data, I...) -> Bool\n\nCheck that a coordinate is within the grid, usually in SetCellRule.\n\nUnlike inbounds, BoundaryCondition status is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.inbounds","page":"DynamicGrids","title":"DynamicGrids.inbounds","text":"inbounds(data::AbstractSimData, I::Tuple) -> Tuple{NTuple{2,Int}, Bool}\ninbounds(data::AbstractSimData, I...) -> Tuple{NTuple{2,Int}, Bool}\n\nCheck grid boundaries for a coordinate before writing in SetCellRule.\n\nReturns a Tuple containing a coordinates Tuple and a Bool - true if the cell is inside the grid bounds, false if not.\n\nBoundaryCondition of type Remove returns the coordinate and false  to skip coordinates that boundary outside of the grid.\n\nWrap returns a tuple with the current position or it's wrapped equivalent, and true as it is allways in-bounds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.ismasked","page":"DynamicGrids","title":"DynamicGrids.ismasked","text":"ismasked(data, I...)\n\nCheck if a cell is masked, using the mask array.\n\nUsed used internally during simulations to skip masked cells.\n\nIf mask was not passed to the Output constructor or sim! it defaults to nothing and false is always returned.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.init","page":"DynamicGrids","title":"DynamicGrids.init","text":"init(obj) -> Union{AbstractArray,NamedTUple}\n\nRetrieve the mask from an Output, Extent or AbstractSimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.aux","page":"DynamicGrids","title":"DynamicGrids.aux","text":"aux(obj, [key])\n\nRetrieve auxilary data NamedTuple from an Output, Extent or AbstractSimData object.\n\nGiven key specific data will be returned. key should be a Val{:symbol} for type stability and zero-cost access inside rules. Symbol will also work, but may be slow.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.mask","page":"DynamicGrids","title":"DynamicGrids.mask","text":"mask(obj) -> AbstractArray\n\nRetrieve the mask from an Output, Extent or AbstractSimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.tspan","page":"DynamicGrids","title":"DynamicGrids.tspan","text":"tspan(obj) -> AbstractRange\n\nRetrieve the time-span AbstractRange from an Output, Extent or AbstractSimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.timestep","page":"DynamicGrids","title":"DynamicGrids.timestep","text":"timestep(obj)\n\nRetrieve the timestep size from an Output, Extent, Ruleset or AbstractSimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttimestep","page":"DynamicGrids","title":"DynamicGrids.currenttimestep","text":"currenttimestep(simdata::AbstractSimData)\n\nRetrieve the current timestep from a AbstractSimData object.\n\nThis may be different from the timestep. If the timestep is Month, currenttimestep will return Seconds for the length of the specific month.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttime","page":"DynamicGrids","title":"DynamicGrids.currenttime","text":"currenttime(simdata::AbstractSimData)\n\nRetrieve the current simulation time from a AbstractSimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currentframe","page":"DynamicGrids","title":"DynamicGrids.currentframe","text":"currentframe(simdata::AbstractSimData) -> Int\n\nRetrieve the current simulation frame a AbstractSimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.AbstractSimData","page":"DynamicGrids","title":"DynamicGrids.AbstractSimData","text":"AbstractSimData\n\nSupertype for simulation data objects. Thes hold grids, settings other objects required to run the simulation and potentially requireing access from rules.\n\nAn AbstractSimData object is accessable in applyrule as the first parameter.\n\nMultiple grids can be indexed into using their key if you need to read from arbitrary locations:\n\nfunciton applyrule(data::AbstractSimData, rule::SomeRule{Tuple{A,B}},W}, (a, b), I) where {A,B,W}\n    grid_a = data[A]\n    grid_b = data[B]\n    ...\n\nIn single-grid simulations AbstractSimData objects can be indexed directly as  if they are a Matrix.\n\nMethods\n\ncurrentframe(data): get the current frame number, an Int\ncurrenttime(data): the current frame time, which isa eltype(tspan)\naux(data, args...): get the aux data NamedTuple, or Nothing.   adding a Symbol or Val{:symbol} argument will get a field of aux.\ntspan(data): get the simulation time span, an AbstractRange.\ntimestep(data): get the simulaiton time step.\nboundary(data) : returns the BoundaryCondition - Remove or Wrap.\npadval(data) : returns the value to use as grid border padding.\n\nThese are available, but you probably shouldn't use them and their behaviour is not guaranteed in furture versions. They will mean rule is useful only in specific contexts.\n\nsettings(data): get the simulaitons SimSettings object.\nextent(data) : get the simulation AbstractExtent object.\ninit(data) : get the simulation init AbstractArray/NamedTuple\nmask(data) : get the simulation mask AbstractArray\nsource(data) : get the source grid that is being read from.\ndest(data) : get the dest grid that is being written to.\nradius(data) : returns the Int radius used on the grid,   which is also the amount of border padding.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SimData","page":"DynamicGrids","title":"DynamicGrids.SimData","text":"SimData <: AbstractSimData\n\nSimData(extent::AbstractExtent, ruleset::AbstractRuleset)\n\nSimulation dataset to hold all intermediate arrays, timesteps and frame numbers for the current frame of the simulation.\n\nAdditional methods not found in AbstractSimData:\n\nrules(d::SimData) : get the simulation rules.\nruleset(d::SimData) : get the simulation AbstractRuleset.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RuleData","page":"DynamicGrids","title":"DynamicGrids.RuleData","text":"SimData <: AbstractSimData\n\nRuleData(extent::AbstractExtent, settings::SimSettings)\n\nAbstractSimData object that is passed to rules. Basically  a trimmed-down version of SimData.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GridData","page":"DynamicGrids","title":"DynamicGrids.GridData","text":"GridData <: AbstractArray\n\nSimulation data specific to a single grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ReadableGridData","page":"DynamicGrids","title":"DynamicGrids.ReadableGridData","text":"ReadableGridData <: GridData\n\nReadableGridData(grid::GridData)\nReadableGridData{S,R}(init::AbstractArray, mask, opt, boundary, padval)\n\nSimulation data and storage passed to rules for each timestep.\n\nType parameters\n\nY: number of rows \nX: number of columns\nR: grid padding radius \n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WritableGridData","page":"DynamicGrids","title":"DynamicGrids.WritableGridData","text":"WritableGridData <: GridData\n\nWritableGridData(grid::GridData)\n\nPassed to rules as write grids, and can be written to directly as an array,  or preferably using add! etc. All writes handle updates to SparseOpt()  and writing to the correct source/dest array.\n\nReads are always from the source array, as rules must not be sequential between cells. This means using e.g. += is not supported, instead use add!.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractSimSettings","page":"DynamicGrids","title":"DynamicGrids.AbstractSimSettings","text":"AbstractSimSettings\n\nAbstract supertype for SimSettings object and variants.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SimSettings","page":"DynamicGrids","title":"DynamicGrids.SimSettings","text":"SimSettings <: AbstractSimSettings\n\nHolds settings for the simulation, in a Ruleset or SimData object.\n\n\n\n\n\n","category":"type"},{"location":"#Neighborhoods","page":"DynamicGrids","title":"Neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Neighborhood\nRadialNeighborhood\nMoore\nWindow\nAbstractPositionalNeighborhood\nPositional\nVonNeumann\nLayeredPositional","category":"page"},{"location":"#DynamicGrids.Neighborhood","page":"DynamicGrids","title":"DynamicGrids.Neighborhood","text":"Neighborhood\n\nNeighborhoods define the pattern of surrounding cells in the \"neighborhood\" of the current cell. The neighbors function returns the surrounding cells as an iterable.\n\nThe main kinds of neighborhood are demonstrated below:\n\n(Image: Neighborhoods)\n\nNeighborhoods can be used in NeighborhoodRule and SetNeighborhoodRule - the same shapes with different purposes. In a NeighborhoodRule the neighborhood specifies which cells around the current cell are returned as an iterable from the neighbors function.  These can be counted, summed, compared, or multiplied with a kernel in an  AbstractKernelNeighborhood, using kernelproduct.\n\nIn SetNeighborhoodRule neighborhoods give the locations of cells around the central cell, as [offsets] and absolute positions around the index of each neighbor. These can then be written to manually.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RadialNeighborhood","page":"DynamicGrids","title":"DynamicGrids.RadialNeighborhood","text":"RadialNeighborhood <: Neighborhood\n\nSquare neighborhoods with radius R, and side length 2R + 1\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Moore","page":"DynamicGrids","title":"DynamicGrids.Moore","text":"Moore <: RadialNeighborhood\n\nMoore(radius::Int=1)\n\nMoore neighborhoods define the neighborhood as all cells within a horizontal or vertical distance of the central cell. The central cell is omitted.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Window","page":"DynamicGrids","title":"DynamicGrids.Window","text":"Window <: RadialNeighborhood\n\nWindow{R}()\n\nA neighboorhood of radius R that includes the central cell. R = 1 gives a 3x3 matrix.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractPositionalNeighborhood","page":"DynamicGrids","title":"DynamicGrids.AbstractPositionalNeighborhood","text":"AbstractPositionalNeighborhood <: Neighborhood\n\nNeighborhoods are tuples or vectors of custom coordinates tuples that are specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Positional","page":"DynamicGrids","title":"DynamicGrids.Positional","text":"Positional <: AbstractPositionalNeighborhood\n\nPositional(coord::Tuple{Vararg{Int}}...)\nPositional(offsets::Tuple{Tuple{Vararg{Int}}})\n\nNeighborhoods that can take arbitrary shapes by specifying each coordinate, as Tuple{Int,Int} of the row/column distance (positive and negative) from the central point.\n\nThe neighborhood radius is calculated from the most distance coordinate. For simplicity the buffer read from the main grid is a square with sides 2r + 1 around the central point.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.VonNeumann","page":"DynamicGrids","title":"DynamicGrids.VonNeumann","text":"VonNeumann(radius=1) -> Positional\n\nA convenience wrapper to build Von-Neumann neighborhoods as a Positional neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.LayeredPositional","page":"DynamicGrids","title":"DynamicGrids.LayeredPositional","text":"LayeredPositional <: AbstractPositional\n\nLayeredPositional(layers::Positional...)\n\nSets of Positional neighborhoods that can have separate rules for each set.\n\nneighbors for LayeredPositional returns a tuple of iterators for each neighborhood layer.\n\n\n\n\n\n","category":"type"},{"location":"#Methods-for-use-with-neighborhood-rules-and-neighborhoods","page":"DynamicGrids","title":"Methods for use with neighborhood rules and neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"neighborhood\nradius","category":"page"},{"location":"#DynamicGrids.neighborhood","page":"DynamicGrids","title":"DynamicGrids.neighborhood","text":"neighborhood(x::Union{NeighborhoodRule,SetNeighborhoodRule}}) -> Neighborhood\n\nReturns a rules neighborhood object\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.radius","page":"DynamicGrids","title":"DynamicGrids.radius","text":"radius(rule, [key]) -> Int\n\nReturn the radius of a rule or ruleset if it has one, otherwise zero.\n\n\n\n\n\n","category":"function"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Useful with NeighborhoodRule:","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"neighbors","category":"page"},{"location":"#DynamicGrids.neighbors","page":"DynamicGrids","title":"DynamicGrids.neighbors","text":"neighbors(x::Union{Neighborhood,NeighborhoodRule}}) -> iterable\n\nReturns an iteraterable generator over all cells in the neighborhood.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Useful with SetNeighborhoodRule:","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"positions\noffsets","category":"page"},{"location":"#DynamicGrids.positions","page":"DynamicGrids","title":"DynamicGrids.positions","text":"positions(x::Union{Neighborhood,NeighborhoodRule}}, cellindex::Tuple) -> iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  in the main array. Useful in SetNeighborhoodRule for  setting neighborhood values.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.offsets","page":"DynamicGrids","title":"DynamicGrids.offsets","text":"offsets(x::Union{Neighborhood,NeighborhoodRule}}) -> iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  offset from the central cell.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"#Convolution-kernel-neighborhoods","page":"DynamicGrids","title":"Convolution kernel neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"AbstractKernelNeighborhood\nKernel\nkernel\nkernelproduct","category":"page"},{"location":"#DynamicGrids.AbstractKernelNeighborhood","page":"DynamicGrids","title":"DynamicGrids.AbstractKernelNeighborhood","text":"AbstractKernelNeighborhood <: Neighborhood\n\nAbstract supertype for kernel neighborhoods.\n\nThese can wrap any other neighborhood object, and include a kernel of the same length and positions as the neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Kernel","page":"DynamicGrids","title":"DynamicGrids.Kernel","text":"Kernel <: AbstractKernelNeighborhood\n\nKernel(neighborhood, kernel)\n\nWrap any other neighborhood object, and includes a kernel of the same length and positions as the neighborhood.\n\nR = 1 gives 3x3 matrices.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.kernel","page":"DynamicGrids","title":"DynamicGrids.kernel","text":"kernel(hood::AbstractKernelNeighborhood) => iterable\n\nReturns the kernel object, an array or iterable matching the length of the neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.kernelproduct","page":"DynamicGrids","title":"DynamicGrids.kernelproduct","text":"kernelproduct(rule::NeighborhoodRule})\nkernelproduct(hood::AbstractKernelNeighborhood)\nkernelproduct(hood::Neighborhood, kernel)\n\nReturns the vector dot product of the neighborhood and the kernel, although differing from dot in that the dot product is not take for  vector members of the neighborhood - they are treated as scalars.\n\n\n\n\n\n","category":"function"},{"location":"#Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule","page":"DynamicGrids","title":"Atomic methods for SetCellRule and SetNeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Using these methods to modify grid values ensures cell independence, and also prevent race conditions with ThreadedCPU or [CuGPU].","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"add!\nsub!\nmin!\nmax!\nand!\nor!\nxor!","category":"page"},{"location":"#DynamicGrids.add!","page":"DynamicGrids","title":"DynamicGrids.add!","text":"add!(data::WritableGridData, x, I...)\n\nAdd the value x to a grid cell.\n\nExample useage\n\nfunction applyrule!(data::AbstractSimData, rule::My{A,B}, state, cellindex) where {A,B}\n\n    dest, is_inbounds = inbounds(data, (jump .+ cellindex)...)\n\n    # Update spotted cell if it's on the grid\n    is_inbounds && add!(data[W], state, dest...)\nend\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sub!","page":"DynamicGrids","title":"DynamicGrids.sub!","text":"sub!(data::WritableGridData, x, I...)\n\nSubtract the value x from a grid cell. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.min!","page":"DynamicGrids","title":"DynamicGrids.min!","text":"min!(data::WritableGridData, x, I...)\n\nSet a gride cell to the minimum of x and the current value. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.max!","page":"DynamicGrids","title":"DynamicGrids.max!","text":"max!(data::WritableGridData, x, I...)\n\nSet a gride cell to the maximum of x and the current value. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.and!","page":"DynamicGrids","title":"DynamicGrids.and!","text":"and!(data::WritableGridData, x, I...)\nand!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c & x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.or!","page":"DynamicGrids","title":"DynamicGrids.or!","text":"or!(data::WritableGridData, x, I...)\nor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c | x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.xor!","page":"DynamicGrids","title":"DynamicGrids.xor!","text":"xor!(data::WritableGridData, x, I...)\nxor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to xor(c, x). See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#Output","page":"DynamicGrids","title":"Output","text":"","category":"section"},{"location":"#Output-Types-and-Constructors","page":"DynamicGrids","title":"Output Types and Constructors","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Output\nArrayOutput\nResultOutput\nTransformedOutput\nGraphicOutput\nREPLOutput\nImageOutput\nGifOutput","category":"page"},{"location":"#DynamicGrids.Output","page":"DynamicGrids","title":"DynamicGrids.Output","text":"Output\n\nAbstract supertype for simulation outputs.\n\nOutputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherwise manipulate the simulation grids to improve performance, reduce memory overheads or similar.\n\nSimulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ArrayOutput","page":"DynamicGrids","title":"DynamicGrids.ArrayOutput","text":"ArrayOutput <: Output\n\nArrayOutput(init; tspan::AbstractRange, [aux, mask, padval])\n\nA simple output that stores each step of the simulation in a vector of arrays.\n\nArguments\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ResultOutput","page":"DynamicGrids","title":"DynamicGrids.ResultOutput","text":"ResultOutput <: Output\n\nResultOutput(init; tspan::AbstractRange, kw...)\n\nA simple output that only stores the final result, not intermediate frames.\n\nArguments\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.TransformedOutput","page":"DynamicGrids","title":"DynamicGrids.TransformedOutput","text":"TransformedOutput(f, init; tspan::AbstractRange, kw...)\n\nAn output that stores the result of some function f of the grid/s\n\nArguments\n\nf: a function or functor that accepts an AbstractArray or NamedTuple of   AbstractArray with names matching init. The AbstractArray will be a view into    the grid the same size as the init grids, removing any padding that has been added.\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\nWARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GraphicOutput","page":"DynamicGrids","title":"DynamicGrids.GraphicOutput","text":"GraphicOutput <: Output\n\nAbstract supertype for Outputs that display the simulation frames.\n\nAll GraphicOutputs must have a GraphicConfig object and define a showframe method.\n\nSee REPLOutput for an example.\n\nKeywords:\n\nThe default constructor will generate these objects from other keyword arguments  and pass them to the object constructor, which must accept the following:\n\nframes: a Vector of simulation frames (NamedTuple or Array). \nrunning: A Bool.\nextent an Extent object.\ngraphicconfig a GraphicConfigobject.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.REPLOutput","page":"DynamicGrids","title":"DynamicGrids.REPLOutput","text":"REPLOutput <: GraphicOutput\n\nREPLOutput(init; tspan, kw...)\n\nAn output that is displayed directly in the REPL. It can either store or discard simulation frames.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Arrays.\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\nmask: BitArray for defining cells that will/will not be run.\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\nfps: Real frames per second to display the simulation\nstore: Bool whether ot store the simulation frames for later use\ncolor: a color from Crayons.jl\ncutoff: Real cutoff point to display a full or empty cell. Default is 0.5\nstyle: CharStyle Block() or Braile() printing. Braile uses 1/4 the screen space of Block.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ImageOutput","page":"DynamicGrids","title":"DynamicGrids.ImageOutput","text":"ImageOutput <: GraphicOutput\n\nAbstract supertype for Graphic outputs that display the simulation frames as RGB images.\n\nImageOutputs must have Extent, GraphicConfig  and ImageConfig components, and define a showimage method.\n\nSee GifOutput for an example.\n\nAlthough the majority of the code is maintained here to enable sharing and reuse, most ImageOutputs are not provided in DynamicGrids.jl to avoid heavy dependencies on graphics libraries. See DynamicGridsGtk.jl and DynamicGridsInteract.jl for implementations.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GifOutput","page":"DynamicGrids","title":"DynamicGrids.GifOutput","text":"GifOutput <: ImageOutput\n\nGifOutput(init; filename, tspan, kw...)\n\nOutput that stores the simulation as images and saves a Gif file on completion.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\nfilename: File path to save the gif file to.\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\nfont: String font name, used in default TextConfig. A default will be guessed.\ntext: TextConfig object or nothing for no text.\nscheme: ColorSchemes.jl scheme, or Greyscale()\nrenderer: Renderer\nminval: minimum value(s) to set colour maximum\nmaxval: maximum values(s) to set colour minimum\n\n\n\n\n\n","category":"type"},{"location":"#Renderers","page":"DynamicGrids","title":"Renderers","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Renderer\nDynamicGrids.SingleGridRenderer\nImage\nDynamicGrids.MultiGridRenderer\nLayout\nSparseOptInspector","category":"page"},{"location":"#DynamicGrids.Renderer","page":"DynamicGrids","title":"DynamicGrids.Renderer","text":"Renderer\n\nAbstract supertype for objects that convert a frame of the simulation into an ARGB32 image for display. Frames may be a single grid or a NamedTuple of multiple grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleGridRenderer","page":"DynamicGrids","title":"DynamicGrids.SingleGridRenderer","text":"SingleGridRenderer <: Renderer\n\nAbstract supertype for Renderers that convert a single grid  into an image array.\n\nThe first grid will be displayed if a SingleGridRenderer is used with a NamedTuple of grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Image","page":"DynamicGrids","title":"DynamicGrids.Image","text":"Image <: SingleGridRenderer\n\nImage(f=identity; scheme=ObjectScheme(), zerocolor=nothing, maskcolor=nothing)\n\nConverts output grids to a colorsheme.\n\nArguments\n\nf: a function to convert value from the grid to Real   oran RGB. Real will be scaled by minval/maxval and be colored by the scheme.   RGB is used directly in the output. This is useful for grids of complex objects,   but not necessary for numbers. The default is identity.\n\nKeywords\n\nscheme: a ColorSchemes.jl colorscheme, ObjectScheme or object that defines   Base.get(obj, val) and returns a Color or a value that can be converted to Color   using ARGB32(val).\nzerocolor: a Col to use when values are zero, or nothing to ignore.\nmaskcolor: a Color to use when cells are masked, or nothing to ignore.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.MultiGridRenderer","page":"DynamicGrids","title":"DynamicGrids.MultiGridRenderer","text":"MultiGridRenderer <: Renderer\n\nAbstract type for Renderers that convert a frame containing multiple  grids into a single image.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Layout","page":"DynamicGrids","title":"DynamicGrids.Layout","text":"Layout <: MultiGridRenderer\n\nLayout(layout::Array, renderer::Matrix)\n\nLayout allows displaying multiple grids in a block layout, by specifying a layout matrix and a list of Images to be run for each.\n\nArguments\n\nlayout: A Vector or Matrix containing the keys or numbers of grids in the    locations to display them. nothing, missing or 0 values will be skipped.\nrenderers: Vector/Matrix of Image, matching the layout.   Can be nothing or any other value for grids not in layout.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOptInspector","page":"DynamicGrids","title":"DynamicGrids.SparseOptInspector","text":"SparseOptInspector()\n\nA Renderer that checks SparseOpt visually. Cells that do not run show in gray. Errors show in red, but if they do there's a bug.\n\n\n\n\n\n","category":"type"},{"location":"#Color-schemes","page":"DynamicGrids","title":"Color schemes","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Schemes from Colorschemes.jl can be used for the scheme argument to ImageOutput,  Renderers. Greyscale control over the band of grey used, and is very fast.  ObjectScheme is the default.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"ObjectScheme\nGreyscale","category":"page"},{"location":"#DynamicGrids.ObjectScheme","page":"DynamicGrids","title":"DynamicGrids.ObjectScheme","text":"ObjectScheme\n\nObjectScheme()\n\nDefault colorscheme. Similar to GreyScale for Number.\n\nOther grid objects can define a custom method to return colors from composite objects:\n\nDynamicGrids.to_rgb(::ObjectScheme, obj::MyObjectType) = ...\n\nWhich must return an ARGB32 value.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Greyscale","page":"DynamicGrids","title":"DynamicGrids.Greyscale","text":"Greyscale\n\nGreyscale(min=nothing, max=nothing)\n\nA greeyscale scheme ith better performance than using a  Colorschemes.jl scheme as there is not array access or interpolation.\n\nmin and max are values between 0.0 and 1.0 that define the range of greys used.\n\n\n\n\n\n","category":"type"},{"location":"#Text-labels","page":"DynamicGrids","title":"Text labels","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"TextConfig","category":"page"},{"location":"#DynamicGrids.TextConfig","page":"DynamicGrids","title":"DynamicGrids.TextConfig","text":"TextConfig\n\nTextConfig(; kw...)\nTextConfig(face, namepixels, namepos, timepixels, timepos, fcolor, bcolor)\n\nText configuration for printing timestep and grid name on the image.\n\nArguments / Keywords\n\nfont: String font name.\nnamepixels and timepixels: the pixel size of the font.\ntimepos and namepos: tuples that set the label positions, in Int pixels.\nfcolor and bcolor: the foreground and background colors, as ARGB32.\n\n\n\n\n\n","category":"type"},{"location":"#Saving-gifs","page":"DynamicGrids","title":"Saving gifs","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"savegif","category":"page"},{"location":"#DynamicGrids.savegif","page":"DynamicGrids","title":"DynamicGrids.savegif","text":"savegif(filename::String, o::Output; kw...)\n\nWrite the output array to a gif.\n\nKeywords\n\nfps: Real frames persecond. Defaults to the fps of the output, or 25.\nminval: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nmaxval: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nfont: String name of font to search for. A default will be guessed.\ntext: TextConfig or nothing for no text. Default is TextConfig(; font=font).\nscheme: ColorSchemes.jl scheme, ObjectScheme or Greyscale\nrenderer: Renderer such as Image or Layout. Will be detected automatically\n\n\n\n\n\n","category":"function"},{"location":"#Output-interface","page":"DynamicGrids","title":"Output interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"These are used for defining your own outputs and GridProcessors, not for general scripting.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.AbstractExtent\nDynamicGrids.Extent\nDynamicGrids.extent\nDynamicGrids.isasync\nDynamicGrids.storeframe!\nDynamicGrids.isrunning\nDynamicGrids.isshowable\nDynamicGrids.isstored\nDynamicGrids.initialise!\nDynamicGrids.finalise!\nDynamicGrids.frameindex","category":"page"},{"location":"#DynamicGrids.AbstractExtent","page":"DynamicGrids","title":"DynamicGrids.AbstractExtent","text":"AbstractExtent\n\nAbstract supertype for Extent objects, that hold all variables related to space and time in a simulation. Usually the field of an output.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Extent","page":"DynamicGrids","title":"DynamicGrids.Extent","text":"Extent <: AbstractExtent\n\nExtent(init, mask, aux, padval, tspan)\nExtent(; init, tspan, mask=nothing, aux=nothing, padval=zero(eltype(init)), kw...)\n\nContainer for extensive variables: spatial and timeseries data. These are kept separate from rules to allow application of rules to alternate spatial and temporal contexts.\n\nExtent is not usually constructed directly by users, but it can be passed to Output constructors instead of init, mask, aux and tspan.\n\nArguments/Keywords\n\ninit: initialisation Array/NamedTuple for grid/s.\nmask: BitArray for defining cells that will/will not be run.\naux: NamedTuple of arbitrary input data. Use aux(data, Aux(:key)) to access from   a Rule in a type-stable way.\npadval: padding value for grids with neighborhood rules. The default is    zero(eltype(init)).\ntspan: Time span range. Never type-stable, only access this in modifyrule methods\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.extent","page":"DynamicGrids","title":"DynamicGrids.extent","text":"extent(o::Output) => Extent\n\nOutput interface method. Return and Extent object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isasync","page":"DynamicGrids","title":"DynamicGrids.isasync","text":"isasync(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output should run asynchonously. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.storeframe!","page":"DynamicGrids","title":"DynamicGrids.storeframe!","text":"storeframe!(o::Output, data::AbstractSimData)\n\nStore the current simulaiton frame in the output.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isrunning","page":"DynamicGrids","title":"DynamicGrids.isrunning","text":"isrunning(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output is running. Prevents multiple versions of sim!  running on the same output for asynchronous outputs.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isshowable","page":"DynamicGrids","title":"DynamicGrids.isshowable","text":"isshowable(o::Output, f::Int) => Bool\n\nOutput interface method.\n\nCheck if the output can be shown visually, where f is the frame number. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isstored","page":"DynamicGrids","title":"DynamicGrids.isstored","text":"isastored(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output is storing each frame, or just the the current one. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.initialise!","page":"DynamicGrids","title":"DynamicGrids.initialise!","text":"initialise!(o::Output)\n\nOutput interface method.\n\nInitialise the output at the start of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.finalise!","page":"DynamicGrids","title":"DynamicGrids.finalise!","text":"finalise!(o::Output, data::AbstractSimData)\n\nOutput interface method.\n\nFinalise the output at the end of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.frameindex","page":"DynamicGrids","title":"DynamicGrids.frameindex","text":"frameindex(o::Output, data::AbstractSimData)\n\nOutput interface method.\n\nGet the index of the current frame in the output. Every frame has an index of 1 if the simulation isn't stored.\n\n\n\n\n\n","category":"function"},{"location":"#GraphicOutput-interface","page":"DynamicGrids","title":"GraphicOutput interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Also includes Output interface.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.GraphicConfig\nDynamicGrids.graphicconfig\nDynamicGrids.fps\nDynamicGrids.setfps!\nDynamicGrids.showframe\nDynamicGrids.initialisegraphics\nDynamicGrids.finalisegraphics","category":"page"},{"location":"#DynamicGrids.GraphicConfig","page":"DynamicGrids","title":"DynamicGrids.GraphicConfig","text":"GraphicConfig\n\nGraphicConfig(; fps=25.0, store=false)\n\nConfig and variables for graphic outputs.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.graphicconfig","page":"DynamicGrids","title":"DynamicGrids.graphicconfig","text":"graphicconfig(output::GraphicOutput) => GraphicConfig\n\nGraphicOutput interface method. Return an GraphicConfig object. \n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.fps","page":"DynamicGrids","title":"DynamicGrids.fps","text":"fps(o::Output) => Real\n\nGraphicOutput interface method.\n\nGet the frames per second the output will run at. The default is nothing - the simulation runs at full speed.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.setfps!","page":"DynamicGrids","title":"DynamicGrids.setfps!","text":"setfps!(o::Output, x)\n\nGraphicOutput interface method.\n\nSet the frames per second the output will run at.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showframe","page":"DynamicGrids","title":"DynamicGrids.showframe","text":"showframe(o::Output, data::AbstractSimData)\nshowframe(frame::NamedTuple, o::Output, data::AbstractSimData)\nshowframe(frame::AbstractArray, o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nDisplay the grid/s somehow in the output, if it can do that.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.initialisegraphics","page":"DynamicGrids","title":"DynamicGrids.initialisegraphics","text":"initalisegraphics(o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nInitialise the output graphics at the start of the simulation, if it has graphics.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.finalisegraphics","page":"DynamicGrids","title":"DynamicGrids.finalisegraphics","text":"finalisegraphics(o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nFinalise the output graphics at the end of the simulation, if it has graphics.\n\n\n\n\n\n","category":"function"},{"location":"#ImageOutput-components-and-interface","page":"DynamicGrids","title":"ImageOutput components and interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Also uses Output and GraphicOutput interfaces.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.ImageConfig\nDynamicGrids.imageconfig\nDynamicGrids.showimage\nDynamicGrids.render!\nDynamicGrids.to_rgb","category":"page"},{"location":"#DynamicGrids.ImageConfig","page":"DynamicGrids","title":"DynamicGrids.ImageConfig","text":"ImageConfig\n\nImageConfig(init; kw...)\n\nCommon configuration component for all ImageOutput.\n\nKeywords\n\ninit output init object, used to generate other arguments automatically.\nminval: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    A Vector/Matrix for multiple grids, matching the layout array. \nmaxval: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    A Vector/Matrix for multiple grids, matching the layout array. \nfont: String name of font to search for. A default will be guessed.\ntext: TextConfig() or nothing for no text. Default is TextConfig(; font=font).\nscheme: ColorSchemes.jl scheme(s), or Greyscale(). ObjectScheme() by default.   A Vector/Matrix for multiple grids, matching the layout array. \nrenderer: Renderer like Image or Layout Will be detected    automatically. A Vector/Matrix for multiple grids, matching the layout array. \n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.imageconfig","page":"DynamicGrids","title":"DynamicGrids.imageconfig","text":"imageconfig(output::ImageOutput) => ImageConfig\n\nImageOutpu interface method. Return an ImageConfig object. \n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showimage","page":"DynamicGrids","title":"DynamicGrids.showimage","text":"showimage(image::AbstractArray, o::ImageOutput)\nshowimage(image::AbstractArray, o::ImageOutput, data::AbstractSimData)\n\nImageOutput interface method.\n\nDisplay an image generated from the grid, a required method for all ImageOutput.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.render!","page":"DynamicGrids","title":"DynamicGrids.render!","text":"render!(o::ImageOutput, data::AbstractSimData)\nrender!(imbuf, renderer::Renderer, o::ImageOutput, data::AbstractSimData, grids)\n\nConvert a grid or NamedRuple of grids to an ARGB32 image, using an  Renderer.\n\nRendered pixels are written to the image buffer matrix.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.to_rgb","page":"DynamicGrids","title":"DynamicGrids.to_rgb","text":"to_rgb(val) => ARGB32\nto_rgb(scheme, val) => ARGB32\n\nImageOutput interface method.\n\nDisplay an image generated from the grid, a required method for all ImageOutput.\n\nCustom grid object will need to add methods for converting the object to a color,\n\nto_rgb(::ObjectScheme, obj::CustomObj) = ...`\n\nFor use with other colorschemes, a method that calls get with a Real value obtained from the object will be required:\n\nto_rgb(scheme, obj::CustomObj) = ARGB32(get(scheme, real_from_obj(obj)))\n\n\n\n\n\n","category":"function"},{"location":"#Custom-grid-element-types","page":"DynamicGrids","title":"Custom grid element types","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"It is common to use Bool, Int or Float64 as the contents of a grid. But a range of object types can be used if they meet the interface criteria.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Immutable, isbits objects are usually better and the only type officially to work - as they are loaded directly in the simulation. Mutable objects, especially containing pointers, may lead to incorrect stored results, and wont work at all on GPUs.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Methods to define are: ","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"zero: define zero of the object type\noneunit: define one of the object type\nisless: define comparison between two of the objects\n*: multiplication by a Real scalar.\n/: division by a Real scalar.\n+: addition to another object of the same type\n-: subtraction from another object of the same type\nto_rgb: return and ARGB32 to visualise the object as a pixel ","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"In this example we define a struct with two fields. You will need to determine the correct behaviours for your own types, but hopefully this will get you started.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"struct MYStruct{A,B}\n    a::A\n    b::B\nend\n\nBase.isless(a::MyStruct, b::MyStruct) = isless(a.a, b.a)\nBase.zero(::Type{<:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(zero(T1), zero(T2))\nBase.oneunit(::Type{<:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(one(T1), one(T2))\n\nBase.:*(x::MyStruct, x::Number) = MyStruct(x.a * x, x.b * x)\nBase.:*(x::Number, x::MyStruct) = MyStruct(x * x.a, x * x.b)\nBase.:/(x::MyStruct, x::Number) = MyStruct(x.a / x, x.b / x)\nBase.:+(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a + x2.a, x1.b + x2.b)\nBase.:-(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a - x2.a, x1.b - x2.b)","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"To generate rgb colors for an ImageOuput, you must define to_rgb,  at least for the default ObjectScheme, but this can also be done for other  schemes such as ColorSchemes.jl, or GreyScale, by calling get on the scheme and a  Real value. Note that the objects will be normalised to values between zero and one by minval and maxval scalars prior to this, using the division operators defined  above. It is preferable to use minval and maxval over normalising in to_rgb -  as this will not be as flexible for scripting.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.to_rgb(::ObjectScheme, obj::MyStruct) = ARGB32(obj.a, obj.b, 0)\nDynamicGrids.to_rgb(scheme, obj::MyStruct) = get(scheme, obj.a)","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"See the test/objectgrids.jl tests for more details on using complex objects in grids.","category":"page"}]
}
