var documenterSearchIndex = {"docs":
[{"location":"#DynamicGrids.jl","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids","category":"page"},{"location":"#DynamicGrids","page":"DynamicGrids.jl","title":"DynamicGrids","text":"DynamicGrids\n\n(Image: ) (Image: ) (Image: Build Status)  (Image: codecov.io) (Image: Aqua.jl Quality Assurance)\n\nDynamicGrids is a generalised framework for building high-performance grid-based spatial simulations, including cellular automata, but also allowing a wider range of behaviours like random jumps and interactions between multiple grids. It is extended by Dispersal.jl for modelling organism dispersal processes.\n\n(Image: Dispersal quarantine)\n\nA dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from DynamicGridsGtk.  Note that this is indicative of the real-time frame-rate on a laptop.\n\nA DynamicGrids.jl simulation is run with a script like this one running the included game of life model Life():\n\nusing DynamicGrids, Crayons\n\ninit = rand(Bool, 150, 200)\noutput = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))\nsim!(output, Life())\n\n# Or define it from scratch (yes this is actually the whole implementation!)\nconst sum_states = (false, false, true, false, false, false, false, false, false), \n                   (false, false, true, true,  false, false, false, false, false)\nlife = Neighbors(Moore(1)) do hood, state\n    sum_states[state + 1][sum(hood) + 1]\nend\nsim!(output, life)\n\n(Image: REPL life)\n\nA game of life simulation being displayed directly in a terminal.\n\nConcepts\n\nThe framework is highly customisable, but there are some central ideas that define how a simulation works: grids, rules, and outputs.\n\nGrids\n\nSimulation grids may be any single AbstractArray or a NamedTuple of multiple AbstractArray. Usually grids contain values of Number, but other types are possible. Grids are updated by Rules that are run for every cell, at every timestep. \n\nThe init grid/s contain whatever initialisation data is required to start a simulation: the array type, size and element type, as well as providing the initial conditions:\n\ninit = rand(Float32, 100, 100)\n\nAn init grid can be attached to an Output: \n\noutput = ArrayOutput(init; tspan=1:100)\n\nor passed in to sim!, where it will take preference over the init attached to the Output, but must be the same type and size:\n\nsim!(output, ruleset; init=init)\n\nFor multiple grids, init is a NamedTuple of equal-sized arrays matching the names given to each Ruleset :\n\ninit = (predator=rand(100, 100), prey=(rand(100, 100))\n\nHandling and passing of the correct grids to a Rule is automated by DynamicGrids.jl. Rules specify which grids they require in what order using the first two (R and W) type parameters, or read and write keyword arguments. \n\nDimensional or spatial init grids from DimensionalData.jl of GeoData.jl will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using Plots.jl, to which shape files and observation points can be easily added.\n\nNon-Number Grids\n\nGrids containing custom and non-Number types are possible, with some caveats. They must define Base.zero for their element type, and should be a bitstype for performance.  Tuple does not define zero. Array is not a bitstype, and does not define zero.  SArray from StaticArrays.jl is both, and can be used as the contents of a grid.  Custom structs that defne zero should also work. \n\nHowever, for any multi-values grid element type, you will need to define a method of  DynamicGrids.rgb that returns an ARGB32 for them to work in ImageOutputs, and  isless for the REPLoutput to work.\n\nRules\n\nRules hold the parameters for running a simulation, and are applied in applyrule method that is called for each of the active cells in the grid. Rules come in a number of flavours (outlined in the docs), which allow assumptions to be made about running them that can greatly improve performance. Rules can be collected in a Ruleset, with some additional arguments to control the simulation:\n\nruleset = Ruleset(Life(2, 3); opt=SparseOpt())\n\nMultiple rules can be combined in a Ruleset. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:\n\nruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt())\n\nFor better performance (often ~2x or more), models included in a Chain object will be combined into a single model, using only one array read and write. This optimisation is limited to CellRule, or a NeighborhoodRule followed by CellRule. If the @inline compiler macro is used on all applyrule methods, all rules in a Chain will be compiled together into a single, efficient function call.\n\nruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))\n\nOutput\n\nOutputs are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: ArrayOutput is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the init array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.\n\noutput = ArrayOutput(init; tspan=1:10)\n\nThe REPLOutput shown above is a GraphicOutput that can be useful for checking a simulation when working in a terminal or over ssh:\n\noutput = REPLOutput(init; tspan=1:100)\n\nImageOutput is the most complex class of outputs, allowing full color visual simulations using ColorSchemes.jl. It can also display multiple grids using color  composites or layouts, as shown above in the quarantine simulation.\n\nDynamicGridsInteract.jl provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. DynamicGridsGtk.jl is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. \n\nOutputs are also easy to write, and high performance applications may benefit from writing a custom output to reduce memory use. Performance of DynamicGrids.jl is dominated by cache interactions, so reducing memory use has positive effects.\n\nExample\n\nThis example implements a very simple forest fire model:\n\nusing DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors\n\nconst DEAD, ALIVE, BURNING = 1, 2, 3\n\nrule = let prob_combustion=0.0001, prob_regrowth=0.01\n    Neighbors(Moore(1)) do neighborhood, cell\n        if cell == ALIVE\n            if BURNING in neighborhood\n                BURNING\n            else\n                rand() <= prob_combustion ? BURNING : ALIVE\n            end\n        elseif cell in BURNING\n            DEAD\n        else\n            rand() <= prob_regrowth ? ALIVE : DEAD\n        end\n    end\nend\n\n# Set up the init array and output (using a Gtk window)\ninit = fill(ALIVE, 400, 400)\nprocessor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))\noutput = GtkOutput(init; tspan=1:200, fps=25, minval=DEAD, maxval=BURNING, processor=processor)\n\n# Run the simulation\nsim!(output, rule)\n\n# Save the output as a gif\nsavegif(\"forestfire.gif\", output)\n\n(Image: forestfire)\n\nTiming the simulation for 200 steps, the performance is quite good:\n\noutput = ArrayOutput(init; tspan=1:200)\n@time sim!(output, ruleset)\n 1.384755 seconds (640 allocations: 2.569 MiB)\n\nAlternatives\n\nAgents.jl can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. \n\nHowever, for simple grid models where you don't need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don't need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.\n\n\n\n\n\n","category":"module"},{"location":"#Running-simulations","page":"DynamicGrids.jl","title":"Running simulations","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"sim!\nresume! ","category":"page"},{"location":"#DynamicGrids.sim!","page":"DynamicGrids.jl","title":"DynamicGrids.sim!","text":"sim!(output, [ruleset::Ruleset=ruleset(output)];\n     init=init(output),\n     mask=mask(output),\n     tstpan=tspan(output),\n     aux=aux(output),\n     fps=fps(output),\n     simdata=nothing,\n     nreplicates=nothing)\n\nRuns the simulation, passing the destination aray to the passed in output for each time-step.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one or more Rules. If the output has a Ruleset attached, it will be used.\n\nKeyword Arguments\n\nTheses are the taken from the output argument by default.\n\ninit: optional array or NamedTuple of arrays.\nmask: a Bool array matching the init array size. false cells do not run.\naux: a NamedTuple of auxilary data to be used by rules.\ntspan: a tuple holding the start and end of the timespan the simulaiton will run for.\nfps: the frames per second to display. Will be taken from the output if not passed in.\nnreplicates: the number of replicates to combine in stochastic simulations\nsimdata: a SimData object. Keeping it between simulations can reduce memory allocation when that is important.\n\n\n\n\n\nsim!(output, rules::Rule...; kwargs...)\n\nRun a simulation passing in rules without defining a Ruleset.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.resume!","page":"DynamicGrids.jl","title":"DynamicGrids.resume!","text":"resume!(output::GraphicOutput, ruleset::Ruleset=ruleset(output);\n        tstop=last(tspan(output)),\n        fps=fps(output),\n        simdata=nothing,\n        nreplicates=nothing)\n\nRestart the simulation from where you stopped last time. For arguments see sim!. The keyword arg tstop can be used to extend the length of the simulation.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one ore more Rules. These will each be run in sequence.\n\nKeyword Arguments (optional\n\ninit: an optional initialisation array\ntstop: the new stop time for the simulation. Taken from the output length by default.\nfps: the frames per second to display. Taken from the output by default.\nnreplicates: the number of replicates to combine in stochastic simulations\nsimdata: a SimData object. Keeping it between simulations can improve performance when that is important\n\n\n\n\n\n","category":"function"},{"location":"#Rules","page":"DynamicGrids.jl","title":"Rules","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular applyrule or applyrule! methods. Rules can be chained together arbitrarily to make composite simulations across any number of grids.","category":"page"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Ruleset\nRule\nCellRule\nCell\nNeighborhoodRule\nNeighbors\nConvolution\nLife\nManualRule\nManual\nManualNeighborhoodRule\nSetNeighbors\nGridRule\nGrid\nChain","category":"page"},{"location":"#DynamicGrids.Ruleset","page":"DynamicGrids.jl","title":"DynamicGrids.Ruleset","text":"Ruleset(rules...; overflow=RemoveOverflow(), opt=NoOpt(), cellsize=1, timestep=nothing)\n\nA container for holding a sequence of Rules and simulation details like overflow handing and optimisation. Rules will be run in the order they are passed, ie. Ruleset(rule1, rule2, rule3).\n\nKeyword Arguments\n\nopt: a PerformanceOpt to specificy optimisations like SparseOpt. Defaults to NoOpt.\noverflow: what to do with overflow of grid edges. Options are RemoveOverflow() or WrapOverflow(), defaulting to RemoveOverflow.\ncellsize: size of cells.\ntimestep: fixed timestep where this is reuired for some rules. eg. Month(1) or 1u\"s\".\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Rule","page":"DynamicGrids.jl","title":"DynamicGrids.Rule","text":"A Rule object contains the information required to apply some logical rule to every cell of every timestep of a simulation.\n\nRules can be chained together sequentially into Rulesets.\n\nRules are applied to the grid using the applyrule method:\n\n@inline applyrule(data::SimData, rule::YourRule, state, cellindex) =\n\nWhere cellindex is a Tuple of Int, and state is a single value, or a NamedTuple if multiple grids are requested. The NamedTuple keys will match the keys in R, which is a type like Tuple{:key1,:key1} - note the names are user specified, and should never be fixed by a Rule - they can be retrieved from the type here as A and B :\n\napplyrule(data::SimData, rule::YourCellRule{Tuple{R1,R2},Tuple{W1,W2}}, state, cellindex) where {R1,R2,W1,W2}\n\nBy default the output is written to the current cell in the specified W write grid/s. Rules writing to multiple grids, simply return a Tuple in the order specified by the W type params.\n\nPrecalculation\n\nprecalcrule can be used to precalculate any fields that depend on the timestep. Otherwise everything should be precalculated apon construction.\n\nRetreive required information from SimData such as currenttime or currentframe. The return value is the updated rule.\n\nprecalcrule(rule::YourCellRule, data::SimData)\n\nRule Performance\n\nRules may run many millions of times during a simulation. They need to be fast.\n\nSome basic guidlines for writing rules are:\n\nNever allocate memory in a Rule if you can help it.\nType stability is essential. isinferred is useful to check if your rule is type-stable.\nUsing the @inline macro on applyrule can help force inlining your code into the simulation.\nReading and writing from multiple grids is expensive due to additional load on fast cahce memory. Try to limit the number of grids you use.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CellRule","page":"DynamicGrids.jl","title":"DynamicGrids.CellRule","text":"A Rule that only writes and uses a state from single cell of the read grids, and has its return value written back to the same cell(s).\n\nThis limitation can be useful for performance optimisation, such as wrapping rules in Chain so that no writes occur between rules.\n\nCellRule is defined with :\n\nstruct YourCellRule{R,W} <: CellRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule(data::SimData, rule::YourCellRule{R,W}, state, cellindex) where {R,W}\n    state * 2\nend\n\nAs the cellindex is provided in applyrule, you can look up an aux array using aux(data, Val{:auxname}())[cellindex...] to access cell-specific variables for your rule.\n\nIt's good to add a struct field to hold the Val{:auxname}() object instead of using names directly, so that users can set the aux name themselves to suit the scripting context.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Cell","page":"DynamicGrids.jl","title":"DynamicGrids.Cell","text":"Cell(f)\nCell{R,W}(f)\n\nA CellRule that applies a function f to the read grid cells and returns the write cells.\n\nEspecially convenient with do notation.\n\nExample\n\nSet the cells of grid :c to the sum of :a and :b:\n\nsimplerule = Cell() do a, b\n    a + b\nend\n\nIf you need to use multiple grids (a and b), use the read and write arguments. If you want to use external variables, wrap the whole thing in a let block, for performance.\n\nrule = let y = y\n    rule = Cell{Tuple{:a,:b},:b}() do a, b\n        a + b * y\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.NeighborhoodRule","page":"DynamicGrids.jl","title":"DynamicGrids.NeighborhoodRule","text":"A Rule that only accesses a neighborhood centered around the current cell. NeighborhoodRule is applied with the method:\n\napplyrule(data::SimData, rule::YourNeighborhoodRule, state, I)\n\nNeighborhoodRule must have a neighborhood field, that holds a Neighborhood object. neighbors(rule) returns an iterator over the surrounding cell pattern defined by the Neighborhood.\n\nFor each cell in the grids the neighborhood buffer will be updated for use in the applyrule method, managed to minimise array reads.\n\nThis allows memory optimisations and the use of BLAS routines on the neighborhood buffer for Moore neighborhoods. It also means that and no bounds checking is required in neighborhood code.\n\nFor neighborhood rules with multiple read grids, the first is always the one used for the neighborhood, the others are passed in as additional state for the cell. Any grids can be written to, but only for the current cell.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Neighbors","page":"DynamicGrids.jl","title":"DynamicGrids.Neighbors","text":"Neighbors(f, neighborhood=Moor(1))\nNeighbors{R,W}(f, neighborhood=Moore())\n\nA NeighborhoodRule that receives a neighbors object for the first read grid and the passed in neighborhood, followed by the cell values for the required grids, as with Cell.\n\nReturned value(s) are written to the write/W grid.\n\nAs with all NeighborhoodRule, you do not have to check bounds at grid edges, that is handled for you internally.\n\nUsing SparseOpt may improve neighborhood performance when zero values are common and can be safely ignored.\n\nExample\n\nrule = let x = 10\n    Neighbors{Tuple{:a,:b},:b}() do hood, a, b\n        data[:b][I...] = a + b^x\n    end\nend\n\nThe let block may improve performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Convolution","page":"DynamicGrids.jl","title":"DynamicGrids.Convolution","text":"Convolution(f, neighborhood=Moor(1))\nConvolution{R,W}(f, neighborhood=Moor(1))\n\nA Rule that runs a basic convolution kernel over the grid.\n\nPerformance\n\nAlways use StaticArrays.jl to define the kernel matrix.\n\nSmall radius convolutions in DynamicGrids.jl will be faster or comparable to using DSP.jl or ImageConvolutions.jl. As the radius increases or grid size gets very large these packages will be a lot faster.\n\nBut Convolution is convenient to chain into a simlulation, and combined with some other  rules. It should perform reasonably well in all but very large simulations or very large  kernels.\n\nExample\n\nrule = Convolution(Kernel(SA[0.05 0.1 0.05; 0.1 0.4 0.1; 0.05 0.1 0.05]))\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Life","page":"DynamicGrids.jl","title":"DynamicGrids.Life","text":"Life(neighborhood, born=3, survive=(2, 3))\n\nRule for game-of-life style cellular automata. This is a demonstration of Cellular Automata more than a seriously optimised game of life rule.\n\nCells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.\n\nExamples (gleaned from CellularAutomata.jl)\n\nusing DynamicGrids, Distributions\n# Use `Binomial` to tweak the density random true values\ninit = Bool.(rand(Binomial(1, 0.5), 70, 70))\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:red)\n\n# Morley\nsim!(output, Ruleset(Life(born=[3, 6, 8], survive=[2, 4, 5])))\n\n# 2x2\nsim!(output, Ruleset(Life(born=[3, 6], survive=[1, 2, 5])))\n\n# Dimoeba\ninit = rand(Bool, 400, 300)\ninit[:, 100:200] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:blue, style=Braile())\nsim!(output,  Life(born=(3, 5, 6, 7, 8),  survive=(5, 6, 7, 8)))\n\n## No death\nsim!(output,  Life(born=(3, ),  survive=(0, 1, 2, 3, 4, 5, 6, 7, 8)))\n\n## 34 life\nsim!(output, Life(born=(3, 4), survive=(3, 4)))\n\n# Replicator\ninit = fill(true, 300,300)\ninit[:, 100:200] .= false\ninit[10, :] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:yellow)\nsim!(output,  Life(born=(1, 3, 5, 7),  survive=(1, 3, 5, 7)))\nnothing\n\n(Image: REPL Life)\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ManualRule","page":"DynamicGrids.jl","title":"DynamicGrids.ManualRule","text":"ManualRule is the supertype for rules that manually write to whichever cells of the grid that they choose, instead of automatically updating every cell with their output.\n\nManualRule is applied with a method like:\n\nfunction applyrule!(data::SimData, rule::YourManualRule{R,W}, state, cellindex) where {R,W}\n     inc = 1\n     add!(data[W], inc, cellindex...)\n     return nothing\nend\n\nNote the ! bang - this method alters the state of data. We also use the type parameter W (write) to index into the data object. You could also just use first(dat) when there is only one W write grid.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nIt there are multiple write grids, you will need to get the grid keys from type parameters, here W1 and W2:\n\nfunction applyrule(data, rule::YourManRule{R,Tuple{W1,W2}}, state, cellindex) where {R,W1,W2}\n     inc = 1\n     add!(data[W1], inc, cellindex...)\n     add!(data[W2], 2inc, cellindex...)\n     return nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Manual","page":"DynamicGrids.jl","title":"DynamicGrids.Manual","text":"Manual(f)\nManual{R,W}(f)\n\nA ManualRule to manually write to the array where you need to. f is passed an indexable data object, and the index of the current cell, followed by the required grid values for the index.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nExample\n\nrule = let x = 10\n    Manual{Tuple{:a,:b},:b}() do data, I, a, b\n        add!(data[:b], a^x, I...)\n    end\nend\n\nThe let block greatly improves performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ManualNeighborhoodRule","page":"DynamicGrids.jl","title":"DynamicGrids.ManualNeighborhoodRule","text":"A Rule that only writes to its neighborhood, defined by its radius distance from the current point.\n\nManualNeighborhood rules must return their radius with a radius() method, although by default this will be called on the result of neighborhood(rule).\n\nTODO: performance optimisations with a neighborhood buffer, simular to NeighborhoodRule but for writing.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetNeighbors","page":"DynamicGrids.jl","title":"DynamicGrids.SetNeighbors","text":"SetNeighbors(f, neighborhood=Moor(1))\nSetNeighbors{R,W}(f, neighborhood=Moor(1))\n\nA ManualRule to manually write to the array with the specified  neighborhood. Indexing outside the neighborhood is undefined behaviour.\n\nFunction f is passed an SimData object data, the specified  neighborhood object and the index of the current cell, followed by the required  grid values for the index. \n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods can be safely combined writes from all grid cells. \n\nDirectly using setindex! is possible, but may cause bugs as multiple cells may write to the same location in an unpredicatble order. As a rule, directly setting a neighborhood index should only be done for a single value - then it can  be guaranteed that any writes from othe grid cells reach the same result.\n\n[neighbors], [offsets] and positions are useful methods\n\nExample\n\nrule = let x = 10\n    SetNeighbors{Tuple{:a,:b},:b}() do data, hood, I, a, b\n        for pos in positions(hood)\n            add!(data[:b], a^x, pos...)\n        end\n    end\nend\n\nThe let block greatly improves performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GridRule","page":"DynamicGrids.jl","title":"DynamicGrids.GridRule","text":"A Rule applies to whole grids. This is used for operations that don't benefit from having neighborhood buffering or looping over the grid handled for them, or any specific optimisations. Best suited to simple functions like rand(write)` or using convolutions from other packages like DSP.jl. They may also be useful for doing other custom things that don't fit into the DynamicGrids.jl framework during the simulation.\n\nGrid rules specify the grids they want and are sequenced just like any other grid.\n\nstruct YourGridRule{R,W} <: GridRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule!(data::SimData, rule::YourGridRule{R,W}) where {R,W}\n    rand!(data[W])\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Grid","page":"DynamicGrids.jl","title":"DynamicGrids.Grid","text":"Grid{R,W}(f)\n\nApply a function f to fill whole grid/s.\n\nrule = Grid{:a,:b}() do a, b\n    b .= a\nend\n\nNever use assignment broadcast .*=, the write grids are not guarantieed to have the same values as the same-named read grids R. Always copy from a read grid to a write grid manually.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Chain","page":"DynamicGrids.jl","title":"DynamicGrids.Chain","text":"Chain(rules...)\nChain(rules::Tuple)\n\nChains allow chaining rules together to be completed in a single processing step, without intermediate reads or writes from grids. \n\nThey are potentially compiled together into a single function call, especially if you  use @inline on all applyrule methods. Chain can hold either all CellRule  or NeighborhoodRule followed by CellRule.\n\nManualRule can't be used in Chain, as it doesn't have a return value.\n\n(Image: Chain rule diagram)\n\n\n\n\n\n","category":"type"},{"location":"#Rule-methods-and-helpers","page":"DynamicGrids.jl","title":"Rule methods and helpers","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids.applyrule\nDynamicGrids.applyrule!\nDynamicGrids.precalcrule\nisinferred ","category":"page"},{"location":"#DynamicGrids.applyrule","page":"DynamicGrids.jl","title":"DynamicGrids.applyrule","text":"applyrule(data::SimData, rule::Rule{R,W}, state, index::Tuple{Int,Int}) => cell value(s)\n\nApply a rule to the cell state and return values to write to the grid(s).\n\nThis is called in maprule! methods during the simulation, not by the user. Custom Rule implementations must define this method.\n\nArguments:\n\ndata : SimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates\n\nReturns the value(s) to be written to the current cell(s) of the grids specified by the W type parameter.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.applyrule!","page":"DynamicGrids.jl","title":"DynamicGrids.applyrule!","text":"applyrule!(data::SimData, rule::ManualRule{R,W}, state, index::Tuple{Int,Int}) => Nothing\n\nApply a rule to the cell state and manually write to the grid data array. Used in all rules inheriting from ManualRule.\n\nThis is called in internal maprule! methods during the simulation, not by the user. Custom ManualRule implementations must define this method.\n\nOnly grids specified with the W type parameter will be writable from data.\n\nArguments:\n\ndata : SimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates - t: the current time step\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.precalcrule","page":"DynamicGrids.jl","title":"DynamicGrids.precalcrule","text":"precalcrule(rule::Rule, data::SimData) => Rule\n\nPrecalculates rule fields at each timestep. Define this method if a Rule has fields that need to be updated over time.\n\nRules are usually immutable (it's faster), so precalc is expected to returns a new rule object with changes applied to it.  Setfield.jl or Acessors.jl may help with updating the immutable struct.\n\nThe default behaviour is to return the existing rule without change.\n\nUpdated rules are be discarded, and the rule argument is always be the original object passed in.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinferred","page":"DynamicGrids.jl","title":"DynamicGrids.isinferred","text":"isinferred(output::Output, ruleset::Ruleset)\nisinferred(output::Output, rules::Rule...)\n\nTest if a custom rule is inferred and the return type is correct when applyrule or applyrule! is run.\n\nType-stability can give orders of magnitude improvements in performance.\n\n\n\n\n\n","category":"function"},{"location":"#Data-objects-and-methods-for-use-in-applyrule","page":"DynamicGrids.jl","title":"Data objects and methods for use in applyrule","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"SimData\nDynamicGrids.init\nDynamicGrids.aux\nDynamicGrids.mask\nDynamicGrids.tspan\nDynamicGrids.timestep\nDynamicGrids.currenttimestep\nDynamicGrids.currenttime\nDynamicGrids.currentframe\nDynamicGrids.frameindex\nDynamicGrids.inbounds\nDynamicGrids.isinbounds","category":"page"},{"location":"#DynamicGrids.SimData","page":"DynamicGrids.jl","title":"DynamicGrids.SimData","text":"SimData(extent::Extent, ruleset::AbstractRuleset)\n\nSimulation dataset to hold all intermediate arrays, timesteps and frame numbers for the current frame of the simulation.\n\nA simdata object is accessable in applyrule as the first parameter.\n\nMultiple grids can be indexed into using their key if you need to read from arbitrary locations:\n\nfunciton applyrule(data::SimData, rule::SomeRule{Tuple{A,B}},W}, (a, b), cellindex) where {A,B,W}\n    grid_a = data[A]\n    grid_b = data[B]\n    ...\n\nIn single grid simulations SimData can be indexed directly as if it is a Matrix.\n\nMethods\n\ncurrentframe(data::SimData): get the current frame number, an Int\ncurrenttime(data::SimData): the current frame time, which isa eltype(tspan)\naux(d::SimData, args...): get the aux data NamedTuple, or Nothing. adding a Symbol or Val{:symbol} argument will get a field of aux.\ntspan(d::SimData): get the simulation time span, an AbstractRange.\ntimestep(d::SimData): get the simulaiton time step.\nradius(data::SimData) : returns the Int radius used on the grid, which is also the amount of border padding.\noverflow(data::SimData) : returns the Overflow - RemoveOverflow or WrapOverflow.\npadval(data::SimData) : returns the value to use as grid border padding.\n\nThese are available, but you probably shouldn't use them and thier behaviour is not guaranteed in furture versions. They will mean rule is useful only in specific contexts.\n\nextent(d::SimData) : get the simulation Extent object.\ninit(data::SimData) : get the simulation init AbstractArray/NamedTuple\nmask(data::SimData) : get the simulation mask AbstractArray\nruleset(d::SimData) : get the simulation AbstractRuleset.\nsource(data::SimData) : get the source grid that is being read from.\ndest(data::SimData) : get the dest grid that is being written to.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.init","page":"DynamicGrids.jl","title":"DynamicGrids.init","text":"init(obj) => Union{AbstractArray,NamedTUple}\n\nRetrieve the mask from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.aux","page":"DynamicGrids.jl","title":"DynamicGrids.aux","text":"aux(obj, [key])\n\nRetrieve auxilary data NamedTuple from an Output, Extent or SimData object.\n\nGiven key specific data will be returned. key should be a Val{:symbol} for type stability and zero-cost access inside rules. Symbol will also work, but may be slow.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.mask","page":"DynamicGrids.jl","title":"DynamicGrids.mask","text":"mask(obj) => AbstractArray\n\nRetrieve the mask from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.tspan","page":"DynamicGrids.jl","title":"DynamicGrids.tspan","text":"tspan(obj) => AbstractRange\n\nRetrieve the time-span AbstractRange from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.timestep","page":"DynamicGrids.jl","title":"DynamicGrids.timestep","text":"timestep(obj)\n\nRetrieve the timestep size from an Output, Extent, Ruleset or SimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttimestep","page":"DynamicGrids.jl","title":"DynamicGrids.currenttimestep","text":"currenttimestep(simdata::SimData)\n\nRetrieve the current timestep from a SimData object.\n\nThis may be different from the timestep. If the simulation is in Month, currenttimestep will return Seconds for the length of the specific month.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttime","page":"DynamicGrids.jl","title":"DynamicGrids.currenttime","text":"currenttime(simdata::SimData)\n\nRetrieve the current simulation time from a SimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currentframe","page":"DynamicGrids.jl","title":"DynamicGrids.currentframe","text":"currentframe(simdata::SimData) => Int\n\nRetrieve the current simulation frame a SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.frameindex","page":"DynamicGrids.jl","title":"DynamicGrids.frameindex","text":"frameindex(o::Output, data::SimData)\n\nGet the index of the current frame in the output.\n\nEvery frame has an index of 1 if the simulation isn't stored\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.inbounds","page":"DynamicGrids.jl","title":"DynamicGrids.inbounds","text":"inbounds(xs::Tuple, data::SimData) => Tuple{NTuple{2,Int},Bool}\n\nCheck grid boundaries for a coordinate before writing in ManualRule.\n\nReturns a Tuple containing a coordinates Tuple and a Bool - true if the cell is in bounds, false if not.\n\nOverflow of type RemoveOverflow returns the coordinate and false to skip coordinates that overflow outside of the grid.\n\nWrapOverflow returns a tuple with the current position or it's wrapped equivalent, and true as it is allways in-bounds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinbounds","page":"DynamicGrids.jl","title":"DynamicGrids.isinbounds","text":"isinbounds(xs::Tuple, data)\n\nCheck that a coordinate is within the grid, usually in ManualRule.\n\nUnlike inbounds, Overflow status is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#Neighborhoods","page":"DynamicGrids.jl","title":"Neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Neighborhoods define a pattern of cells surrounding the current cell, and how they are combined to update the value of the current cell.","category":"page"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Neighborhood\nRadialNeighborhood\nAbstractKernel\nKernel\nMoore\nVonNeumann\nAbstractPositional\nPositional\nLayeredPositional","category":"page"},{"location":"#DynamicGrids.Neighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.Neighborhood","text":"Neighborhoods define the pattern of surrounding cells in the \"neighborhood\" of the current cell. The neighbors function returns the surrounding cells as an iterable.\n\nThe main kinds of neighborhood are demonstrated below:\n\n(Image: Neighborhoods)\n\nIf the allocation of neighborhood buffers during the simulation is costly (it usually isn't) you can use allocbuffers or preallocate them:\n\nMoore{3}(allocbuffers(3, init))\n\nYou can also change the length of the buffers tuple to experiment with cache performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RadialNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.RadialNeighborhood","text":"Moore-style square neighborhoods\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractKernel","page":"DynamicGrids.jl","title":"DynamicGrids.AbstractKernel","text":"Abstract supertype for kernel neighborhoods.\n\nThese inlude the central cell.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Kernel","page":"DynamicGrids.jl","title":"DynamicGrids.Kernel","text":"Kernel{R}(kernel, buffer=nothing)\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Moore","page":"DynamicGrids.jl","title":"DynamicGrids.Moore","text":"Moore(radius::Int=1)\n\nMoore neighborhoods define the neighborhood as all cells within a horizontal or vertical distance of the central cell. The central cell is omitted.\n\nThe buffer argument may be required for performance optimisation, see Neighborhood for details.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.VonNeumann","page":"DynamicGrids.jl","title":"DynamicGrids.VonNeumann","text":"VonNeumann(radius=1)\n\nA convenience wrapper to build Von-Neumann neighborhoods as a Positional neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.AbstractPositional","page":"DynamicGrids.jl","title":"DynamicGrids.AbstractPositional","text":"Neighborhoods are tuples or vectors of custom coordinates tuples that are specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Positional","page":"DynamicGrids.jl","title":"DynamicGrids.Positional","text":"Positional(coord::Tuple{Vararg{Int}}...)\nPositional(offsets::Tuple{Tuple{Vararg{Int}}}, [buffer=nothing])\nPositional{R}(offsets::Tuple, buffer)\n\nNeighborhoods that can take arbitrary shapes by specifying each coordinate, as Tuple{Int,Int} of the row/column distance (positive and negative) from the central point.\n\nThe neighborhood radius is calculated from the most distance coordinate. For simplicity the buffer read from the main grid is a square with sides 2r + 1 around the central point, and is not shrunk or offset to match the coordinates if they are not symmetrical.\n\nThe buffer argument may be required for performance optimisation, see [Neighborhood] for more details.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.LayeredPositional","page":"DynamicGrids.jl","title":"DynamicGrids.LayeredPositional","text":"LayeredPositional(layers::Positional...)\n\nSets of Positional neighborhoods that can have separate rules for each set.\n\nneighbors for LayeredPositional returns a tuple of iterators for each neighborhood layer.\n\n\n\n\n\n","category":"type"},{"location":"#Methods-for-use-with-neighborhood-rules-and-neighborhoods","page":"DynamicGrids.jl","title":"Methods for use with neighborhood rules and neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids.radius\nDynamicGrids.neighbors\nDynamicGrids.positions\nDynamicGrids.offsets\nDynamicGrids.sumneighbors","category":"page"},{"location":"#DynamicGrids.radius","page":"DynamicGrids.jl","title":"DynamicGrids.radius","text":"radius(rule, [key]) => Int\n\nReturn the radius of a rule or ruleset if it has one, otherwise zero.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.neighbors","page":"DynamicGrids.jl","title":"DynamicGrids.neighbors","text":"neighbors(x::Union{Neighborhood,NeighborhoodRule}}) => iterable\n\nReturns an iteraterable generator over all cells in the neighborhood.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.positions","page":"DynamicGrids.jl","title":"DynamicGrids.positions","text":"positions(x::Union{Neighborhood,NeighborhoodRule}}, cellindex::Tuple) => iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  in the main array. Useful in ManualNeighborhoodRule for  setting neighborhood values.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.offsets","page":"DynamicGrids.jl","title":"DynamicGrids.offsets","text":"offsets(x::Union{Neighborhood,NeighborhoodRule}}) => iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  offset from the central cell.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sumneighbors","page":"DynamicGrids.jl","title":"DynamicGrids.sumneighbors","text":"sumneighbors(hood::Neighborhood, state::T) => T\n\nSums all cells in the neighborhood. This is identical to running sum(neighbors(hood)) but it can be more efficient than as it may use matrix algra libraries for sum, instead of regular sum over an iterator.\n\n\n\n\n\n","category":"function"},{"location":"#Manual-Rules","page":"DynamicGrids.jl","title":"Manual Rules","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"add!\nsub!\nand!\nor!\nxor!","category":"page"},{"location":"#DynamicGrids.add!","page":"DynamicGrids.jl","title":"DynamicGrids.add!","text":"add!(data::WritableGridData, x, I...)\nadd!(A::AbstractArray, x, I...)\n\nAdd the value x to a grid cell.\n\nExample useage\n\nfunction applyrule!(data::SimData, rule::MyManualRule{A,B}, state, cellindex) where {A,B}\n\n    dest, is_inbounds = inbounds(jump .+ cellindex, gridsize(data))\n\n    # Update spotted cell if it's on the grid\n    is_inbounds && add!(data[W], state, dest...)\nend\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sub!","page":"DynamicGrids.jl","title":"DynamicGrids.sub!","text":"sub!(data::WritableGridData, x, I...)\nsub!(A::AbstractArray, x, I...)\n\nSubtract the value x from a grid cell. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.and!","page":"DynamicGrids.jl","title":"DynamicGrids.and!","text":"and!(data::WritableGridData, x, I...)\nand!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c & x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.or!","page":"DynamicGrids.jl","title":"DynamicGrids.or!","text":"or!(data::WritableGridData, x, I...)\nor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c | x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.xor!","page":"DynamicGrids.jl","title":"DynamicGrids.xor!","text":"xor!(data::WritableGridData, x, I...)\nxor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to xor(c, x). See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#Output","page":"DynamicGrids.jl","title":"Output","text":"","category":"section"},{"location":"#Output-Types-and-Constructors","page":"DynamicGrids.jl","title":"Output Types and Constructors","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Output\nArrayOutput\nResultOutput\nGraphicOutput\nREPLOutput\nImageOutput\nGifOutput","category":"page"},{"location":"#DynamicGrids.Output","page":"DynamicGrids.jl","title":"DynamicGrids.Output","text":"Outputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherwise manipulate the simulation grids to improve performance, reduce memory overheads or similar.\n\nSimulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ArrayOutput","page":"DynamicGrids.jl","title":"DynamicGrids.ArrayOutput","text":"ArrayOutput(init; tspan::AbstractRange)\n\nA simple output that stores each step of the simulation in a vector of arrays.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Array\n\nKeyword Argument:\n\ntspan: AbstractRange timespan for the simulation\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ResultOutput","page":"DynamicGrids.jl","title":"DynamicGrids.ResultOutput","text":"ResultOutput(init; tspan::AbstractRange)\n\nA simple output that only stores the final result, not intermediate frames.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Array\n\nKeyword Argument:\n\ntspan: AbstractRange timespan for the simulation\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GraphicOutput","page":"DynamicGrids.jl","title":"DynamicGrids.GraphicOutput","text":"Outputs that display the simulation frames live.\n\nAll GraphicOutputs have a GraphicConfig object  and provide a showframe method.\n\nSee REPLOutput for an example.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.REPLOutput","page":"DynamicGrids.jl","title":"DynamicGrids.REPLOutput","text":"REPLOutput(init; tspan, fps=25.0, store=false, color=:white, cutoff=0.5, style=Block())\n\nAn output that is displayed directly in the REPL. It can either store or discard simulation frames.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of arrays.\n\nKeyword Arguments:\n\ntspan: AbstractRange timespan for the simulation\nfps::Real: frames per second to display the simulation\nstore::Bool: whether ot store the simulation frames for later use\ncolor: a color from Crayons.jl\ncutoff::Real: the cutoff point to display a full or empty cell. Default is 0.5\nstyle::CharStyle: Block() or Braile() style printing. Braile uses 1/4 the screen space.\n\nREPLOutput(init)\n\nThe default option is :block.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ImageOutput","page":"DynamicGrids.jl","title":"DynamicGrids.ImageOutput","text":"Graphic outputs that display the simulation frames as RGB images.\n\nImageOutputs must have a Extent, GraphicConfig  and ImageConfig component, and define a showimage method.\n\nSee GifOutput for an example.\n\nAlthough the majority of the code is maintained here to enable sharing and reuse, most ImageOutputs are not provided in DynamicGrids.jl to avoid heavy dependencies on graphics libraries. See DynamicGridsGtk.jl and DynamicGridsInteract.jl for implementations.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GifOutput","page":"DynamicGrids.jl","title":"DynamicGrids.GifOutput","text":"GifOutput(init; filename, tspan, fps=25.0, store=false, \n          processor=ColorProcessor(), minval=nothing, maxval=nothing)\n\nOutput that stores the simulation as images and saves a Gif file on completion.\n\n\n\n\n\n","category":"type"},{"location":"#Output-methods","page":"DynamicGrids.jl","title":"Output methods","text":"","category":"section"},{"location":"#Grid-processors","page":"DynamicGrids.jl","title":"Grid processors","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"GridProcessor\nSingleGridProcessor\nSparseOptInspector\nColorProcessor\nMultiGridProcessor\nThreeColorProcessor\nLayoutProcessor\nGreyscale\nGrayscale\nTextConfig","category":"page"},{"location":"#DynamicGrids.GridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.GridProcessor","text":"abstract type GridProcessor\n\nGrid processors convert a frame of the simulation into an RGB image for display. Frames may be one or multiple grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleGridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.SingleGridProcessor","text":"abstract type SingleGridProcessor <: GridProcessor\n\nGrid processors that convert one grid into an image array.\n\nThe first grid will be displayed if a SingleGridProcessor is used with a NamedTuple of grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOptInspector","page":"DynamicGrids.jl","title":"DynamicGrids.SparseOptInspector","text":"struct SparseOptInspector <: SingleGridProcessor\n\nSparseOptInspector()\n\nA GridProcessor that checks SparseOpt visually. Cells that do not run show in gray. Errors show in red, but if they do there's a bug.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ColorProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.ColorProcessor","text":"ColorProcessor(; scheme=Greyscale(), zerocolor=nothing, maskcolor=nothing)\n\nConverts output grids to a colorsheme.\n\nArguments / Keyword Arguments\n\nscheme: a ColorSchemes.jl colorscheme, Greyscale or object that defines Base.get(obj, val) and returns a Color or a value that can be converted to Color using ARGB32(val).\nzerocolor: a Color to use when values are zero, or nothing to ignore.\nmaskcolor: a Color to use when cells are masked, or nothing to ignore.\ntextconfig: a TextConfig object.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.MultiGridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.MultiGridProcessor","text":"abstract type MultiGridProcessor <: GridProcessor\n\nProcessors that convert a frame containing multiple grids into a single image.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ThreeColorProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.ThreeColorProcessor","text":"ThreeColorProcessor(; colors=(Red(), Green(), Blue()), zerocolor=nothing, maskcolor=nothing)\n\nAssigns Red(), Blue(), Green() or nothing to any number of dynamic grids in any order. Duplicate colors will be summed. The final color sums are combined into a composite color image for display.\n\nArguments / Keyword Arguments\n\ncolors: a tuple or Red(), Green(), Blue(), or nothing matching the number of grids.\nzerocolor: an RGB color to use when values are zero, or nothing to ignore.\nmaskcolor: an RGB color to use when cells are masked, or nothing to ignore.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.LayoutProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.LayoutProcessor","text":"LayoutProcessor(layout::Array, processors::Matrix, textconfig::TextConfig)\n\nLayoutProcessor allows displaying multiple grids in a block layout, by specifying a layout matrix and a list of SingleGridProcessor to be run for each.\n\nArguments\n\nlayout: A Vector or Matrix containing the keys or numbers of grids in the locations to display them. nothing, missing or 0 values will be skipped.\nprocessors: tuple of SingleGridProcessor, one for each grid in the simulation. Can be nothing or any other value for grids not in layout.\ntextconfig : [TextConfig] object for printing time and grid name labels.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Greyscale","page":"DynamicGrids.jl","title":"DynamicGrids.Greyscale","text":"Greyscale(min=nothing, max=nothing)\n\nDefault colorscheme. Better performance than using a Colorschemes.jl scheme as there is array access or interpolation.\n\nmin and max are values between 0.0 and 1.0 that define the range of greys used.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Grayscale","page":"DynamicGrids.jl","title":"DynamicGrids.Grayscale","text":"Grayscale(min=nothing, max=nothing)\n\nAlternate name for Greyscale().\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.TextConfig","page":"DynamicGrids.jl","title":"DynamicGrids.TextConfig","text":"TextConfig(; font::String, namepixels=14, timepixels=14,\n           namepos=(timepixels+namepixels, timepixels),\n           timepos=(timepixels, timepixels),\n           fcolor=ARGB32(1.0), bcolor=ARGB32(RGB(0.0), 1.0),)\nTextConfig(face, namepixels, namepos, timepixels, timepos, fcolor, bcolor)\n\nText configuration for printing timestep and grid name on the image.\n\nArguments\n\nnamepixels and timepixels: set the pixel size of the font. \ntimepos and namepos: tuples that set the label positions, in pixels.\nfcolor and bcolor: the foreground and background colors, as ARGB32.\n\n\n\n\n\n","category":"type"},{"location":"#Gifs","page":"DynamicGrids.jl","title":"Gifs","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"savegif","category":"page"},{"location":"#DynamicGrids.savegif","page":"DynamicGrids.jl","title":"DynamicGrids.savegif","text":"savegif(filename::String, o::Output, data; processor=processor(o), fps=fps(o), [kwargs...])\n\nWrite the output array to a gif. You must pass a processor keyword argument for any Output objects not in ImageOutput (which allready have a processor attached).\n\nSaving very large gifs may trigger a bug in Imagemagick.\n\n\n\n\n\n","category":"function"},{"location":"#Internal-components-and-methods-for-outputs","page":"DynamicGrids.jl","title":"Internal components and methods for outputs","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"These are used for defining your own outputs and GridProcessors,  not for general scripting.","category":"page"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids.Extent\nDynamicGrids.GraphicConfig\nDynamicGrids.ImageConfig\nDynamicGrids.storeframe!\nDynamicGrids.showframe\nDynamicGrids.showimage\nDynamicGrids.isasync\nDynamicGrids.isshowable\nDynamicGrids.isstored\nDynamicGrids.initialise\nDynamicGrids.delay\nDynamicGrids.finalise\nDynamicGrids.grid2image\nDynamicGrids.rendertext!\nDynamicGrids.rendertime!\nDynamicGrids.rendername!\nDynamicGrids.normalise\nDynamicGrids.rgb","category":"page"},{"location":"#DynamicGrids.Extent","page":"DynamicGrids.jl","title":"DynamicGrids.Extent","text":"Extent(init::Union{AbstractArray,NamedTuple}, \n       mask::Union{AbstractArray,Nothing}, \n       aux::Union{NamedTuple,Nothing}, \n       tspan::AbstractRange)\nExtent(; init, mask=nothing, aux=nothing, tspan, kwargs...)\n\nContainer for extensive variables: spatial and timeseries data. These are kept separate from rules to allow application of rules to alternate spatial and temporal contexts.\n\nExtent is not usually constructed directly by users, but it can be passed to Output constructors instead of init, mask, aux and tspan.\n\ninit: initialisation Array/NamedTuple for grid/s.\nmask: BitArray for defining cells that will/will not be run.\naux: NamedTuple of arbitrary input data. Use aux(data, Vale{:key}) to access from  a Rule in a type-stable way.\ntspan: Time span range. Never type-stable, only access this in precalc methods\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GraphicConfig","page":"DynamicGrids.jl","title":"DynamicGrids.GraphicConfig","text":"GraphicConfig(; fps=25.0, store=false, kwargs...) =\nGraphicConfig(fps, timestamp, stampframe, store)\n\nConfig and variables for graphic outputs.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ImageConfig","page":"DynamicGrids.jl","title":"DynamicGrids.ImageConfig","text":"ImageConfig(processor, minval, maxval) \nImageConfig(; processor=ColorProcessor(), minval=nothing, maxval=nothing)\n\nCommon configuration component for all ImageOutput.\n\nprocessor is any GridProcessor.  minval and maxval fields normalise grid values between zero and one, for use  with Colorshemes.jl. nothing values are considered to represent zero or one  respectively for minval and maxval, and will not be normalised.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.storeframe!","page":"DynamicGrids.jl","title":"DynamicGrids.storeframe!","text":"storeframe!(o::Output, data::AbstractSimData)\n\nStore the current simulaiton frame in the output.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showframe","page":"DynamicGrids.jl","title":"DynamicGrids.showframe","text":"showframe(o::Output, , data::SimData, f, t)\n\nShow the grid(s) in the output, if it can do that.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showimage","page":"DynamicGrids.jl","title":"DynamicGrids.showimage","text":"showimage(image::AbstractArray{AGRB32,2}, output::ImageOutput, f, t)\n\nShow image generated by and GridProcessor in an ImageOutput.\n\nArguments\n\nimage: An array of Color\noutput: the output to define the method for\nf: the current frame number\nt: the current frame date/time\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isasync","page":"DynamicGrids.jl","title":"DynamicGrids.isasync","text":"isasync(o::Output)\n\nCheck if the output should run asynchonously.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isshowable","page":"DynamicGrids.jl","title":"DynamicGrids.isshowable","text":"isshowable(o::Output)\n\nCheck if the output can be shown visually.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isstored","page":"DynamicGrids.jl","title":"DynamicGrids.isstored","text":"isastored(o::Output)\n\nCheck if the output is storing each frame, or just the the current one.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.initialise","page":"DynamicGrids.jl","title":"DynamicGrids.initialise","text":"initialise(o::Output)\n\nInitialise the output display, if it has one.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.delay","page":"DynamicGrids.jl","title":"DynamicGrids.delay","text":"delay(o::Output, f)\n\nGraphic outputs delay the simulations to match some fps rate, but other outputs just do nothing and continue.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.finalise","page":"DynamicGrids.jl","title":"DynamicGrids.finalise","text":"finalise(o::Output)\n\nFinalise the output display, if it has one.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.grid2image","page":"DynamicGrids.jl","title":"DynamicGrids.grid2image","text":"grid2image(o::ImageOutput, data::SimData, grids, f, t)\ngrid2image(p::GridProcessor, o::ImageOutput, data::SimData, grids, f, t)\n\nConvert a grid or NamedRuple of grids to an RGB image, using a GridProcessor. But it they can be dispatched on together when required for custom outputs.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.rendertext!","page":"DynamicGrids.jl","title":"DynamicGrids.rendertext!","text":"rendertext!(img, config::TextConfig, name, t)\n\nRender time name and t as text onto the image, following config settings.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.rendertime!","page":"DynamicGrids.jl","title":"DynamicGrids.rendertime!","text":"rendertime!(img, config::TextConfig, t)\n\nRender time t as text on the image following config settings.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.rendername!","page":"DynamicGrids.jl","title":"DynamicGrids.rendername!","text":"rendername!(img, config::TextConfig, name)\n\nRender name as text on the image following config settings.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.normalise","page":"DynamicGrids.jl","title":"DynamicGrids.normalise","text":"normalise(x, min, max)\n\nSet a value to be between zero and one, before converting to Color. min and max of nothing are assumed to be 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.rgb","page":"DynamicGrids.jl","title":"DynamicGrids.rgb","text":"rgb(val)\n\nConvert a number, tuple or color to an ARGB32 value.\n\n\n\n\n\nrgb(scheme, val)\n\nConvert a color scheme and value to an RGB value.\n\n\n\n\n\n","category":"function"},{"location":"#Ruleset-config","page":"DynamicGrids.jl","title":"Ruleset config","text":"","category":"section"},{"location":"#Overflow","page":"DynamicGrids.jl","title":"Overflow","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Overflow\nWrapOverflow\nRemoveOverflow","category":"page"},{"location":"#DynamicGrids.Overflow","page":"DynamicGrids.jl","title":"DynamicGrids.Overflow","text":"abstract type Overflow\n\nSingleton types for choosing the grid overflow rule used in inbounds and NeighborhoodRule buffers. These determine what is done when a neighborhood or jump extends outside of the grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WrapOverflow","page":"DynamicGrids.jl","title":"DynamicGrids.WrapOverflow","text":"struct WrapOverflow <: Overflow\n\nWrapOverflow()\n\nWrap cordinates that overflow boundaries back to the opposite side of the grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RemoveOverflow","page":"DynamicGrids.jl","title":"DynamicGrids.RemoveOverflow","text":"struct RemoveOverflow <: Overflow\n\nRemoveOverflow()\n\nRemove coordinates that overflow grid boundaries.\n\n\n\n\n\n","category":"type"},{"location":"#Optimisation","page":"DynamicGrids.jl","title":"Optimisation","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"PerformanceOpt\nNoOpt\nSparseOpt","category":"page"},{"location":"#DynamicGrids.PerformanceOpt","page":"DynamicGrids.jl","title":"DynamicGrids.PerformanceOpt","text":"abstract type PerformanceOpt\n\nPerformance optimisations to use in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.NoOpt","page":"DynamicGrids.jl","title":"DynamicGrids.NoOpt","text":"struct NoOpt <: PerformanceOpt\n\nNoOpt()\n\nRun the simulation without performance optimisations besides basic high performance programming.\n\nThis is still very fast, but not intelligent about the work that it does.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOpt","page":"DynamicGrids.jl","title":"DynamicGrids.SparseOpt","text":"SparseOpt()\n\nAn optimisation that ignores all zero values in the grid.\n\nFor low-density simulations performance may improve by orders of magnitude, as only used cells are run.\n\nThis is complicated for optimising neighborhoods - they must run if they contain just one non-zero cell.\n\nThis is best demonstrated with this simulation, where the grey areas do not run except where the neighborhood partially hangs over an area that is not grey.\n\n(Image: SparseOpt demonstration)\n\n\n\n\n\n","category":"type"},{"location":"#Internal-data-handling","page":"DynamicGrids.jl","title":"Internal data handling","text":"","category":"section"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"SimData and GridData objects are used to  manage the simulation and provide rules with any data they need.","category":"page"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"These methods and objects are all subject to change until version 1.0.","category":"page"},{"location":"","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids.GridData\nDynamicGrids.ReadableGridData\nDynamicGrids.WritableGridData\nDynamicGrids.runsim!\nDynamicGrids.simloop!\nDynamicGrids.sequencerules!\nDynamicGrids.maprule!\nDynamicGrids.optmap\nDynamicGrids.readgrids\nDynamicGrids.writegrids\nDynamicGrids.ismasked\nDynamicGrids.getreadgrids\nDynamicGrids.combinegrids\nDynamicGrids.replacegrids\nDynamicGrids.filter_readstate\nDynamicGrids.filter_writestate\nDynamicGrids.update_chainstate","category":"page"},{"location":"#DynamicGrids.GridData","page":"DynamicGrids.jl","title":"DynamicGrids.GridData","text":"Simulation data specific to a single grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ReadableGridData","page":"DynamicGrids.jl","title":"DynamicGrids.ReadableGridData","text":"ReadableGridData(griddata::GridData)\nReadableGridData{Y,X,R}(init::AbstractArray, mask, opt, overflow, padval)\n\nSimulation data and storage passed to rules for each timestep.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WritableGridData","page":"DynamicGrids.jl","title":"DynamicGrids.WritableGridData","text":"ReadableGridData(griddata::GridData)\n\nPassed to rules <: ManualRule, and can be written to directly as an array. This handles updates to SparseOpt() and writing to the correct source/dest array.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.runsim!","page":"DynamicGrids.jl","title":"DynamicGrids.runsim!","text":"runsim!(output::Output, args...)\n\nSimulation runner. Runs a simulation synchonously or asynchonously depending on the return value of isasync(output) - which may be a fixed trait or a field value depending on the output type.\n\nThis allows interfaces with interactive components to update during the simulations.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.simloop!","page":"DynamicGrids.jl","title":"DynamicGrids.simloop!","text":"simloop!(output::Output, simdata::SimData, fspan::UnitRange)\n\nLoop over the frames in fspan, running the ruleset and displaying the output.\n\nOperations on outputs and rulesets are allways mutable and in-place.\n\nOperations on Rules and SimData objects are in a functional style, as they are used in inner loops where immutability improves performance.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sequencerules!","page":"DynamicGrids.jl","title":"DynamicGrids.sequencerules!","text":"sequencerules!(simdata::AbstractSimData)\n\nSequence rules over the SimData object, calling maprule! for each individual Rule.\n\nIf a Vector of SimData is used replicates will be run with Threads.@threads.\n\nTODO: use the new threading method.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.maprule!","page":"DynamicGrids.jl","title":"DynamicGrids.maprule!","text":"maprule!(simdata::SimData, rule::Rule)\n\nMap a rule over the grids it reads from and updating the grids it writes to.\n\nThis is broken into a setup method and an application method to introduce a function barrier, for type stability.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.optmap","page":"DynamicGrids.jl","title":"DynamicGrids.optmap","text":"optmap(f, ::SparseOpt, rdata::GridOrGridTuple, wdata::GridOrGridTuple)\n\nMaps rules over grids with sparse block optimisation. Inactive blocks do not run. This can lead to order of magnitude performance improvments in sparse simulations where large areas of the grid are filled with zeros.\n\n\n\n\n\noptmap(f, ::NoOpt, rgrids::GridOrGridTuple, wgrids::GridOrGridTuple)\n\nMaps rule applicator over the grid with no optimisation\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.readgrids","page":"DynamicGrids.jl","title":"DynamicGrids.readgrids","text":"readgrids(rkeys, rgrids, I...)\n\nRead values from grid/s at index I. This occurs for every cell for every rule, so has to be very fast.\n\nReturns a single value or NamedTuple of values.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.writegrids","page":"DynamicGrids.jl","title":"DynamicGrids.writegrids","text":"writegrids(rkeys, rgrids, I...)\n\nWrite values to grid/s at index I. This occurs for every cell for every rule, so has to be very fast.\n\nReturns a single value or NamedTuple of values.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.ismasked","page":"DynamicGrids.jl","title":"DynamicGrids.ismasked","text":"ismasked(data, I...)\n\nCheck if a cell is masked, using the mask array.\n\nUsed used internally during simulations to skip masked cells.\n\nIf mask was not passed to the Output constructor or sim! it defaults to nothing and false is always returned.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.getreadgrids","page":"DynamicGrids.jl","title":"DynamicGrids.getreadgrids","text":"getredgrids(context, rule::Rule, simdata::AbstractSimData)\n\nRetrieves GridData from a SimData object to match the requirements of a Rule.\n\nReturns a Tuple holding the key or Tuple of keys, and grid or Tuple of grids.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.combinegrids","page":"DynamicGrids.jl","title":"DynamicGrids.combinegrids","text":"combinegrids(rkey, rgrids, wkey, wgrids)\n\nCombine grids into a new NamedTuple of grids depending on the read and write keys required by a rule.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.replacegrids","page":"DynamicGrids.jl","title":"DynamicGrids.replacegrids","text":"replacegrids(simdata::AbstractSimData, newkeys, newgrids)\n\nReplace grids in a NamedTuple with new grids where required.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.filter_readstate","page":"DynamicGrids.jl","title":"DynamicGrids.filter_readstate","text":"filter_readstate(rule, state::NamedTuple)\n\nGet the state to pass to the specific rule as a NamedTuple or single value\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.filter_writestate","page":"DynamicGrids.jl","title":"DynamicGrids.filter_writestate","text":"filter_writestate(rule, state::NamedTuple)\n\nGet the state to write for the specific rule\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.update_chainstate","page":"DynamicGrids.jl","title":"DynamicGrids.update_chainstate","text":"update_chainstate(rule::Rule, state::NamedTuple, writestate)\n\nMerge new state with previous state.\n\nReturns a new NamedTuple with all keys having the most recent state\n\n\n\n\n\n","category":"function"}]
}
