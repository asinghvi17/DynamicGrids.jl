var documenterSearchIndex = {"docs":
[{"location":"#DynamicGrids","page":"DynamicGrids","title":"DynamicGrids","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids","category":"page"},{"location":"#DynamicGrids","page":"DynamicGrids","title":"DynamicGrids","text":"(Image: DynamicGrids)\n\n(Image: ) (Image: ) (Image: Build Status)  (Image: codecov.io) (Image: Aqua.jl Quality Assurance)\n\nDynamicGrids is a generalised framework for building high-performance grid-based spatial simulations, including cellular automata, but also allowing a wider range of behaviours like random jumps and interactions between multiple grids. It is extended by Dispersal.jl for modelling organism dispersal processes.\n\n(Image: Dispersal quarantine)\n\nA dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from DynamicGridsGtk.  Note that this is indicative of the real-time frame-rate on a laptop.\n\nA DynamicGrids.jl simulation is run with a script like this one running the included game of life model Life():\n\nusing DynamicGrids, Crayons\n\ninit = rand(Bool, 150, 200)\noutput = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))\nsim!(output, Life())\n\n# Or define it from scratch (yes this is actually the whole implementation!)\nconst sum_states = (false, false, true, false, false, false, false, false, false), \n                   (false, false, true, true,  false, false, false, false, false)\nlife = Neighbors(Moore(1)) do hood, state\n    sum_states[state + 1][sum(hood) + 1]\nend\nsim!(output, life)\n\n(Image: REPL life)\n\nA game of life simulation being displayed directly in a terminal.\n\nConcepts\n\nThe framework is highly customisable, but there are some central ideas that define how a simulation works: grids, rules, and outputs.\n\nGrids\n\nSimulation grids may be any single AbstractArray or a NamedTuple of multiple AbstractArray. Usually grids contain values of Number, but other types are possible. Grids are updated by Rules that are run for every cell, at every timestep. \n\nThe init grid/s contain whatever initialisation data is required to start a simulation: the array type, size and element type, as well as providing the initial conditions:\n\ninit = rand(Float32, 100, 100)\n\nAn init grid can be attached to an Output: \n\noutput = ArrayOutput(init; tspan=1:100)\n\nor passed in to sim!, where it will take preference over the init attached to the Output, but must be the same type and size:\n\nsim!(output, ruleset; init=init)\n\nFor multiple grids, init is a NamedTuple of equal-sized arrays matching the names given to each Ruleset :\n\ninit = (predator=rand(100, 100), prey=(rand(100, 100))\n\nHandling and passing of the correct grids to a Rule is automated by DynamicGrids.jl. Rules specify which grids they require in what order using the first two (R and W) type parameters, or read and write keyword arguments. \n\nDimensional or spatial init grids from DimensionalData.jl of GeoData.jl will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using Plots.jl, to which shape files and observation points can be easily added.\n\nNon-Number Grids\n\nGrids containing custom and non-Number types are possible, with some caveats. They must define Base.zero for their element type, and should be a bitstype for performance.  Tuple does not define zero. Array is not a bitstype, and does not define zero.  SArray from StaticArrays.jl is both, and can be used as the contents of a grid.  Custom structs that defne zero should also work. \n\nHowever, for any multi-values grid element type, you will need to define a method of  DynamicGrids.rgb that returns an ARGB32 for them to work in ImageOutputs, and  isless for the REPLoutput to work.\n\nRules\n\nRules hold the parameters for running a simulation, and are applied in applyrule method that is called for each of the active cells in the grid. Rules come in a number of flavours (outlined in the docs), which allow assumptions to be made about running them that can greatly improve performance. Rules can be collected in a Ruleset, with some additional arguments to control the simulation:\n\nruleset = Ruleset(Life(2, 3); opt=SparseOpt())\n\nMultiple rules can be combined in a Ruleset. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:\n\nruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt())\n\nFor better performance (often ~2x or more), models included in a Chain object will be combined into a single model, using only one array read and write. This optimisation is limited to CellRule, or a NeighborhoodRule followed by CellRule. If the @inline compiler macro is used on all applyrule methods, all rules in a Chain will be compiled together into a single, efficient function call.\n\nruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))\n\nOutput\n\nOutputs are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: ArrayOutput is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the init array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.\n\noutput = ArrayOutput(init; tspan=1:10)\n\nThe REPLOutput shown above is a GraphicOutput that can be useful for checking a simulation when working in a terminal or over ssh:\n\noutput = REPLOutput(init; tspan=1:100)\n\nImageOutput is the most complex class of outputs, allowing full color visual simulations using ColorSchemes.jl. It can also display multiple grids using color  composites or layouts, as shown above in the quarantine simulation.\n\nDynamicGridsInteract.jl provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. DynamicGridsGtk.jl is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. \n\nOutputs are also easy to write, and high performance applications may benefit from writing a custom output to reduce memory use. Performance of DynamicGrids.jl is dominated by cache interactions, so reducing memory use has positive effects.\n\nExample\n\nThis example implements a very simple forest fire model:\n\nusing DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors\n\nconst DEAD, ALIVE, BURNING = 1, 2, 3\n\nrule = let prob_combustion=0.0001, prob_regrowth=0.01\n    Neighbors(Moore(1)) do neighborhood, cell\n        if cell == ALIVE\n            if BURNING in neighborhood\n                BURNING\n            else\n                rand() <= prob_combustion ? BURNING : ALIVE\n            end\n        elseif cell in BURNING\n            DEAD\n        else\n            rand() <= prob_regrowth ? ALIVE : DEAD\n        end\n    end\nend\n\n# Set up the init array and output (using a Gtk window)\ninit = fill(ALIVE, 400, 400)\nprocessor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))\noutput = GtkOutput(init; tspan=1:200, fps=25, minval=DEAD, maxval=BURNING, processor=processor)\n\n# Run the simulation\nsim!(output, rule)\n\n# Save the output as a gif\nsavegif(\"forestfire.gif\", output)\n\n(Image: forestfire)\n\nTiming the simulation for 200 steps, the performance is quite good:\n\noutput = ArrayOutput(init; tspan=1:200)\n@time sim!(output, ruleset)\n 1.384755 seconds (640 allocations: 2.569 MiB)\n\nAlternatives\n\nAgents.jl can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. \n\nHowever, for simple grid models where you don't need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don't need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.\n\n\n\n\n\n","category":"module"},{"location":"#Running-simulations","page":"DynamicGrids","title":"Running simulations","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"sim!\nresume!\nstep!","category":"page"},{"location":"#DynamicGrids.sim!","page":"DynamicGrids","title":"DynamicGrids.sim!","text":"sim!(output, rules::Rule...; kw...)\nsim!(output, rules::Tuple{<:Rule,Vararg}; kw...)\nsim!(output, [ruleset::Ruleset=ruleset(output)]; kw...)\n\nRuns the simulation, passing the destination aray to the passed in output for each time-step.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one or more Rules. If the output has a Ruleset attached, it will be used.\n\nKeywords\n\nTheses are the taken from the output argument by default:\n\ninit: optional array or NamedTuple of arrays.\nmask: a Bool array matching the init array size. false cells do not run.\naux: a NamedTuple of auxilary data to be used by rules.\ntspan: a tuple holding the start and end of the timespan the simulaiton will run for.\nfps: the frames per second to display. Will be taken from the output if not passed in.\n\nTheses are the taken from the ruleset argument by default:\n\nproc: a Processor to specificy the hardware to run simulations on,    like SingleCPU, ThreadedCPU or CuGPU when    KernelAbstractions.jl and a CUDA gpu is available. \nopt: a PerformanceOpt to specificy optimisations like   SparseOpt or NoOpt. Defaults to NoOpt().\nboundary: what to do with boundary of grid edges.   Options are Remove or Wrap, defaulting to Remove().\ncellsize: the size of cells, which may be accessed by rules.\ntimestep: fixed timestep where this is required for some rules.   eg. Month(1) or 1u\"s\".\n\nOther:\n\nsimdata: a SimData object. Keeping it between simulations can reduce memory allocation a little, when that is important.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.resume!","page":"DynamicGrids","title":"DynamicGrids.resume!","text":"resume!(output::GraphicOutput, ruleset::Ruleset=ruleset(output); tstop, kw...)\n\nRestart the simulation from where you stopped last time. For arguments see sim!. The keyword arg tstop can be used to extend the length of the simulation.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Ruleset containing one ore more Rules. These will each be run in sequence.\n\nKeyword Arguments (optional\n\ninit: an optional initialisation array\ntstop: the new stop time for the simulation. Taken from the output length by default.\nfps: the frames per second to display. Taken from the output by default.\nsimdata: a SimData object. Keeping it between simulations can improve performance   when that is important\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.step!","page":"DynamicGrids","title":"DynamicGrids.step!","text":"step!(sd::SimData, rules=rules(sd))\n\nAllows stepping a simulation one frame at a time, for a more manual approach to simulation that sim!. This may be useful if other processes need to be run  between steps, or the simulation is of variable length. Step also removes the use of Outputs, meaning storing of grid data must be handled manually, if it is  required.\n\nInstead the internal SimData objects are used directly, and can be defined  using a Extent object and a Ruleset.\n\nruleset = Ruleset(myrules) \nextent = Extent(; init=(a=A, b=B), aux=aux, tspan=tspan)\nsimdata = SimData(extent, ruleset) \n# Run a single step\nstep!(simdata)\nsimdata[:a]\n\nThis example returns a GridData object for the :a grid, which is <: AbstractAray.\n\n\n\n\n\n","category":"function"},{"location":"#Rulesets","page":"DynamicGrids","title":"Rulesets","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"AbstractRuleset\nRuleset","category":"page"},{"location":"#DynamicGrids.AbstractRuleset","page":"DynamicGrids","title":"DynamicGrids.AbstractRuleset","text":"AbstractRuleset <: ModelParameters.AbstractModel\n\nAbstract supertype for Ruleset objects and variants.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Ruleset","page":"DynamicGrids","title":"DynamicGrids.Ruleset","text":"Rulseset <: AbstractRuleset\n\nRuleset(rules...; kw...)\n\nA container for holding a sequence of Rules and simulation details like boundary handing and optimisation. Rules will be run in the order they are passed, ie. Ruleset(rule1, rule2, rule3).\n\nKeywords\n\nproc: a Processor to specificy the hardware to run simulations on,    like SingleCPU, ThreadedCPU or CuGPU when    KernelAbstractions.jl and a CUDA gpu is available. \nopt: a PerformanceOpt to specificy optimisations like   SparseOpt. Defaults to NoOpt.\nboundary: what to do with boundary of grid edges.   Options are Remove() or Wrap(), defaulting to Remove.\ncellsize: size of cells.\ntimestep: fixed timestep where this is required for some rules.    eg. Month(1) or 1u\"s\".\n\n\n\n\n\n","category":"type"},{"location":"#Options/Flags","page":"DynamicGrids","title":"Options/Flags","text":"","category":"section"},{"location":"#Boundary-conditions","page":"DynamicGrids","title":"Boundary conditions","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"BoundaryCondition\nWrap\nRemove","category":"page"},{"location":"#DynamicGrids.BoundaryCondition","page":"DynamicGrids","title":"DynamicGrids.BoundaryCondition","text":"BoundaryCondition\n\nAbstract supertype for flags that specify the boundary conditions used in the simulation, used in inbounds and to update NeighborhoodRule grid padding. These determine what happens when a neighborhood or jump extends outside of the grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Wrap","page":"DynamicGrids","title":"DynamicGrids.Wrap","text":"Wrap <: BoundaryCondition\n\nWrap()\n\nBoundaryCondition flag to wrap cordinates that boundary boundaries back to the opposite side of the grid.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; boundary=Wrap())\n# or\noutput = sim!(output, rule; boundary=Wrap())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Remove","page":"DynamicGrids","title":"DynamicGrids.Remove","text":"Remove <: BoundaryCondition\n\nRemove()\n\nBoundaryCondition flag that specifies to assign padval to cells that overflow  grid boundaries. padval defaults to zero(eltype(grid)) but can be assigned as a keyword argument to an Output.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; boundary=Remove())\n# or\noutput = sim!(output, rule; boundary=Remove())\n\n\n\n\n\n","category":"type"},{"location":"#Hardware-selection","page":"DynamicGrids","title":"Hardware selection","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.Processor\nDynamicGrids.CPU\nSingleCPU\nThreadedCPU\nDynamicGrids.GPU\nCuGPU\nCPUGPU","category":"page"},{"location":"#DynamicGrids.Processor","page":"DynamicGrids","title":"DynamicGrids.Processor","text":"Processor\n\nAbstract supertype for selecting a hardware processor, such as ia CPU or GPU.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CPU","page":"DynamicGrids","title":"DynamicGrids.CPU","text":"CPU <: Processor\n\nAbstract supertype for CPU processors.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleCPU","page":"DynamicGrids","title":"DynamicGrids.SingleCPU","text":"SingleCPU <: CPU\n\nSingleCPU()\n\nProcessor flag that specifies to use a single thread on a single CPU.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; proc=SingleCPU())\n# or\noutput = sim!(output, rule; proc=SingleCPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ThreadedCPU","page":"DynamicGrids","title":"DynamicGrids.ThreadedCPU","text":"ThreadedCPU <: CPU\n\nThreadedCPU()\n\nProcessor flag that specifies to use a Threads.nthreads() CPUs.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; proc=ThreadedCPU())\n# or\noutput = sim!(output, rule; proc=ThreadedCPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GPU","page":"DynamicGrids","title":"DynamicGrids.GPU","text":"GPU <: Processor\n\nAbstract supertype for GPU processors.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CuGPU","page":"DynamicGrids","title":"DynamicGrids.CuGPU","text":"CuGPU <: GPU\n\nCuGPU()\nCuGPU{threads_per_block}()\n\nruleset = Ruleset(rule; proc=ThreadedCPU())\n# or\noutput = sim!(output, rule; proc=ThreadedCPU())\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CPUGPU","page":"DynamicGrids","title":"DynamicGrids.CPUGPU","text":"CPUGPU <: GPU\n\nCPUGPU()\n\nUses the CUDA GPU code on CPU using KernelAbstractions, to test it.\n\n\n\n\n\n","category":"type"},{"location":"#Performance-optimisation","page":"DynamicGrids","title":"Performance optimisation","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"PerformanceOpt\nNoOpt\nSparseOpt","category":"page"},{"location":"#DynamicGrids.PerformanceOpt","page":"DynamicGrids","title":"DynamicGrids.PerformanceOpt","text":"PerformanceOpt\n\nAbstract supertype for performance optimisation flags.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.NoOpt","page":"DynamicGrids","title":"DynamicGrids.NoOpt","text":"NoOpt <: PerformanceOpt\n\nNoOpt()\n\nFlag to run a simulation without performance optimisations besides basic high performance programming. Still fast, but not intelligent about the work that it does: all cells are run for all rules.\n\nNoOpt is the default opt method.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOpt","page":"DynamicGrids","title":"DynamicGrids.SparseOpt","text":"SparseOpt <: PerformanceOpt\n\nSparseOpt()\n\nAn optimisation flag that ignores all zero values in the grid.\n\nFor low-density simulations performance may improve by orders of magnitude, as only used cells are run.\n\nThis is complicated for optimising neighborhoods - they must run if they contain just one non-zero cell.\n\nSpecifiy with:\n\nruleset = Ruleset(rule; opt=SparseOpt())\n# or\noutput = sim!(output, rule; opt=SparseOpt())\n\nSparseOpt is best demonstrated with this simulation, where the grey areas do not run except where the neighborhood partially hangs over an area that is not grey:\n\n(Image: SparseOpt demonstration)\n\n\n\n\n\n","category":"type"},{"location":"#Rules","page":"DynamicGrids","title":"Rules","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Rule\nDynamicGrids.SetRule","category":"page"},{"location":"#DynamicGrids.Rule","page":"DynamicGrids","title":"DynamicGrids.Rule","text":"Rule\n\nA Rule object contains the information required to apply an applyrule method to every cell of every timestep of a simulation.\n\nRules are applied to the grid using the applyrule method:\n\n@inline applyrule(data::SimData, rule::YourRule, state, index) = ...\n\nWhere index is a Tuple of Int, and state is a single value, or a NamedTuple if multiple grids are requested. the SimData object can be used to access current  timestep and other simulation data and metadata.\n\nRules can be updated from the original rule before each timestep, in modifyrule:\n\nmodifyrule(rule::YourRule, data::SimData) = ...\n\nRules can also be run in sequence, often wrapped in a Tuple or Rulesets.\n\nDynamicGrids guarantees that:\n\nmodifyrule is run once for every rule for every timestep.    The result is passed to applyrule, but not retained after that.\napplyrule is run once for every rule, for every cell, for every timestep, unless an    optimisation like SparseOpt is enable to skips empty cells.\nthe output of running a rule for any cell does not affect the input of the    same rule running anywhere else in the grid.\nrules later in the sequence are passed grid state updated by the earlier rules.\nmasked areas and wrapped or removed boundary regions are updated between all rules and timesteps\n\nMultiple grids\n\nThe NamedTuple keys will match the keys in R, which is a type like Tuple{:key1,:key1}. Note the names are user-specified, and should never be fixed by a Rule. \n\nThey can be retrieved from the type here as A and B :\n\napplyrule(data::SimData, rule::YourCellRule{Tuple{R1,R2},Tuple{W1,W2}}, state, index) where {R1,R2,W1,W2}\n\nBy default the output is written to the current cell in the specified W write grid/s. Rules writing to multiple grids, simply return a Tuple in the order specified by the W type params.\n\nRule Performance\n\nRules may run many millions of times during a simulation. They need to be fast.  Some basic guidlines for writing rules are:\n\nNever allocate memory in a Rule if you can help it.\nType stability is essential. isinferred is useful to check   if your rule is type-stable.\nUsing the @inline macro on applyrule can help force inlining your   code into the simulation.\nReading and writing from multiple grids is expensive due to additional load   on fast cahce memory. Try to limit the number of grids you use.\nUse a graphical profiler, like ProfileView.jl, to check your rules overall    performance when run with sim!.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetRule","page":"DynamicGrids","title":"DynamicGrids.SetRule","text":"SetRule <: Rule\n\nAbstract supertype for rules that manually write to the grid in some way.\n\nThese must define methods of applyrule!.\n\n\n\n\n\n","category":"type"},{"location":"#CellRule","page":"DynamicGrids","title":"CellRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"CellRule\nCell\nCopyTo","category":"page"},{"location":"#DynamicGrids.CellRule","page":"DynamicGrids","title":"DynamicGrids.CellRule","text":"Cellrule <: Rule\n\nA Rule that only writes and uses a state from single cell of the read grids, and has its return value written back to the same cell(s).\n\nThis limitation can be useful for performance optimisation, such as wrapping rules in Chain so that no writes occur between rules.\n\nCellRule is defined with :\n\nstruct YourCellRule{R,W} <: CellRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule(data::SimData, rule::YourCellRule{R,W}, state, index) where {R,W}\n    state * 2\nend\n\nAs the index is provided in applyrule, you can look up an aux array using aux(data, Val{:auxname}())[index...] to access cell-specific variables for your rule.\n\nIt's good to add a struct field to hold the Val{:auxname}() object instead of using names directly, so that users can set the aux name themselves to suit the scripting context.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Cell","page":"DynamicGrids","title":"DynamicGrids.Cell","text":"Call <: CellRule\n\nCell(f)\nCell{R,W}(f)\n\nA CellRule that applies a function f to the read grid cells and returns the write cells.\n\nEspecially convenient with do notation.\n\nExample\n\nSet the cells of grid :c to the sum of :a and :b:\n\nsimplerule = Cell() do a, b\n    a + b\nend\n\nIf you need to use multiple grids (a and b), use the read and write arguments. If you want to use external variables, wrap the whole thing in a let block, for performance.\n\nrule = let y = y\n    rule = Cell{Tuple{:a,:b},:b}() do a, b\n        a + b * y\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CopyTo","page":"DynamicGrids","title":"DynamicGrids.CopyTo","text":"CopyTo <: CellRule\n\nCopyTo{W}(from)\nCopyTo{W}(; from)\n\nA simple rule that copies aux array slices to a grid over time. This can be used for comparing simulation dynamics to aux data dynamics.\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodRule","page":"DynamicGrids","title":"NeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"NeighborhoodRule\nNeighbors\nConvolution\nLife","category":"page"},{"location":"#DynamicGrids.NeighborhoodRule","page":"DynamicGrids","title":"DynamicGrids.NeighborhoodRule","text":"NeighborhoodRule <: Rule\n\nA Rule that only accesses a neighborhood centered around the current cell. NeighborhoodRule is applied with the method:\n\napplyrule(data::SimData, rule::YourNeighborhoodRule, state, I)\n\nNeighborhoodRule must have a neighborhood field, that holds a Neighborhood object. neighbors(rule) returns an iterator over the surrounding cell pattern defined by the Neighborhood.\n\nFor each cell in the grids the neighborhood buffer will be updated for use in the applyrule method, managed to minimise array reads.\n\nThis allows memory optimisations and the use of high perforance routines on the neighborhood buffer. It also means that and no bounds checking is required in  neighborhood code.\n\nFor neighborhood rules with multiple read grids, the first is always the one used for the neighborhood, the others are passed in as additional state for the cell. Any grids can be written to, but only for the current cell.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Neighbors","page":"DynamicGrids","title":"DynamicGrids.Neighbors","text":"Neighbors <: NeighborhoodRule\n\nNeighbors(f, neighborhood=Moor(1))\nNeighbors{R,W}(f, neighborhood=Moore())\n\nA NeighborhoodRule that receives a neighbors object for the first read grid and the passed in neighborhood, followed by the cell values for the required grids, as with Cell.\n\nReturned value(s) are written to the write/W grid.\n\nAs with all NeighborhoodRule, you do not have to check bounds at grid edges, that is handled for you internally.\n\nUsing SparseOpt may improve neighborhood performance when zero values are common and can be safely ignored.\n\nExample\n\nrule = let x = 10\n    Neighbors{Tuple{:a,:b},:b}() do hood, a, b\n        data[:b][I...] = a + b^x\n    end\nend\n\nThe let block may improve performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Convolution","page":"DynamicGrids","title":"DynamicGrids.Convolution","text":"Convolution <: NeighborhoodRule\n\nConvolution(f, neighborhood=Moore(1))\nConvolution{R,W}(f, neighborhood=Moore(1))\n\nA Rule that runs a basic convolution kernel over the grid.\n\nPerformance\n\nAlways use StaticArrays.jl to define the kernel matrix.\n\nSmall radius convolutions in DynamicGrids.jl will be faster or comparable to using DSP.jl or ImageConvolutions.jl. As the radius increases or grid size gets very large these packages will be a lot faster.\n\nBut Convolution is convenient to chain into a simulation, and combined with some other rules. It should perform reasonably well in all but very large simulations or very large kernels.\n\nExample\n\nrule = Convolution(Kernel(SA[0.05 0.1 0.05; 0.1 0.4 0.1; 0.05 0.1 0.05]))\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Life","page":"DynamicGrids","title":"DynamicGrids.Life","text":"Life <: NeighborhoodRule\n\nLife(neighborhood, born=3, survive=(2, 3))\n\nRule for game-of-life style cellular automata. This is a demonstration of Cellular Automata more than a seriously optimised game of life rule.\n\nCells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.\n\nExamples (gleaned from CellularAutomata.jl)\n\nusing DynamicGrids, Distributions\n# Use `Binomial` to tweak the density random true values\ninit = Bool.(rand(Binomial(1, 0.5), 70, 70))\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:red)\n\n# Morley\nsim!(output, Ruleset(Life(born=[3, 6, 8], survive=[2, 4, 5])))\n\n# 2x2\nsim!(output, Ruleset(Life(born=[3, 6], survive=[1, 2, 5])))\n\n# Dimoeba\ninit = rand(Bool, 400, 300)\ninit[:, 100:200] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:blue, style=Braile())\nsim!(output,  Life(born=(3, 5, 6, 7, 8),  survive=(5, 6, 7, 8)))\n\n## No death\nsim!(output,  Life(born=(3, ),  survive=(0, 1, 2, 3, 4, 5, 6, 7, 8)))\n\n## 34 life\nsim!(output, Life(born=(3, 4), survive=(3, 4)))\n\n# Replicator\ninit = fill(true, 300,300)\ninit[:, 100:200] .= false\ninit[10, :] .= 0\noutput = REPLOutput(init; tspan=1:100, fps=25, color=:yellow)\nsim!(output,  Life(born=(1, 3, 5, 7),  survive=(1, 3, 5, 7)))\nnothing\n\n(Image: REPL Life)\n\n\n\n\n\n","category":"type"},{"location":"#SetCellRule","page":"DynamicGrids","title":"SetCellRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetCellRule\nSetCell","category":"page"},{"location":"#DynamicGrids.SetCellRule","page":"DynamicGrids","title":"DynamicGrids.SetCellRule","text":"SetCellRule <: Rule\n\nAbstract supertype for rules that can manually write to any cells of the grid that they need to.\n\nSetCellRule is applied with a method like:\n\nfunction applyrule!(data::SimData, rule::YourSetCellRule, state, index)\n     inc = 1\n     add!(data, inc, index...)\n     return nothing\nend\n\nNote the ! bang - this method alters the state of data.\n\nTo update the grid, you can use atomic operators add!, sub!, min!, max!, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nIt there are multiple write grids, you will need to get the grid keys from type parameters, here W1 and W2:\n\nfunction applyrule(data, rule::YourSetCellRule{R,Tuple{W1,W2}}, state, index) where {R,W1,W2}\n     inc = 1\n     add!(data[W1], inc, index...)\n     add!(data[W2], 2inc, index...)\n     return nothing\nend\n\nDynamicGrids guarantees that:\n\nvalues written to anywhere on the grid do not affect other cells in   the same rule at the same timestep.\nvalues written to anywhere on the grid are available to the next rule in the    sequence, or the next timestep.\nif atomic operators are always used, race conditions will not occur on any hardware.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetCell","page":"DynamicGrids","title":"DynamicGrids.SetCell","text":"SetCell <: SetCellRule\n\nSetCell(f)\nSetCell{R,W}(f)\n\nA SetCellRule to manually write to the array where you need to. f is passed an indexable data object, and the index of the current cell, followed by the required grid values for the index.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods safely combined writes from all grid cells - directly using setindex! would cause bugs.\n\nExample\n\nrule = let x = 10\n    Set{Tuple{:a,:b},:b}() do data, I, a, b\n        add!(data[:b], a^x, I...)\n    end\nend\n\nThe let block greatly improves performance.\n\n\n\n\n\n","category":"type"},{"location":"#SetNeighborhoodRule","page":"DynamicGrids","title":"SetNeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetNeighborhoodRule\nSetNeighbors","category":"page"},{"location":"#DynamicGrids.SetNeighborhoodRule","page":"DynamicGrids","title":"DynamicGrids.SetNeighborhoodRule","text":"SetNeighborhoodRule <: SetRule\n\nA Rule that only writes to its neighborhood.\n\npositions and offsets are useful iterators for modifying neighborhood values. Atomic\n\nSetNeighborhood rules must return a Neighborhood object from neighborhood(rule). By default this is rule.neighborhood. If this property exists, no interface methods are required.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetNeighbors","page":"DynamicGrids","title":"DynamicGrids.SetNeighbors","text":"SetNeighbors <: SetNeighborhoodRule\n\nSetNeighbors(f, neighborhood=Moor(1))\nSetNeighbors{R,W}(f, neighborhood=Moor(1))\n\nA SetCellRule to manually write to the array with the specified neighborhood. Indexing outside the neighborhood is undefined behaviour.\n\nFunction f is passed an SimData object data, the specified neighborhood object and the index of the current cell, followed by the required grid values for the index.\n\nTo update the grid, you can use: add!, sub! for Number, and and!, or! for Bool. These methods can be safely combined writes from all grid cells.\n\nDirectly using setindex! is possible, but may cause bugs as multiple cells may write to the same location in an unpredicatble order. As a rule, directly setting a neighborhood index should only be done if it always sets the samevalue - then it can be guaranteed that any writes from othe grid cells reach the same result.\n\nneighbors, offsets and positions are useful methods for SetNeighbors rules.\n\nExample\n\nSetNeighbors{Tuple{:a,:b},:b}() do data, hood, I, a, b\n    for pos in positions(hood)\n        add!(data[:b], a^2, pos...)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"#SetGridRule","page":"DynamicGrids","title":"SetGridRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"SetGridRule\nSetGrid","category":"page"},{"location":"#DynamicGrids.SetGridRule","page":"DynamicGrids","title":"DynamicGrids.SetGridRule","text":"SetGridRule <: Rule\n\nA Rule applies to whole grids. This is used for operations that don't benefit from having neighborhood buffering or looping over the grid handled for them, or any specific optimisations. Best suited to simple functions like rand(write)` or using convolutions from other packages like DSP.jl. They may also be useful for doing other custom things that don't fit into the DynamicGrids.jl framework during the simulation.\n\nGrid rules specify the grids they want and are sequenced just like any other grid.\n\nstruct YourSetGridRule{R,W} <: SetGridRule{R,W} end\n\nAnd applied as:\n\nfunction applyrule!(data::SimData, rule::YourSetGridRule{R,W}) where {R,W}\n    rand!(data[W])\nend\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SetGrid","page":"DynamicGrids","title":"DynamicGrids.SetGrid","text":"SetGrid{R,W}(f)\n\nApply a function f to fill whole grid/s.\n\nrule = SetGrid{:a,:b}() do a, b\n    b .= a\nend\n\n\n\n\n\n","category":"type"},{"location":"#Rule-wrappers","page":"DynamicGrids","title":"Rule wrappers","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"RuleWrapper\nChain\nRunIf\nRunAt","category":"page"},{"location":"#DynamicGrids.RuleWrapper","page":"DynamicGrids","title":"DynamicGrids.RuleWrapper","text":"RuleWrapper <: Rule\n\nA Rule that wraps other rules, altering their behaviour or how they are run.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Chain","page":"DynamicGrids","title":"DynamicGrids.Chain","text":"Chain(rules...)\nChain(rules::Tuple)\n\nChains allow chaining rules together to be completed in a single processing step, without intermediate reads or writes from grids.\n\nThey are potentially compiled together into a single function call, especially if you use @inline on all applyrule methods. Chain can hold either all CellRule or NeighborhoodRule followed by CellRule.\n\nSetRule can't be used in Chain, as it doesn't have a return value.\n\n(Image: Chain rule diagram)\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RunIf","page":"DynamicGrids","title":"DynamicGrids.RunIf","text":"RunIf(f, rule)\n\nRunIfs allows wrapping a rule in a condition, passed the SimData object and the cell state and index.\n\n`julia RunIf(dispersal) do data state I     state = oneunit(state) end `\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RunAt","page":"DynamicGrids","title":"DynamicGrids.RunAt","text":"RunAt(rules...)\nRunAt(rules::Tuple)\n\nRunAts allow running a Rule or multiple Rules at a lower frequeny than the main simulation, using a range matching the main tspan but with a larger span, or specific events - by using a vector of arbitrary times in tspan.\n\n\n\n\n\n","category":"type"},{"location":"#Parameter-sources","page":"DynamicGrids","title":"Parameter sources","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"ParameterSource\nAux\nGrid","category":"page"},{"location":"#DynamicGrids.ParameterSource","page":"DynamicGrids","title":"DynamicGrids.ParameterSource","text":"ParameterSource\n\nAbstract supertypes for parameter source wrappers. These allow parameters to be retreived from auxilliary data or from other grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Aux","page":"DynamicGrids","title":"DynamicGrids.Aux","text":"Aux <: ParameterSource\n\nAux{K}()\nAux(K::Symbol)\n\nUse auxilary array with key K as a parameter source.\n\nImplemented in rules with:\n\nget(data, rule.myparam, index...)\n\nWhen an Aux param is specified at rule construction with:\n\nrule = SomeRule(; myparam=Aux{:myaux})\noutput = ArrayOutput(init; aux=(myaux=myauxarray,))\n\nIf the array is a DimensionalData.jl DimArray with a Ti (time) dimension, the correct interval will be selected automatically, precalculated for each timestep so it has no significant overhead.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Grid","page":"DynamicGrids","title":"DynamicGrids.Grid","text":"Grid <: ParameterSource\n\nGrid{K}()\nGrid(K::Symbol)\n\nUse grid with key K as a parameter source.\n\nImplemented in rules with:\n\nget(data, rule.myparam, index...)\n\nAnd specified at rule construction with:\n\nSomeRule(; myparam=Grid{:somegrid})\n\n\n\n\n\n","category":"type"},{"location":"#Custom-Rule-interface-and-helpers","page":"DynamicGrids","title":"Custom Rule interface and helpers","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.applyrule\nDynamicGrids.applyrule!\nDynamicGrids.modifyrule\nisinferred","category":"page"},{"location":"#DynamicGrids.applyrule","page":"DynamicGrids","title":"DynamicGrids.applyrule","text":"applyrule(data::SimData, rule::Rule{R,W}, state, index::Tuple{Int,Int}) -> cell value(s)\n\nApply a rule to the cell state and return values to write to the grid(s).\n\nThis is called in maprule! methods during the simulation, not by the user. Custom Rule implementations must define this method.\n\nArguments:\n\ndata : SimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates\n\nReturns the value(s) to be written to the current cell(s) of the grids specified by the W type parameter.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.applyrule!","page":"DynamicGrids","title":"DynamicGrids.applyrule!","text":"applyrule!(data::SimData, rule::{R,W}, state, index::Tuple{Int,Int}) -> Nothing\n\nApply a rule to the cell state and manually write to the grid data array. Used in all rules inheriting from SetCellRule.\n\nThis is called in internal maprule! methods during the simulation, not by the user. Custom SetCellRule implementations must define this method.\n\nOnly grids specified with the W type parameter will be writable from data.\n\nArguments:\n\ndata : SimData\nrule : Rule\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates - t: the current time step\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.modifyrule","page":"DynamicGrids","title":"DynamicGrids.modifyrule","text":"modifyrule(rule::Rule, data::SimData) -> Rule\n\nPrecalculates rule fields at each timestep. Define this method if a Rule has fields that need to be updated over time.\n\nRules are usually immutable (it's faster), so precalc is expected to returns a new rule object with changes applied to it.  Setfield.jl or Acessors.jl may help with updating the immutable struct.\n\nThe default behaviour is to return the existing rule without change.\n\nUpdated rules are be discarded, and the rule argument is always be the original object passed in.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinferred","page":"DynamicGrids","title":"DynamicGrids.isinferred","text":"isinferred(output::Output, ruleset::Ruleset)\nisinferred(output::Output, rules::Rule...)\n\nTest if a custom rule is inferred and the return type is correct when applyrule or applyrule! is run.\n\nType-stability can give orders of magnitude improvements in performance.\n\n\n\n\n\n","category":"function"},{"location":"#Objects-and-methods-for-use-in-applyrule-and/or-modifyrule","page":"DynamicGrids","title":"Objects and methods for use in applyrule and/or modifyrule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"get\nDynamicGrids.SimData\nDynamicGrids.GridData\nDynamicGrids.ReadableGridData\nDynamicGrids.WritableGridData\nDynamicGrids.ismasked\nDynamicGrids.inbounds\nDynamicGrids.isinbounds\nDynamicGrids.init\nDynamicGrids.aux\nDynamicGrids.mask\nDynamicGrids.tspan\nDynamicGrids.timestep\nDynamicGrids.currenttimestep\nDynamicGrids.currenttime\nDynamicGrids.currentframe","category":"page"},{"location":"#Base.get","page":"DynamicGrids","title":"Base.get","text":"Base.get(data::SimData, key::Union{Symbol,Aux,Grid}, I...)\n\nAllows parameters to be taken from a single value, another grid or an aux array.\n\nIf aux arrays are a DimArray time sequence (with a Ti dim) the currect date will be  calculated automatically.\n\nCurrently this is cycled by default, but will use Cyclic mode in DiensionalData.jl in future.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.SimData","page":"DynamicGrids","title":"DynamicGrids.SimData","text":"SimData <: AbstractSimData\n\nSimData(extent::AbstractExtent, ruleset::AbstractRuleset)\n\nSimulation dataset to hold all intermediate arrays, timesteps and frame numbers for the current frame of the simulation.\n\nA simdata object is accessable in applyrule as the first parameter.\n\nMultiple grids can be indexed into using their key if you need to read from arbitrary locations:\n\nfunciton applyrule(data::SimData, rule::SomeRule{Tuple{A,B}},W}, (a, b), cellindex) where {A,B,W}\n    grid_a = data[A]\n    grid_b = data[B]\n    ...\n\nIn single grid simulations SimData can be indexed directly as if it is a Matrix.\n\nMethods\n\ncurrentframe(data::SimData): get the current frame number, an Int\ncurrenttime(data::SimData): the current frame time, which isa eltype(tspan)\naux(d::SimData, args...): get the aux data NamedTuple, or Nothing. adding a Symbol or Val{:symbol} argument will get a field of aux.\ntspan(d::SimData): get the simulation time span, an AbstractRange.\ntimestep(d::SimData): get the simulaiton time step.\nradius(data::SimData) : returns the Int radius used on the grid, which is also the amount of border padding.\nboundary(data::SimData) : returns the BoundaryCondition - Remove or Wrap.\npadval(data::SimData) : returns the value to use as grid border padding.\n\nThese are available, but you probably shouldn't use them and thier behaviour is not guaranteed in furture versions. They will mean rule is useful only in specific contexts.\n\nextent(d::SimData) : get the simulation AbstractExtent object.\ninit(data::SimData) : get the simulation init AbstractArray/NamedTuple\nmask(data::SimData) : get the simulation mask AbstractArray\nruleset(d::SimData) : get the simulation AbstractRuleset.\nsource(data::SimData) : get the source grid that is being read from.\ndest(data::SimData) : get the dest grid that is being written to.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GridData","page":"DynamicGrids","title":"DynamicGrids.GridData","text":"GridData <: AbstractArray\n\nSimulation data specific to a single grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ReadableGridData","page":"DynamicGrids","title":"DynamicGrids.ReadableGridData","text":"ReadableGridData <: GridData\n\nReadableGridData(grid::GridData)\nReadableGridData{Y,X,R}(init::AbstractArray, mask, opt, boundary, padval)\n\nSimulation data and storage passed to rules for each timestep.\n\nType parameters\n\nY: number of rows \nX: number of columns\nR: grid padding radius \n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WritableGridData","page":"DynamicGrids","title":"DynamicGrids.WritableGridData","text":"WritableGridData <: GridData\n\nWritableGridData(grid::GridData)\n\nPassed to rules as write grids, and can be written to directly as an array,  or preferably using add! etc. All writes handle updates to SparseOpt()  and writing to the correct source/dest array.\n\nReads are always from the source array, as rules must not be sequential between cells. This means using e.g. += is not supported, instead use add!.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ismasked","page":"DynamicGrids","title":"DynamicGrids.ismasked","text":"ismasked(data, I...)\n\nCheck if a cell is masked, using the mask array.\n\nUsed used internally during simulations to skip masked cells.\n\nIf mask was not passed to the Output constructor or sim! it defaults to nothing and false is always returned.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.inbounds","page":"DynamicGrids","title":"DynamicGrids.inbounds","text":"inbounds(data::SimData, I::Tuple) -> Tuple{NTuple{2,Int},Bool}\ninbounds(data::SimData, I...) -> Tuple{NTuple{2,Int},Bool}\n\nCheck grid boundaries for a coordinate before writing in SetCellRule.\n\nReturns a Tuple containing a coordinates Tuple and a Bool - true if the cell is in bounds, false if not.\n\nBoundaryCondition of type Remove returns the coordinate and false  to skip coordinates that boundary outside of the grid.\n\nWrap returns a tuple with the current position or it's wrapped equivalent, and true as it is allways in-bounds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isinbounds","page":"DynamicGrids","title":"DynamicGrids.isinbounds","text":"isinbounds(data, I::Tuple) -> Bool\nisinbounds(data, I...) -> Bool\n\nCheck that a coordinate is within the grid, usually in SetCellRule.\n\nUnlike inbounds, BoundaryCondition status is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.init","page":"DynamicGrids","title":"DynamicGrids.init","text":"init(obj) -> Union{AbstractArray,NamedTUple}\n\nRetrieve the mask from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.aux","page":"DynamicGrids","title":"DynamicGrids.aux","text":"aux(obj, [key])\n\nRetrieve auxilary data NamedTuple from an Output, Extent or SimData object.\n\nGiven key specific data will be returned. key should be a Val{:symbol} for type stability and zero-cost access inside rules. Symbol will also work, but may be slow.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.mask","page":"DynamicGrids","title":"DynamicGrids.mask","text":"mask(obj) -> AbstractArray\n\nRetrieve the mask from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.tspan","page":"DynamicGrids","title":"DynamicGrids.tspan","text":"tspan(obj) -> AbstractRange\n\nRetrieve the time-span AbstractRange from an Output, Extent or SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.timestep","page":"DynamicGrids","title":"DynamicGrids.timestep","text":"timestep(obj)\n\nRetrieve the timestep size from an Output, Extent, Ruleset or SimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttimestep","page":"DynamicGrids","title":"DynamicGrids.currenttimestep","text":"currenttimestep(simdata::SimData)\n\nRetrieve the current timestep from a SimData object.\n\nThis may be different from the timestep. If the timestep is Month, currenttimestep will return Seconds for the length of the specific month.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currenttime","page":"DynamicGrids","title":"DynamicGrids.currenttime","text":"currenttime(simdata::SimData)\n\nRetrieve the current simulation time from a SimData object.\n\nThis will be in whatever type/units you specify in tspan.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.currentframe","page":"DynamicGrids","title":"DynamicGrids.currentframe","text":"currentframe(simdata::SimData) -> Int\n\nRetrieve the current simulation frame a SimData object.\n\n\n\n\n\n","category":"function"},{"location":"#Neighborhoods","page":"DynamicGrids","title":"Neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Neighborhood\nRadialNeighborhood\nMoore\nVonNeumann\nWindow\nAbstractPositional\nPositional\nLayeredPositional\nAbstractKernel\nKernel","category":"page"},{"location":"#DynamicGrids.Neighborhood","page":"DynamicGrids","title":"DynamicGrids.Neighborhood","text":"Neighborhood\n\nNeighborhoods define the pattern of surrounding cells in the \"neighborhood\" of the current cell. The neighbors function returns the surrounding cells as an iterable.\n\nThe main kinds of neighborhood are demonstrated below:\n\n(Image: Neighborhoods)\n\nMoore{3}()\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RadialNeighborhood","page":"DynamicGrids","title":"DynamicGrids.RadialNeighborhood","text":"RadialNeighborhood <: Neighborhood\n\nSquare neighborhoods with radius R, and side length 2R + 1\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Moore","page":"DynamicGrids","title":"DynamicGrids.Moore","text":"Moore <: RadialNeighborhood\n\nMoore(radius::Int=1)\n\nMoore neighborhoods define the neighborhood as all cells within a horizontal or vertical distance of the central cell. The central cell is omitted.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.VonNeumann","page":"DynamicGrids","title":"DynamicGrids.VonNeumann","text":"VonNeumann(radius=1) -> Positional\n\nA convenience wrapper to build Von-Neumann neighborhoods as a Positional neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.Window","page":"DynamicGrids","title":"DynamicGrids.Window","text":"Window <: RadialNeighborhood\n\nWindow{R}()\n\nA neighboorhood of radius R that includes the central cell. R = 1 gives a 3x3 matrix.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractPositional","page":"DynamicGrids","title":"DynamicGrids.AbstractPositional","text":"AbstractPositional <: Neighborhood\n\nNeighborhoods are tuples or vectors of custom coordinates tuples that are specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Positional","page":"DynamicGrids","title":"DynamicGrids.Positional","text":"Positional <: AbstractPositional\n\nPositional(coord::Tuple{Vararg{Int}}...)\nPositional(offsets::Tuple{Tuple{Vararg{Int}}})\n\nNeighborhoods that can take arbitrary shapes by specifying each coordinate, as Tuple{Int,Int} of the row/column distance (positive and negative) from the central point.\n\nThe neighborhood radius is calculated from the most distance coordinate. For simplicity the buffer read from the main grid is a square with sides 2r + 1 around the central point, and is not shrunk or offset to match the coordinates if they are not symmetrical.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.LayeredPositional","page":"DynamicGrids","title":"DynamicGrids.LayeredPositional","text":"LayeredPositional <: AbstractPositional\n\nLayeredPositional(layers::Positional...)\n\nSets of Positional neighborhoods that can have separate rules for each set.\n\nneighbors for LayeredPositional returns a tuple of iterators for each neighborhood layer.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractKernel","page":"DynamicGrids","title":"DynamicGrids.AbstractKernel","text":"AbstractKernel <: Neighborhood\n\nAbstract supertype for kernel neighborhoods.\n\nThese can wrap any other neighborhood object, and include a kernel of the same length and positions as the neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Kernel","page":"DynamicGrids","title":"DynamicGrids.Kernel","text":"Kernel <: AbstractKernel\n\nKernel(neighborhood, kernel)\n\nWrap any other neighborhood object, and includes a kernel of the same length and positions as the neighborhood.\n\nR = 1 gives 3x3 matrices.\n\n\n\n\n\n","category":"type"},{"location":"#Methods-for-use-with-neighborhood-rules-and-neighborhoods","page":"DynamicGrids","title":"Methods for use with neighborhood rules and neighborhoods","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"These are especially useful with SetNeighborhoodRule.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.radius\nDynamicGrids.neighbors\nDynamicGrids.positions\nDynamicGrids.offsets","category":"page"},{"location":"#DynamicGrids.radius","page":"DynamicGrids","title":"DynamicGrids.radius","text":"radius(rule, [key]) -> Int\n\nReturn the radius of a rule or ruleset if it has one, otherwise zero.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.neighbors","page":"DynamicGrids","title":"DynamicGrids.neighbors","text":"neighbors(x::Union{Neighborhood,NeighborhoodRule}}) -> iterable\n\nReturns an iteraterable generator over all cells in the neighborhood.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.positions","page":"DynamicGrids","title":"DynamicGrids.positions","text":"positions(x::Union{Neighborhood,NeighborhoodRule}}, cellindex::Tuple) -> iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  in the main array. Useful in SetNeighborhoodRule for  setting neighborhood values.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.offsets","page":"DynamicGrids","title":"DynamicGrids.offsets","text":"offsets(x::Union{Neighborhood,NeighborhoodRule}}) -> iterable\n\nReturns an iteraterable over all cells as a Tuple of the index  offset from the central cell.\n\nCustom Neighborhoods must define this method.\n\n\n\n\n\n","category":"function"},{"location":"#Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule","page":"DynamicGrids","title":"Atomic methods for SetCellRule and SetNeighborhoodRule","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Using these methods to modify grid values ensures cell independence, and also prevent race conditions with ThreadedCPU or [CuGPU].","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"add!\nsub!\nmin!\nmax!\nand!\nor!\nxor!","category":"page"},{"location":"#DynamicGrids.add!","page":"DynamicGrids","title":"DynamicGrids.add!","text":"add!(data::WritableGridData, x, I...)\n\nAdd the value x to a grid cell.\n\nExample useage\n\nfunction applyrule!(data::SimData, rule::My{A,B}, state, cellindex) where {A,B}\n\n    dest, is_inbounds = inbounds(data, (jump .+ cellindex)...)\n\n    # Update spotted cell if it's on the grid\n    is_inbounds && add!(data[W], state, dest...)\nend\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sub!","page":"DynamicGrids","title":"DynamicGrids.sub!","text":"sub!(data::WritableGridData, x, I...)\n\nSubtract the value x from a grid cell. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.min!","page":"DynamicGrids","title":"DynamicGrids.min!","text":"min!(data::WritableGridData, x, I...)\n\nSet a gride cell to the minimum of x and the current value. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.max!","page":"DynamicGrids","title":"DynamicGrids.max!","text":"max!(data::WritableGridData, x, I...)\n\nSet a gride cell to the maximum of x and the current value. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.and!","page":"DynamicGrids","title":"DynamicGrids.and!","text":"and!(data::WritableGridData, x, I...)\nand!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c & x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.or!","page":"DynamicGrids","title":"DynamicGrids.or!","text":"or!(data::WritableGridData, x, I...)\nor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to c | x. See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.xor!","page":"DynamicGrids","title":"DynamicGrids.xor!","text":"xor!(data::WritableGridData, x, I...)\nxor!(A::AbstractArray, x, I...)\n\nSet the grid cell c to xor(c, x). See add! for example usage.\n\n\n\n\n\n","category":"function"},{"location":"#Output","page":"DynamicGrids","title":"Output","text":"","category":"section"},{"location":"#Output-Types-and-Constructors","page":"DynamicGrids","title":"Output Types and Constructors","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Output\nArrayOutput\nResultOutput\nTransformedOutput\nGraphicOutput\nREPLOutput\nImageOutput\nGifOutput","category":"page"},{"location":"#DynamicGrids.Output","page":"DynamicGrids","title":"DynamicGrids.Output","text":"Output\n\nAbstract supertype for simulation outputs.\n\nOutputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherwise manipulate the simulation grids to improve performance, reduce memory overheads or similar.\n\nSimulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ArrayOutput","page":"DynamicGrids","title":"DynamicGrids.ArrayOutput","text":"ArrayOutput <: Output\n\nArrayOutput(init; tspan::AbstractRange, [aux, mask, padval])\n\nA simple output that stores each step of the simulation in a vector of arrays.\n\nArguments\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ResultOutput","page":"DynamicGrids","title":"DynamicGrids.ResultOutput","text":"ResultOutput <: Output\n\nResultOutput(init; tspan::AbstractRange, kw...)\n\nA simple output that only stores the final result, not intermediate frames.\n\nArguments\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.TransformedOutput","page":"DynamicGrids","title":"DynamicGrids.TransformedOutput","text":"TransformedOutput(f, init; tspan::AbstractRange, kw...)\n\nAn output that stores the result of some function f of the grid/s\n\nArguments\n\nf: a function or functor that accepts an AbstractArray or NamedTuple of   AbstractArray with names matchin init. The AbstractArray will be a view into    the grid the same size as the init grids, removing any padding that has been added.\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GraphicOutput","page":"DynamicGrids","title":"DynamicGrids.GraphicOutput","text":"GraphicOutput <: Output\n\nAbstract supertype for Outputs that display the simulation frames.\n\nAll GraphicOutputs must have a GraphicConfig object and define a showframe method.\n\nSee REPLOutput for an example.\n\nKeywords:\n\nThe default constructor will generate these objects from other keyword arguments  and pass them to the object constructor, which must accept the following:\n\nframes: a Vector of simulation frames (NamedTuple or Array). \nrunning: A Bool.\nextent an Extent object.\ngraphicconfig a GraphicConfigobject.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.REPLOutput","page":"DynamicGrids","title":"DynamicGrids.REPLOutput","text":"REPLOutput <: GraphicOutput\n\nREPLOutput(init; tspan, kw...)\n\nAn output that is displayed directly in the REPL. It can either store or discard simulation frames.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Arrays.\n\nKeywords\n\ntspan: AbstractRange timespan for the simulation\nmask: BitArray for defining cells that will/will not be run.\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\nfps: Real frames per second to display the simulation\nstore: Bool whether ot store the simulation frames for later use\ncolor: a color from Crayons.jl\ncutoff: Real cutoff point to display a full or empty cell. Default is 0.5\nstyle: CharStyle Block() or Braile() printing. Braile uses 1/4 the screen space of Block.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ImageOutput","page":"DynamicGrids","title":"DynamicGrids.ImageOutput","text":"ImageOutput <: GraphicOutput\n\nAbstract supertype for Graphic outputs that display the simulation frames as RGB images.\n\nImageOutputs must have Extent, GraphicConfig  and ImageConfig components, and define a showimage method.\n\nSee GifOutput for an example.\n\nAlthough the majority of the code is maintained here to enable sharing and reuse, most ImageOutputs are not provided in DynamicGrids.jl to avoid heavy dependencies on graphics libraries. See DynamicGridsGtk.jl and DynamicGridsInteract.jl for implementations.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GifOutput","page":"DynamicGrids","title":"DynamicGrids.GifOutput","text":"GifOutput <: ImageOutput\n\nGifOutput(init; filename, tspan, kw...)\n\nOutput that stores the simulation as images and saves a Gif file on completion.\n\nArguments:\n\ninit: initialisation Array or NamedTuple of Array\n\nKeywords\n\nfilename: File path to save the gif file to.\ntspan: AbstractRange timespan for the simulation\naux: NamedTuple of arbitrary input data. Use get(data, Aux(:key), I...)    to access from a Rule in a type-stable way.\nmask: BitArray for defining cells that will/will not be run.\npadval: padding value for grids with neighborhood rules. The default is zero(eltype(init)).\nfont: String font name, used in default TextConfig. A default will be guessed.\ntext: TextConfig object or nothing for no text.\nscheme: ColorSchemes.jl scheme, or Greyscale()\nimagegen: ImageGenerator\nminval: minimum value(s) to set colour maximum\nmaxval: maximum values(s) to set colour minimum\n\n\n\n\n\n","category":"type"},{"location":"#Image-generators","page":"DynamicGrids","title":"Image generators","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"ImageGenerator\nDynamicGrids.SingleGridImageGenerator\nImage\nDynamicGrids.MultiGridImageGenerator\nLayout\nSparseOptInspector","category":"page"},{"location":"#DynamicGrids.ImageGenerator","page":"DynamicGrids","title":"DynamicGrids.ImageGenerator","text":"ImageGenerator\n\nAbstract supertype for objects that convert a frame of the simulation into an ARGB32 image for display. Frames may be a single grid or a NamedTuple of multiple grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleGridImageGenerator","page":"DynamicGrids","title":"DynamicGrids.SingleGridImageGenerator","text":"SingleGridImageGenerator <: ImageGenerator\n\nAbstract supertype for ImageGenerators that convert a single grid  into an image array.\n\nThe first grid will be displayed if a SingleGridImageGenerator is used with a NamedTuple of grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Image","page":"DynamicGrids","title":"DynamicGrids.Image","text":"Image <: SingleGridImageGenerator\n\nImage(; scheme=ObjectScheme(), zerocolor=nothing, maskcolor=nothing)\n\nConverts output grids to a colorsheme.\n\nKeywords\n\nscheme: a ColorSchemes.jl colorscheme, ObjectScheme or object that defines   Base.get(obj, val) and returns a Color or a value that can be converted to Color   using ARGB32(val).\nzerocolor: a Col to use when values are zero, or nothing to ignore.\nmaskcolor: a Color to use when cells are masked, or nothing to ignore.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.MultiGridImageGenerator","page":"DynamicGrids","title":"DynamicGrids.MultiGridImageGenerator","text":"MultiGridImageGenerator <: ImageGenerator\n\nAbstract type for ImageGenerators that convert a frame containing multiple  grids into a single image.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Layout","page":"DynamicGrids","title":"DynamicGrids.Layout","text":"Layout <: MultiGridImageGenerator\n\nLayout(layout::Array, imagegens::Matrix)\n\nLayout allows displaying multiple grids in a block layout, by specifying a  layout matrix and a list of Images to be run for each.\n\nArguments\n\nlayout: A Vector or Matrix containing the keys or numbers of grids in the locations to   display them. nothing, missing or 0 values will be skipped.\nimagegens: tuple of Image, one for each grid in the simulation.   Can be nothing or any other value for grids not in layout.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SparseOptInspector","page":"DynamicGrids","title":"DynamicGrids.SparseOptInspector","text":"SparseOptInspector()\n\nA ImageGenerator that checks SparseOpt visually. Cells that do not run show in gray. Errors show in red, but if they do there's a bug.\n\n\n\n\n\n","category":"type"},{"location":"#Color-schemes","page":"DynamicGrids","title":"Color schemes","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Schemes from Colorschemes.jl can be used for the scheme argument to ImageOutput,  ImageGenerators. Greyscale control over the band of grey used, and is very fast.  ObjectScheme is the default.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"ObjectScheme\nGreyscale","category":"page"},{"location":"#DynamicGrids.ObjectScheme","page":"DynamicGrids","title":"DynamicGrids.ObjectScheme","text":"ObjectScheme\n\nObjectScheme()\n\nDefault colorscheme. Similar to GreyScale for Number.\n\nOther grid objects can define a custom method to return colors from composite objects:\n\nDynamicGrids.to_rgb(::ObjectScheme, obj::MyObjectType) = ...\n\nWhich must return an ARGB32 value.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Greyscale","page":"DynamicGrids","title":"DynamicGrids.Greyscale","text":"Greyscale\n\nGreyscale(min=nothing, max=nothing)\n\nA greeyscale scheme ith better performance than using a  Colorschemes.jl scheme as there is not array access or interpolation.\n\nmin and max are values between 0.0 and 1.0 that define the range of greys used.\n\n\n\n\n\n","category":"type"},{"location":"#Text-labels","page":"DynamicGrids","title":"Text labels","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"TextConfig","category":"page"},{"location":"#DynamicGrids.TextConfig","page":"DynamicGrids","title":"DynamicGrids.TextConfig","text":"TextConfig\n\nTextConfig(; kw...)\nTextConfig(face, namepixels, namepos, timepixels, timepos, fcolor, bcolor)\n\nText configuration for printing timestep and grid name on the image.\n\nArguments / Keywords\n\nfont: String font name.\nnamepixels and timepixels: the pixel size of the font.\ntimepos and namepos: tuples that set the label positions, in Int pixels.\nfcolor and bcolor: the foreground and background colors, as ARGB32.\n\n\n\n\n\n","category":"type"},{"location":"#Saving-gifs","page":"DynamicGrids","title":"Saving gifs","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"savegif","category":"page"},{"location":"#DynamicGrids.savegif","page":"DynamicGrids","title":"DynamicGrids.savegif","text":"savegif(filename::String, o::Output; kw...)\n\nWrite the output array to a gif.\n\nKeywords\n\nfps: Real frames persecond. Defaults to the fps of the output, or 25.\nminval: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nmaxval: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nfont: String name of font to search for. A default will be guessed.\ntext: TextConfig() or nothing for no text. Default is TextConfig(; font=font).\nscheme: ColorSchemes.jl scheme, ObjectScheme() or Greyscale()\nimagegen: ImageGenerator like Image or Layout. Will be detected automatically\n\n\n\n\n\n","category":"function"},{"location":"#Output-interface","page":"DynamicGrids","title":"Output interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"These are used for defining your own outputs and GridProcessors, not for general scripting.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.AbstractExtent\nDynamicGrids.Extent\nDynamicGrids.extent\nDynamicGrids.isasync\nDynamicGrids.storeframe!\nDynamicGrids.isrunning\nDynamicGrids.isshowable\nDynamicGrids.isstored\nDynamicGrids.initialise!\nDynamicGrids.finalise!\nDynamicGrids.frameindex","category":"page"},{"location":"#DynamicGrids.AbstractExtent","page":"DynamicGrids","title":"DynamicGrids.AbstractExtent","text":"AbstractExtent\n\nAbstract supertype for Extent objects, that hold all variables related to space and time in a simulation. Usually the field of an output.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Extent","page":"DynamicGrids","title":"DynamicGrids.Extent","text":"Extent <: AbstractExtent\n\nExtent(init, mask, aux, padval, tspan)\nExtent(; init, tspan, mask=nothing, aux=nothing, padval=zero(eltype(init)), kw...)\n\nContainer for extensive variables: spatial and timeseries data. These are kept separate from rules to allow application of rules to alternate spatial and temporal contexts.\n\nExtent is not usually constructed directly by users, but it can be passed to Output constructors instead of init, mask, aux and tspan.\n\nArguments/Keywords\n\ninit: initialisation Array/NamedTuple for grid/s.\nmask: BitArray for defining cells that will/will not be run.\naux: NamedTuple of arbitrary input data. Use aux(data, Aux(:key)) to access from   a Rule in a type-stable way.\npadval: padding value for grids with neighborhood rules. The default is    zero(eltype(init)).\ntspan: Time span range. Never type-stable, only access this in modifyrule methods\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.extent","page":"DynamicGrids","title":"DynamicGrids.extent","text":"extent(o::Output) => Extent\n\nOutput interface method. Return and Extent object.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isasync","page":"DynamicGrids","title":"DynamicGrids.isasync","text":"isasync(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output should run asynchonously. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.storeframe!","page":"DynamicGrids","title":"DynamicGrids.storeframe!","text":"storeframe!(o::Output, data::AbstractSimData)\n\nStore the current simulaiton frame in the output.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isrunning","page":"DynamicGrids","title":"DynamicGrids.isrunning","text":"isrunning(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output is running. Prevents multiple versions of sim!  running on the same output for asynchronous outputs.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isshowable","page":"DynamicGrids","title":"DynamicGrids.isshowable","text":"isshowable(o::Output, f::Int) => Bool\n\nOutput interface method.\n\nCheck if the output can be shown visually, where f is the frame number. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.isstored","page":"DynamicGrids","title":"DynamicGrids.isstored","text":"isastored(o::Output) => Bool\n\nOutput interface method.\n\nCheck if the output is storing each frame, or just the the current one. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.initialise!","page":"DynamicGrids","title":"DynamicGrids.initialise!","text":"initialise!(o::Output)\n\nOutput interface method.\n\nInitialise the output at the start of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.finalise!","page":"DynamicGrids","title":"DynamicGrids.finalise!","text":"finalise!(o::Output, data::AbstractSimData)\n\nOutput interface method.\n\nFinalise the output at the end of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.frameindex","page":"DynamicGrids","title":"DynamicGrids.frameindex","text":"frameindex(o::Output, data::AbstractSimData)\n\nOutput interface method.\n\nGet the index of the current frame in the output. Every frame has an index of 1 if the simulation isn't stored.\n\n\n\n\n\n","category":"function"},{"location":"#GraphicOutput-interface","page":"DynamicGrids","title":"GraphicOutput interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Also includes Output interface.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.GraphicConfig\nDynamicGrids.graphicconfig\nDynamicGrids.fps\nDynamicGrids.setfps!\nDynamicGrids.showframe\nDynamicGrids.delay\nDynamicGrids.initialisegraphics\nDynamicGrids.finalisegraphics","category":"page"},{"location":"#DynamicGrids.GraphicConfig","page":"DynamicGrids","title":"DynamicGrids.GraphicConfig","text":"GraphicConfig\n\nGraphicConfig(; fps=25.0, store=false)\n\nConfig and variables for graphic outputs.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.graphicconfig","page":"DynamicGrids","title":"DynamicGrids.graphicconfig","text":"graphicconfig(output::GraphicOutput) => GraphicConfig\n\nGraphicOutput interface method. Return an GraphicConfig object. \n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.fps","page":"DynamicGrids","title":"DynamicGrids.fps","text":"fps(o::Output) => Real\n\nGraphicOutput interface method.\n\nGet the frames per second the output will run at. The default is nothing - the simulation runs at full speed.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.setfps!","page":"DynamicGrids","title":"DynamicGrids.setfps!","text":"setfps!(o::Output, x)\n\nGraphicOutput interface method.\n\nSet the frames per second the output will run at.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showframe","page":"DynamicGrids","title":"DynamicGrids.showframe","text":"showframe(o::Output, data::AbstractSimData)\nshowframe(frame::NamedTuple, o::Output, data::AbstractSimData)\nshowframe(frame::AbstractArray, o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nDisplay the grid/s somehow in the output, if it can do that.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.delay","page":"DynamicGrids","title":"DynamicGrids.delay","text":"delay(o::Output, f::Int) => nothing\n\nGraphicOutput interface method.\n\nDelay the simulations to match some fps rate. The default for outputs not  <: GraphicOutput is to do nothing and continue.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.initialisegraphics","page":"DynamicGrids","title":"DynamicGrids.initialisegraphics","text":"initalisegraphics(o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nInitialise the output graphics at the start of the simulation, if it has graphics.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.finalisegraphics","page":"DynamicGrids","title":"DynamicGrids.finalisegraphics","text":"finalisegraphics(o::Output, data::AbstractSimData)\n\nGraphicOutput interface method.\n\nFinalise the output graphics at the end of the simulation, if it has graphics.\n\n\n\n\n\n","category":"function"},{"location":"#ImageOutput-components-and-interface","page":"DynamicGrids","title":"ImageOutput components and interface","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Also uses Output and GraphicOutput interfaces.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.ImageConfig\nDynamicGrids.imageconfig\nDynamicGrids.showimage\nDynamicGrids.grid_to_image!\nDynamicGrids.to_rgb","category":"page"},{"location":"#DynamicGrids.ImageConfig","page":"DynamicGrids","title":"DynamicGrids.ImageConfig","text":"ImageConfig\n\nImageConfig(init; kw...)\n\nCommon configuration component for all ImageOutput.\n\nKeywords\n\ninit output init object, used to generate other arguments automatically.\nminval: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nmaxval: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    Number or Tuple for multiple grids. \nfont: String name of font to search for. A default will be guessed.\ntext: TextConfig() or nothing for no text. Default is TextConfig(; font=font).\nscheme: ColorSchemes.jl scheme, or Greyscale(). ObjectScheme() by default.\nimagegen: ImageGenerator like Image or Layout Will    be detected automatically\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.imageconfig","page":"DynamicGrids","title":"DynamicGrids.imageconfig","text":"imageconfig(output::ImageOutput) => ImageConfig\n\nImageOutpu interface method. Return an ImageConfig object. \n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.showimage","page":"DynamicGrids","title":"DynamicGrids.showimage","text":"showimage(image::AbstractArray, o::ImageOutput)\nshowimage(image::AbstractArray, o::ImageOutput, data::AbstractSimData)\n\nImageOutput interface method.\n\nDisplay an image generated from the grid, a required method for all ImageOutput.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.grid_to_image!","page":"DynamicGrids","title":"DynamicGrids.grid_to_image!","text":"grid_to_image!(o::ImageOutput, data::SimData)\ngrid_to_image!(imbuf, imgen::ImageGenerator, o::ImageOutput, data::SimData, grids)\n\nConvert a grid or NamedRuple of grids to an ARGB32 image, using an  ImageGenerator.\n\nGenerated pixels are written to the image buffer matrix.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.to_rgb","page":"DynamicGrids","title":"DynamicGrids.to_rgb","text":"to_rgb(val) => ARGB32\nto_rgb(scheme, val) => ARGB32\n\nImageOutput interface method.\n\nDisplay an image generated from the grid, a required method for all ImageOutput.\n\nCustom grid object will need to add methods for converting the object to a color,\n\nto_rgb(::ObjectScheme, obj::CustomObj) = ...`\n\nFor use with other colorschemes, a method that calls get with a Real value obtained from the object will be required:\n\nto_rgb(scheme, obj::CustomObj) = ARGB32(get(scheme, real_from_obj(obj)))\n\n\n\n\n\n","category":"function"},{"location":"#Custom-grid-element-types","page":"DynamicGrids","title":"Custom grid element types","text":"","category":"section"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"It is common to use Bool, Int or Float64 as the contents of a grid. But a range of object types can be used if they meet the interface criteria.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Immutable, isbits objects are usually better and the only type officially to work - as they are loaded directly in the simulation. Mutable objects, especially containing pointers, may lead to incorrect stored results, and wont work at all on GPUs.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"Methods to define are: ","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"zero: define zero of the object type\noneunit: define one of the object type\nisless: define comparison between two of the objects\n*: multiplication by a Real scalar.\n/: division by a Real scalar.\n+: addition to another object of the same type\n-: subtraction from another object of the same type\nto_rgb: return and ARGB32 to visualise the object as a pixel ","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"In this example we define a struct with two fields. You will need to determine the correct behaviours for your own types, but hopefully this will get you started.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"struct MYStruct{A,B}\n    a::A\n    b::B\nend\n\nBase.isless(a::MyStruct, b::MyStruct) = isless(a.a, b.a)\nBase.zero(::Type{<:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(zero(T1), zero(T2))\nBase.oneunit(::Type{<:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(one(T1), one(T2))\n\nBase.:*(x::MyStruct, x::Number) = MyStruct(x.a * x, x.b * x)\nBase.:*(x::Number, x::MyStruct) = MyStruct(x * x.a, x * x.b)\nBase.:/(x::MyStruct, x::Number) = MyStruct(x.a / x, x.b / x)\nBase.:+(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a + x2.a, x1.b + x2.b)\nBase.:-(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a - x2.a, x1.b - x2.b)","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"To generate rgb colors for an ImageOuput, you must define to_rgb,  at least for the default ObjectScheme, but this can also be done for other  schemes such as ColorSchemes.jl, or GreyScale, by calling get on the scheme and a  Real value. Note that the objects will be normalised to values between zero and one by minval and maxval scalars prior to this, using the division operators defined  above. It is preferable to use minval and maxval over normalising in to_rgb -  as this will not be as flexible for scripting.","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"DynamicGrids.to_rgb(::ObjectScheme, obj::MyStruct) = ARGB32(obj.a, obj.b, 0)\nDynamicGrids.to_rgb(scheme, obj::MyStruct) = get(scheme, obj.a)","category":"page"},{"location":"","page":"DynamicGrids","title":"DynamicGrids","text":"See the test/objectgrids.jl tests for more details on using complex objects in grids.","category":"page"}]
}
