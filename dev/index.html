<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicGrids.jl · DynamicGrids.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DynamicGrids.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicGrids.jl</a><ul class="internal"><li><a class="tocitem" href="#Running-simulations"><span>Running simulations</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Neighborhoods"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Manual-Rules"><span>Manual Rules</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Ruleset-config"><span>Ruleset config</span></a></li><li><a class="tocitem" href="#Internal-data-handling"><span>Internal data handling</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicGrids.jl"><a class="docs-heading-anchor" href="#DynamicGrids.jl">DynamicGrids.jl</a><a id="DynamicGrids.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicGrids.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids" href="#DynamicGrids"><code>DynamicGrids</code></a> — <span class="docstring-category">Module</span></header><section><div><p><img src="https://repository-images.githubusercontent.com/136250713/956b0c00-5cc7-11eb-9814-eed48441d013" alt="Banner"/></p><p><strong>DynamicGrids</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://cesaraustralia.github.io/DynamicGrids.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.com/cesaraustralia/DynamicGrids.jl"><img src="https://travis-ci.com/cesaraustralia/DynamicGrids.jl.svg?branch=master" alt="Build Status"/></a>  <a href="http://codecov.io/github/cesaraustralia/DynamicGrids.jl?branch=master"><img src="http://codecov.io/github/cesaraustralia/DynamicGrids.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DynamicGrids is a generalised framework for building high-performance grid-based spatial simulations, including cellular automata, but also allowing a wider range of behaviours like random jumps and interactions between multiple grids. It is extended by <a href="https://github.com/cesaraustralia/Dispersal.jl">Dispersal.jl</a> for modelling organism dispersal processes.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif" alt="Dispersal quarantine"/></p><p><em>A dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk</a>.  Note that this is indicative of the real-time frame-rate on a laptop.</em></p><p>A DynamicGrids.jl simulation is run with a script like this one running the included game of life model <code>Life()</code>:</p><pre><code class="language-julia">using DynamicGrids, Crayons

init = rand(Bool, 150, 200)
output = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))
sim!(output, Life())

# Or define it from scratch (yes this is actually the whole implementation!)
const sum_states = (false, false, true, false, false, false, false, false, false), 
                   (false, false, true, true,  false, false, false, false, false)
life = Neighbors(Moore(1)) do hood, state
    sum_states[state + 1][sum(hood) + 1]
end
sim!(output, life)</code></pre><p><img src="https://github.com/cesaraustralia/DynamicGrids.jl/blob/media/life.gif?raw=true" alt="REPL life"/></p><p><em>A game of life simulation being displayed directly in a terminal.</em></p><p><strong>Concepts</strong></p><p>The framework is highly customisable, but there are some central ideas that define how a simulation works: <em>grids</em>, <em>rules</em>, and <em>outputs</em>.</p><p><strong>Grids</strong></p><p>Simulation grids may be any single <code>AbstractArray</code> or a <code>NamedTuple</code> of multiple <code>AbstractArray</code>. Usually grids contain values of <code>Number</code>, but other types are possible. Grids are updated by <code>Rule</code>s that are run for every cell, at every timestep. </p><p>The <code>init</code> grid/s contain whatever initialisation data is required to start a simulation: the array type, size and element type, as well as providing the initial conditions:</p><pre><code class="language-juli">init = rand(Float32, 100, 100)</code></pre><p>An <code>init</code> grid can be attached to an <code>Output</code>: </p><pre><code class="language-none">output = ArrayOutput(init; tspan=1:100)</code></pre><p>or passed in to <code>sim!</code>, where it will take preference over the <code>init</code> attached to the <code>Output</code>, but must be the same type and size:</p><pre><code class="language-none">sim!(output, ruleset; init=init)</code></pre><p>For multiple grids, <code>init</code> is a <code>NamedTuple</code> of equal-sized arrays matching the names given to each <code>Ruleset</code> :</p><pre><code class="language-julia">init = (predator=rand(100, 100), prey=(rand(100, 100))</code></pre><p>Handling and passing of the correct grids to a <code>Rule</code> is automated by DynamicGrids.jl. <code>Rule</code>s specify which grids they require in what order using the first two (<code>R</code> and <code>W</code>) type parameters, or <code>read</code> and <code>write</code> keyword arguments. </p><p>Dimensional or spatial <code>init</code> grids from <a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> of <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a> will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, to which shape files and observation points can be easily added.</p><p><strong>Non-Number Grids</strong></p><p>Grids containing custom and non-<code>Number</code> types are possible, with some caveats. They must define <code>Base.zero</code> for their element type, and should be a bitstype for performance.  Tuple does not define <code>zero</code>. <code>Array</code> is not a bitstype, and does not define <code>zero</code>.  <code>SArray</code> from StaticArrays.jl is both, and can be used as the contents of a grid.  Custom structs that defne <code>zero</code> should also work. </p><p>However, for any multi-values grid element type, you will need to define a method of  <code>DynamicGrids.rgb</code> that returns an <code>ARGB32</code> for them to work in <code>ImageOutput</code>s, and  <code>isless</code> for the <code>REPLoutput</code> to work.</p><p><strong>Rules</strong></p><p>Rules hold the parameters for running a simulation, and are applied in <code>applyrule</code> method that is called for each of the active cells in the grid. Rules come in a number of flavours (outlined in the <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Rules-1">docs</a>), which allow assumptions to be made about running them that can greatly improve performance. Rules can be collected in a <code>Ruleset</code>, with some additional arguments to control the simulation:</p><pre><code class="language-none">ruleset = Ruleset(Life(2, 3); opt=SparseOpt())</code></pre><p>Multiple rules can be combined in a <code>Ruleset</code>. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:</p><pre><code class="language-julia">ruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt())</code></pre><p>For better performance (often ~2x or more), models included in a <code>Chain</code> object will be combined into a single model, using only one array read and write. This optimisation is limited to <code>CellRule</code>, or a <code>NeighborhoodRule</code> followed by <code>CellRule</code>. If the <code>@inline</code> compiler macro is used on all <code>applyrule</code> methods, all rules in a <code>Chain</code> will be compiled together into a single, efficient function call.</p><pre><code class="language-julia">ruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))</code></pre><p><strong>Output</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Output-1">Outputs</a> are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: <code>ArrayOutput</code> is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the <code>init</code> array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.</p><pre><code class="language-julia">output = ArrayOutput(init; tspan=1:10)</code></pre><p>The <code>REPLOutput</code> shown above is a <code>GraphicOutput</code> that can be useful for checking a simulation when working in a terminal or over ssh:</p><pre><code class="language-julia">output = REPLOutput(init; tspan=1:100)</code></pre><p><code>ImageOutput</code> is the most complex class of outputs, allowing full color visual simulations using ColorSchemes.jl. It can also display multiple grids using color  composites or layouts, as shown above in the quarantine simulation.</p><p><a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. </p><p>Outputs are also easy to write, and high performance applications may benefit from writing a custom output to reduce memory use. Performance of DynamicGrids.jl is dominated by cache interactions, so reducing memory use has positive effects.</p><p><strong>Example</strong></p><p>This example implements a very simple forest fire model:</p><pre><code class="language-julia">using DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors

const DEAD, ALIVE, BURNING = 1, 2, 3

rule = let prob_combustion=0.0001, prob_regrowth=0.01
    Neighbors(Moore(1)) do neighborhood, cell
        if cell == ALIVE
            if BURNING in neighborhood
                BURNING
            else
                rand() &lt;= prob_combustion ? BURNING : ALIVE
            end
        elseif cell in BURNING
            DEAD
        else
            rand() &lt;= prob_regrowth ? ALIVE : DEAD
        end
    end
end

# Set up the init array and output (using a Gtk window)
init = fill(ALIVE, 400, 400)
processor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))
output = GtkOutput(init; tspan=1:200, fps=25, minval=DEAD, maxval=BURNING, processor=processor)

# Run the simulation
sim!(output, rule)

# Save the output as a gif
savegif(&quot;forestfire.gif&quot;, output)</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif" alt="forestfire"/></p><p>Timing the simulation for 200 steps, the performance is quite good:</p><pre><code class="language-julia">output = ArrayOutput(init; tspan=1:200)
@time sim!(output, ruleset)
 1.384755 seconds (640 allocations: 2.569 MiB)</code></pre><p><strong>Alternatives</strong></p><p><a href="https://github.com/JuliaDynamics/Agents.jl">Agents.jl</a> can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. </p><p>However, for simple grid models where you don&#39;t need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don&#39;t need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/DynamicGrids.jl#L3-L237">source</a></section></article><h2 id="Running-simulations"><a class="docs-heading-anchor" href="#Running-simulations">Running simulations</a><a id="Running-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Running-simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sim!" href="#DynamicGrids.sim!"><code>DynamicGrids.sim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sim!(output, rules::Rule...; kw...)
sim!(output, rules::Tuple{&lt;:Rule,Vararg}; kw...)
sim!(output, [ruleset::Ruleset=ruleset(output)];
     init=init(output),
     mask=mask(output),
     tstpan=tspan(output),
     aux=aux(output),
     fps=fps(output),
     proc=opt(ruleset)
     opt=opt(ruleset),
     boundary=opt(ruleset),
     cellsize=opt(ruleset),
     timestep=opt(ruleset),
     simdata=nothing
)</code></pre><p>Runs the simulation, passing the destination aray to the passed in output for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one or more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s. If the output has a <code>Ruleset</code> attached, it will be used.</li></ul><p><strong>Keyword Arguments</strong></p><p>Theses are the taken from the <code>output</code> argument by default:</p><ul><li><code>init</code>: optional array or NamedTuple of arrays.</li><li><code>mask</code>: a <code>Bool</code> array matching the init array size. <code>false</code> cells do not run.</li><li><code>aux</code>: a <code>NamedTuple</code> of auxilary data to be used by rules.</li><li><code>tspan</code>: a tuple holding the start and end of the timespan the simulaiton will run for.</li><li><code>fps</code>: the frames per second to display. Will be taken from the output if not passed in.</li></ul><p>Theses are the taken from the <code>ruleset</code> argument by default:</p><ul><li><code>proc</code>: a <a href="@ref"><code>Processor</code></a> to specificy the hardware to run simulations on,  like <a href="@ref"><code>SingleCPU</code></a>, <a href="@ref"><code>ThreadedCPU</code></a> or <a href="@ref"><code>CuGPU</code></a> when  KernelAbstractions.jl and a CUDA gpu is available. </li><li><code>opt</code>: a <a href="#DynamicGrids.PerformanceOpt"><code>PerformanceOpt</code></a> to specificy optimisations like <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> or <a href="#DynamicGrids.NoOpt"><code>NoOpt</code></a>. Defaults to <code>NoOpt()</code>.</li><li><code>boundary</code>: what to do with boundary of grid edges. Options are <a href="#DynamicGrids.Remove"><code>Remove</code></a> or <a href="#DynamicGrids.Wrap"><code>Wrap</code></a>, defaulting to <code>Remove()</code>.</li><li><code>cellsize</code>: the size of cells, which may be accessed by rules.</li><li><code>timestep</code>: fixed timestep where this is required for some rules. eg. <code>Month(1)</code> or <code>1u&quot;s&quot;</code>.</li></ul><p>Other:</p><ul><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can reduce memory allocation a little, when that is important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/framework.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.resume!" href="#DynamicGrids.resume!"><code>DynamicGrids.resume!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resume!(output::GraphicOutput, ruleset::Ruleset=ruleset(output);
        tstop=last(tspan(output)),
        fps=fps(output),
        simdata=nothing)</code></pre><p>Restart the simulation from where you stopped last time. For arguments see <a href="#DynamicGrids.sim!"><code>sim!</code></a>. The keyword arg <code>tstop</code> can be used to extend the length of the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one ore more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s. These will each be run in sequence.</li></ul><p><strong>Keyword Arguments (optional</strong></p><ul><li><code>init</code>: an optional initialisation array</li><li><code>tstop</code>: the new stop time for the simulation. Taken from the output length by default.</li><li><code>fps</code>: the frames per second to display. Taken from the output by default.</li><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can improve performance when that is important</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/framework.jl#L99">source</a></section></article><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><p>Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> or <a href="#DynamicGrids.applyrule!"><code>applyrule!</code></a> methods. Rules can be chained together arbitrarily to make composite simulations across any number of grids.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Ruleset" href="#DynamicGrids.Ruleset"><code>DynamicGrids.Ruleset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ruleset(rules...; boundary=Remove(), opt=NoOpt(), cellsize=1, timestep=nothing)</code></pre><p>A container for holding a sequence of <code>Rule</code>s and simulation details like boundary handing and optimisation. Rules will be run in the order they are passed, ie. <code>Ruleset(rule1, rule2, rule3)</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>proc</code>: a <a href="@ref"><code>Processor</code></a> to specificy the hardware to run simulations on,  like <a href="@ref"><code>SingleCPU</code></a>, <a href="@ref"><code>ThreadedCPU</code></a> or <a href="@ref"><code>CuGPU</code></a> when  KernelAbstractions.jl and a CUDA gpu is available. </li><li><code>opt</code>: a <a href="#DynamicGrids.PerformanceOpt"><code>PerformanceOpt</code></a> to specificy optimisations like <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a>. Defaults to <a href="#DynamicGrids.NoOpt"><code>NoOpt</code></a>.</li><li><code>boundary</code>: what to do with boundary of grid edges. Options are <code>Remove()</code> or <code>Wrap()</code>, defaulting to <a href="#DynamicGrids.Remove"><code>Remove</code></a>.</li><li><code>cellsize</code>: size of cells.</li><li><code>timestep</code>: fixed timestep where this is reuired for some rules. eg. <code>Month(1)</code> or <code>1u&quot;s&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Rule" href="#DynamicGrids.Rule"><code>DynamicGrids.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Rule</code> object contains the information required to apply some logical rule to every cell of every timestep of a simulation.</p><p>Rules can be chained together sequentially into <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>s.</p><p>Rules are applied to the grid using the <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> method:</p><pre><code class="language-julia">@inline applyrule(data::SimData, rule::YourRule, state, cellindex) =</code></pre><p>Where cellindex is a <code>Tuple</code> of <code>Int</code>, and <code>state</code> is a single value, or a <code>NamedTuple</code> if multiple grids are requested. The <code>NamedTuple</code> keys will match the keys in <code>R</code>, which is a type like <code>Tuple{:key1,:key1}</code> - note the names are user specified, and should never be fixed by a Rule - they can be retrieved from the type here as <code>A</code> and <code>B</code> :</p><pre><code class="language-julia">applyrule(data::SimData, rule::YourCellRule{Tuple{R1,R2},Tuple{W1,W2}}, state, cellindex) where {R1,R2,W1,W2}</code></pre><p>By default the output is written to the current cell in the specified <code>W</code> write grid/s. <code>Rule</code>s writing to multiple grids, simply return a <code>Tuple</code> in the order specified by the <code>W</code> type params.</p><p><strong>Precalculation</strong></p><p><a href="#DynamicGrids.precalcrule"><code>precalcrule</code></a> can be used to precalculate any fields that depend on the timestep. Otherwise everything should be precalculated apon construction.</p><p>Retreive required information from <a href="#DynamicGrids.SimData"><code>SimData</code></a> such as <a href="#DynamicGrids.currenttime"><code>currenttime</code></a> or <a href="#DynamicGrids.currentframe"><code>currentframe</code></a>. The return value is the updated rule.</p><pre><code class="language-julia">precalcrule(rule::YourCellRule, data::SimData)</code></pre><p><strong>Rule Performance</strong></p><p>Rules may run many millions of times during a simulation. They need to be fast.</p><p>Some basic guidlines for writing rules are:</p><ul><li>Never allocate memory in a <code>Rule</code> if you can help it.</li><li>Type stability is essential. <a href="#DynamicGrids.isinferred"><code>isinferred</code></a> is useful to check if your rule is type-stable.</li><li>Using the <code>@inline</code> macro on <code>applyrule</code> can help force inlining your code into the simulation.</li><li>Reading and writing from multiple grids is expensive due to additional load on fast cahce memory. Try to limit the number of grids you use.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CellRule" href="#DynamicGrids.CellRule"><code>DynamicGrids.CellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Rule</code> that only writes and uses a state from single cell of the read grids, and has its return value written back to the same cell(s).</p><p>This limitation can be useful for performance optimisation, such as wrapping rules in <a href="#DynamicGrids.Chain"><code>Chain</code></a> so that no writes occur between rules.</p><p><code>CellRule</code> is defined with :</p><pre><code class="language-julia">struct YourCellRule{R,W} &lt;: CellRule{R,W} end</code></pre><p>And applied as:</p><pre><code class="language-julia">function applyrule(data::SimData, rule::YourCellRule{R,W}, state, cellindex) where {R,W}
    state * 2
end</code></pre><p>As the <code>cellindex</code> is provided in <code>applyrule</code>, you can look up an <a href="#DynamicGrids.aux"><code>aux</code></a> array using <code>aux(data, Val{:auxname}())[cellindex...]</code> to access cell-specific variables for your rule.</p><p>It&#39;s good to add a struct field to hold the <code>Val{:auxname}()</code> object instead of using names directly, so that users can set the aux name themselves to suit the scripting context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Cell" href="#DynamicGrids.Cell"><code>DynamicGrids.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cell(f)
Cell{R,W}(f)</code></pre><p>A <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> that applies a function <code>f</code> to the <code>read</code> grid cells and returns the <code>write</code> cells.</p><p>Especially convenient with <code>do</code> notation.</p><p><strong>Example</strong></p><p>Set the cells of grid <code>:c</code> to the sum of <code>:a</code> and <code>:b</code>:</p><pre><code class="language-julia">simplerule = Cell() do a, b
    a + b
end</code></pre><p>If you need to use multiple grids (a and b), use the <code>read</code> and <code>write</code> arguments. If you want to use external variables, wrap the whole thing in a <code>let</code> block, for performance.</p><pre><code class="language-julia">rule = let y = y
    rule = Cell{Tuple{:a,:b},:b}() do a, b
        a + b * y
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NeighborhoodRule" href="#DynamicGrids.NeighborhoodRule"><code>DynamicGrids.NeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Rule that only accesses a neighborhood centered around the current cell. <code>NeighborhoodRule</code> is applied with the method:</p><pre><code class="language-julia">applyrule(data::SimData, rule::YourNeighborhoodRule, state, I)</code></pre><p><code>NeighborhoodRule</code> must have a <code>neighborhood</code> field, that holds a <a href="#DynamicGrids.Neighborhood"><code>Neighborhood</code></a> object. <code>neighbors(rule)</code> returns an iterator over the surrounding cell pattern defined by the <code>Neighborhood</code>.</p><p>For each cell in the grids the neighborhood buffer will be updated for use in the <code>applyrule</code> method, managed to minimise array reads.</p><p>This allows memory optimisations and the use of BLAS routines on the neighborhood buffer for <a href="#DynamicGrids.Moore"><code>Moore</code></a> neighborhoods. It also means that and no bounds checking is required in neighborhood code.</p><p>For neighborhood rules with multiple read grids, the first is always the one used for the neighborhood, the others are passed in as additional state for the cell. Any grids can be written to, but only for the current cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighbors" href="#DynamicGrids.Neighbors"><code>DynamicGrids.Neighbors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Neighbors(f, neighborhood=Moor(1))
Neighbors{R,W}(f, neighborhood=Moore())</code></pre><p>A <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> that receives a neighbors object for the first <code>read</code> grid and the passed in neighborhood, followed by the cell values for the required grids, as with <a href="#DynamicGrids.Cell"><code>Cell</code></a>.</p><p>Returned value(s) are written to the <code>write</code>/<code>W</code> grid.</p><p>As with all <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a>, you do not have to check bounds at grid edges, that is handled for you internally.</p><p>Using <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> may improve neighborhood performance when zero values are common and can be safely ignored.</p><p><strong>Example</strong></p><pre><code class="language-julia">rule = let x = 10
    Neighbors{Tuple{:a,:b},:b}() do hood, a, b
        data[:b][I...] = a + b^x
    end
end</code></pre><p>The <code>let</code> block may improve performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Convolution" href="#DynamicGrids.Convolution"><code>DynamicGrids.Convolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Convolution(f, neighborhood=Moor(1))
Convolution{R,W}(f, neighborhood=Moor(1))</code></pre><p>A <code>Rule</code> that runs a basic convolution kernel over the grid.</p><p><strong>Performance</strong></p><p><em>Always</em> use StaticArrays.jl to define the kernel matrix.</p><p>Small radius convolutions in DynamicGrids.jl will be faster or comparable to using DSP.jl or ImageConvolutions.jl. As the radius increases or grid size gets very large these packages will be a lot faster.</p><p>But <code>Convolution</code> is convenient to chain into a simlulation, and combined with some other  rules. It should perform reasonably well in all but very large simulations or very large  kernels.</p><p><strong>Example</strong></p><pre><code class="language-julia">rule = Convolution(Kernel(SA[0.05 0.1 0.05; 0.1 0.4 0.1; 0.05 0.1 0.05]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Life" href="#DynamicGrids.Life"><code>DynamicGrids.Life</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Life(neighborhood, born=3, survive=(2, 3))</code></pre><p>Rule for game-of-life style cellular automata. This is a demonstration of Cellular Automata more than a seriously optimised game of life rule.</p><p>Cells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.</p><p><strong>Examples (gleaned from CellularAutomata.jl)</strong></p><pre><code class="language-julia">using DynamicGrids, Distributions
# Use `Binomial` to tweak the density random true values
init = Bool.(rand(Binomial(1, 0.5), 70, 70))
output = REPLOutput(init; tspan=1:100, fps=25, color=:red)

# Morley
sim!(output, Ruleset(Life(born=[3, 6, 8], survive=[2, 4, 5])))

# 2x2
sim!(output, Ruleset(Life(born=[3, 6], survive=[1, 2, 5])))

# Dimoeba
init = rand(Bool, 400, 300)
init[:, 100:200] .= 0
output = REPLOutput(init; tspan=1:100, fps=25, color=:blue, style=Braile())
sim!(output,  Life(born=(3, 5, 6, 7, 8),  survive=(5, 6, 7, 8)))

## No death
sim!(output,  Life(born=(3, ),  survive=(0, 1, 2, 3, 4, 5, 6, 7, 8)))

## 34 life
sim!(output, Life(born=(3, 4), survive=(3, 4)))

# Replicator
init = fill(true, 300,300)
init[:, 100:200] .= false
init[10, :] .= 0
output = REPLOutput(init; tspan=1:100, fps=25, color=:yellow)
sim!(output,  Life(born=(1, 3, 5, 7),  survive=(1, 3, 5, 7)))
nothing</code></pre><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/life.gif" alt="REPL Life"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/life.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetCellRule" href="#DynamicGrids.SetCellRule"><code>DynamicGrids.SetCellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SetCellRule</code> is the supertype for rules that manually write to whichever cells of the grid that they choose, instead of automatically updating every cell with their output.</p><p><code>SetCellRule</code> is applied with a method like:</p><pre><code class="language-julia">function applyrule!(data::SimData, rule::YourSetCellRule{R,W}, state, cellindex) where {R,W}
     inc = 1
     add!(data[W], inc, cellindex...)
     return nothing
end</code></pre><p>Note the <code>!</code> bang - this method alters the state of <code>data</code>. We also use the type parameter <code>W</code> (write) to index into the <code>data</code> object. You could also just use <code>first(dat)</code> when there is only one <code>W</code> write grid.</p><p>To update the grid, you can use: <a href="#DynamicGrids.add!"><code>add!</code></a>, <a href="#DynamicGrids.sub!"><code>sub!</code></a> for <code>Number</code>, and <a href="#DynamicGrids.and!"><code>and!</code></a>, <a href="#DynamicGrids.or!"><code>or!</code></a> for <code>Bool</code>. These methods safely combined writes from all grid cells - directly using <code>setindex!</code> would cause bugs.</p><p>It there are multiple write grids, you will need to get the grid keys from type parameters, here <code>W1</code> and <code>W2</code>:</p><pre><code class="language-julia">function applyrule(data, rule::YourManRule{R,Tuple{W1,W2}}, state, cellindex) where {R,W1,W2}
     inc = 1
     add!(data[W1], inc, cellindex...)
     add!(data[W2], 2inc, cellindex...)
     return nothing
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L144">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Manual</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetNeighborhoodRule" href="#DynamicGrids.SetNeighborhoodRule"><code>DynamicGrids.SetNeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Rule that only writes to its neighborhood.</p><p><a href="#DynamicGrids.positions"><code>positions</code></a> and <a href="#DynamicGrids.offsets"><code>offsets</code></a> are useful iterators for modifying neighborhood values.</p><p>SetNeighborhood rules must return a <code>Neighborhood</code> object from <code>neighborhood(rule)</code>. By default this is <code>rule.neighborhood</code>. If this property exists, no interface methods  are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetNeighbors" href="#DynamicGrids.SetNeighbors"><code>DynamicGrids.SetNeighbors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SetNeighbors(f, neighborhood=Moor(1))
SetNeighbors{R,W}(f, neighborhood=Moor(1))</code></pre><p>A <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a> to manually write to the array with the specified  neighborhood. Indexing outside the neighborhood is undefined behaviour.</p><p>Function <code>f</code> is passed an <a href="#DynamicGrids.SimData"><code>SimData</code></a> object <code>data</code>, the specified  neighborhood object and the index of the current cell, followed by the required  grid values for the index. </p><p>To update the grid, you can use: <a href="#DynamicGrids.add!"><code>add!</code></a>, <a href="#DynamicGrids.sub!"><code>sub!</code></a> for <code>Number</code>, and <a href="#DynamicGrids.and!"><code>and!</code></a>, <a href="#DynamicGrids.or!"><code>or!</code></a> for <code>Bool</code>. These methods can be safely combined writes from all grid cells. </p><p>Directly using <code>setindex!</code> is possible, but may cause bugs as multiple cells may write to the same location in an unpredicatble order. As a rule, directly setting a neighborhood index should only be done for a single value - then it can  be guaranteed that any writes from othe grid cells reach the same result.</p><p>[<code>neighbors</code>], [<code>offsets</code>] and <a href="#DynamicGrids.positions"><code>positions</code></a> are useful methods</p><p><strong>Example</strong></p><pre><code class="language-julia">rule = let x = 10
    SetNeighbors{Tuple{:a,:b},:b}() do data, hood, I, a, b
        for pos in positions(hood)
            add!(data[:b], a^x, pos...)
        end
    end
end</code></pre><p>The <code>let</code> block greatly improves performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/rules.jl#L414">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GridRule</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Grid</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Chain" href="#DynamicGrids.Chain"><code>DynamicGrids.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain(rules...)
Chain(rules::Tuple)</code></pre><p><code>Chain</code>s allow chaining rules together to be completed in a single processing step, without intermediate reads or writes from grids.</p><p>They are potentially compiled together into a single function call, especially if you use <code>@inline</code> on all <code>applyrule</code> methods. <code>Chain</code> can hold either all <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> or <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>.</p><p><a href="@ref">``</a> can&#39;t be used in <code>Chain</code>, as it doesn&#39;t have a return value.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/Chain.png" alt="Chain rule diagram"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/chain.jl#L1">source</a></section></article><h3 id="Rule-methods-and-helpers"><a class="docs-heading-anchor" href="#Rule-methods-and-helpers">Rule methods and helpers</a><a id="Rule-methods-and-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-methods-and-helpers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule" href="#DynamicGrids.applyrule"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule(data::SimData, rule::Rule{R,W}, state, index::Tuple{Int,Int}) =&gt; cell value(s)</code></pre><p>Apply a rule to the cell state and return values to write to the grid(s).</p><p>This is called in <code>maprule!</code> methods during the simulation, not by the user. Custom <code>Rule</code> implementations must define this method.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code> : <a href="#DynamicGrids.SimData"><code>SimData</code></a></li><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>state</code>: the value(s) of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates</li></ul><p>Returns the value(s) to be written to the current cell(s) of the grids specified by the <code>W</code> type parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule!" href="#DynamicGrids.applyrule!"><code>DynamicGrids.applyrule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule!(data::SimData, rule::{R,W}, state, index::Tuple{Int,Int}) =&gt; Nothing</code></pre><p>Apply a rule to the cell state and manually write to the grid data array. Used in all rules inheriting from <a href="@ref">``</a>.</p><p>This is called in internal <code>maprule!</code> methods during the simulation, not by the user. Custom <a href="@ref">``</a> implementations must define this method.</p><p>Only grids specified with the <code>W</code> type parameter will be writable from <code>data</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code> : <a href="#DynamicGrids.SimData"><code>SimData</code></a></li><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>state</code>: the value(s) of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates - <code>t</code>: the current time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.precalcrule" href="#DynamicGrids.precalcrule"><code>DynamicGrids.precalcrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precalcrule(rule::Rule, data::SimData) =&gt; Rule</code></pre><p>Precalculates rule fields at each timestep. Define this method if a <a href="#DynamicGrids.Rule"><code>Rule</code></a> has fields that need to be updated over time.</p><p><code>Rule</code>s are usually immutable (it&#39;s faster), so precalc is expected to returns a new rule object with changes applied to it.  Setfield.jl or Acessors.jl may help with updating the immutable struct.</p><p>The default behaviour is to return the existing rule without change.</p><p>Updated rules are be discarded, and the <code>rule</code> argument is always be the original object passed in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isinferred" href="#DynamicGrids.isinferred"><code>DynamicGrids.isinferred</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isinferred(output::Output, ruleset::Ruleset)
isinferred(output::Output, rules::Rule...)</code></pre><p>Test if a custom rule is inferred and the return type is correct when <code>applyrule</code> or <code>applyrule!</code> is run.</p><p>Type-stability can give orders of magnitude improvements in performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/utils.jl#L17">source</a></section></article><h3 id="Data-objects-and-methods-for-use-in-applyrule"><a class="docs-heading-anchor" href="#Data-objects-and-methods-for-use-in-applyrule">Data objects and methods for use in <code>applyrule</code></a><a id="Data-objects-and-methods-for-use-in-applyrule-1"></a><a class="docs-heading-anchor-permalink" href="#Data-objects-and-methods-for-use-in-applyrule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SimData" href="#DynamicGrids.SimData"><code>DynamicGrids.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimData(extent::AbstractExtent, ruleset::AbstractRuleset)</code></pre><p>Simulation dataset to hold all intermediate arrays, timesteps and frame numbers for the current frame of the simulation.</p><p>A simdata object is accessable in <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> as the first parameter.</p><p>Multiple grids can be indexed into using their key if you need to read from arbitrary locations:</p><pre><code class="language-julia">funciton applyrule(data::SimData, rule::SomeRule{Tuple{A,B}},W}, (a, b), cellindex) where {A,B,W}
    grid_a = data[A]
    grid_b = data[B]
    ...</code></pre><p>In single grid simulations <code>SimData</code> can be indexed directly as if it is a <code>Matrix</code>.</p><p><strong>Methods</strong></p><ul><li><code>currentframe(data::SimData)</code>: get the current frame number, an <code>Int</code></li><li><code>currenttime(data::SimData)</code>: the current frame time, which <code>isa eltype(tspan)</code></li><li><code>aux(d::SimData, args...)</code>: get the <code>aux</code> data <code>NamedTuple</code>, or <code>Nothing</code>. adding a <code>Symbol</code> or <code>Val{:symbol}</code> argument will get a field of aux.</li><li><code>tspan(d::SimData)</code>: get the simulation time span, an <code>AbstractRange</code>.</li><li><code>timestep(d::SimData)</code>: get the simulaiton time step.</li><li><code>radius(data::SimData)</code> : returns the <code>Int</code> radius used on the grid, which is also the amount of border padding.</li><li><code>boundary(data::SimData)</code> : returns the <a href="#DynamicGrids.Boundary"><code>Boundary</code></a> - <code>Remove</code> or <code>Wrap</code>.</li><li><code>padval(data::SimData)</code> : returns the value to use as grid border padding.</li></ul><p>These are available, but you probably shouldn&#39;t use them and thier behaviour is not guaranteed in furture versions. They will mean rule is useful only in specific contexts.</p><ul><li><code>extent(d::SimData)</code> : get the simulation <a href="@ref"><code>AbstractExtent</code></a> object.</li><li><code>init(data::SimData)</code> : get the simulation init <code>AbstractArray</code>/<code>NamedTuple</code></li><li><code>mask(data::SimData)</code> : get the simulation mask <code>AbstractArray</code></li><li><code>ruleset(d::SimData)</code> : get the simulation <a href="@ref"><code>AbstractRuleset</code></a>.</li><li><code>source(data::SimData)</code> : get the <code>source</code> grid that is being read from.</li><li><code>dest(data::SimData)</code> : get the <code>dest</code> grid that is being written to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/simulationdata.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.init" href="#DynamicGrids.init"><code>DynamicGrids.init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init(obj) =&gt; Union{AbstractArray,NamedTUple}</code></pre><p>Retrieve the mask from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.aux" href="#DynamicGrids.aux"><code>DynamicGrids.aux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aux(obj, [key])</code></pre><p>Retrieve auxilary data <code>NamedTuple</code> from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p><p>Given <code>key</code> specific data will be returned. <code>key</code> should be a <code>Val{:symbol}</code> for type stability and zero-cost access inside rules. <code>Symbol</code> will also work, but may be slow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.mask" href="#DynamicGrids.mask"><code>DynamicGrids.mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mask(obj) =&gt; AbstractArray</code></pre><p>Retrieve the mask from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.tspan" href="#DynamicGrids.tspan"><code>DynamicGrids.tspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tspan(obj) =&gt; AbstractRange</code></pre><p>Retrieve the time-span <code>AbstractRange</code> from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.timestep" href="#DynamicGrids.timestep"><code>DynamicGrids.timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timestep(obj)</code></pre><p>Retrieve the timestep size from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a>, <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> or <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p><p>This will be in whatever type/units you specify in <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currenttimestep" href="#DynamicGrids.currenttimestep"><code>DynamicGrids.currenttimestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">currenttimestep(simdata::SimData)</code></pre><p>Retrieve the current timestep from a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p><p>This may be different from the <code>timestep</code>. If the timestep is <code>Month</code>, <code>currenttimestep</code> will return <code>Seconds</code> for the length of the specific month.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currenttime" href="#DynamicGrids.currenttime"><code>DynamicGrids.currenttime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">currenttime(simdata::SimData)</code></pre><p>Retrieve the current simulation time from a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p><p>This will be in whatever type/units you specify in <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currentframe" href="#DynamicGrids.currentframe"><code>DynamicGrids.currentframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">currentframe(simdata::SimData) =&gt; Int</code></pre><p>Retrieve the current simulation frame a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L224">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.frameindex</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.inbounds" href="#DynamicGrids.inbounds"><code>DynamicGrids.inbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inbounds(I::Tuple, data::SimData) =&gt; Tuple{NTuple{2,Int},Bool}</code></pre><p>Check grid boundaries for a coordinate before writing in <a href="@ref">``</a>.</p><p>Returns a <code>Tuple</code> containing a coordinates <code>Tuple</code> and a <code>Bool</code> - <code>true</code> if the cell is in bounds, <code>false</code> if not.</p><p>Boundary of type <a href="#DynamicGrids.Remove"><code>Remove</code></a> returns the coordinate and <code>false</code> to skip coordinates that boundary outside of the grid.</p><p><a href="#DynamicGrids.Wrap"><code>Wrap</code></a> returns a tuple with the current position or it&#39;s wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isinbounds" href="#DynamicGrids.isinbounds"><code>DynamicGrids.isinbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isinbounds(I::Tuple, data)</code></pre><p>Check that a coordinate is within the grid, usually in <a href="@ref">``</a>.</p><p>Unlike <a href="#DynamicGrids.inbounds"><code>inbounds</code></a>, <a href="#DynamicGrids.Boundary"><code>Boundary</code></a> status is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L164">source</a></section></article><h2 id="Neighborhoods"><a class="docs-heading-anchor" href="#Neighborhoods">Neighborhoods</a><a id="Neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods" title="Permalink"></a></h2><p>Neighborhoods define a pattern of cells surrounding the current cell, and how they are combined to update the value of the current cell.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhood" href="#DynamicGrids.Neighborhood"><code>DynamicGrids.Neighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Neighborhoods define the pattern of surrounding cells in the &quot;neighborhood&quot; of the current cell. The <code>neighbors</code> function returns the surrounding cells as an iterable.</p><p>The main kinds of neighborhood are demonstrated below:</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/Neighborhoods.png" alt="Neighborhoods"/></p><pre><code class="language-julia">Moore{3}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RadialNeighborhood" href="#DynamicGrids.RadialNeighborhood"><code>DynamicGrids.RadialNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Moore-style square neighborhoods</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractKernel" href="#DynamicGrids.AbstractKernel"><code>DynamicGrids.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for kernel neighborhoods.</p><p>These can wrap any other neighborhood object, and include a kernel of  the same length and positions as the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Kernel" href="#DynamicGrids.Kernel"><code>DynamicGrids.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Kernel(neighborhood, kernel)</code></pre><p>Wrap any other neighborhood object, and includes a kernel of  the same length and positions as the neighborhood.</p><p><code>R = 1</code> gives 3x3 matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Moore" href="#DynamicGrids.Moore"><code>DynamicGrids.Moore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Moore(radius::Int=1)</code></pre><p>Moore neighborhoods define the neighborhood as all cells within a horizontal or vertical distance of the central cell. The central cell is omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.VonNeumann" href="#DynamicGrids.VonNeumann"><code>DynamicGrids.VonNeumann</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">VonNeumann(radius=1)</code></pre><p>A convenience wrapper to build Von-Neumann neighborhoods as a <a href="#DynamicGrids.Positional"><code>Positional</code></a> neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractPositional" href="#DynamicGrids.AbstractPositional"><code>DynamicGrids.AbstractPositional</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Neighborhoods are tuples or vectors of custom coordinates tuples that are specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Positional" href="#DynamicGrids.Positional"><code>DynamicGrids.Positional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Positional(coord::Tuple{Vararg{Int}}...)
Positional(offsets::Tuple{Tuple{Vararg{Int}}})</code></pre><p>Neighborhoods that can take arbitrary shapes by specifying each coordinate, as <code>Tuple{Int,Int}</code> of the row/column distance (positive and negative) from the central point.</p><p>The neighborhood radius is calculated from the most distance coordinate. For simplicity the buffer read from the main grid is a square with sides <code>2r + 1</code> around the central point, and is not shrunk or offset to match the coordinates if they are not symmetrical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayeredPositional" href="#DynamicGrids.LayeredPositional"><code>DynamicGrids.LayeredPositional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayeredPositional(layers::Positional...)</code></pre><p>Sets of <a href="#DynamicGrids.Positional"><code>Positional</code></a> neighborhoods that can have separate rules for each set.</p><p><code>neighbors</code> for <code>LayeredPositional</code> returns a tuple of iterators for each neighborhood layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/neighborhoods.jl#L205">source</a></section></article><h3 id="Methods-for-use-with-neighborhood-rules-and-neighborhoods"><a class="docs-heading-anchor" href="#Methods-for-use-with-neighborhood-rules-and-neighborhoods">Methods for use with neighborhood rules and neighborhoods</a><a id="Methods-for-use-with-neighborhood-rules-and-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-use-with-neighborhood-rules-and-neighborhoods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.radius" href="#DynamicGrids.radius"><code>DynamicGrids.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(rule, [key]) =&gt; Int</code></pre><p>Return the radius of a rule or ruleset if it has one, otherwise zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.neighbors" href="#DynamicGrids.neighbors"><code>DynamicGrids.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighbors(x::Union{Neighborhood,NeighborhoodRule}}) =&gt; iterable</code></pre><p>Returns an iteraterable generator over all cells in the neighborhood.</p><p>Custom <code>Neighborhood</code>s must define this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.positions" href="#DynamicGrids.positions"><code>DynamicGrids.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">positions(x::Union{Neighborhood,NeighborhoodRule}}, cellindex::Tuple) =&gt; iterable</code></pre><p>Returns an iteraterable over all cells as a <code>Tuple</code> of the index  in the main array. Useful in <a href="#DynamicGrids.SetNeighborhoodRule"><code>SetNeighborhoodRule</code></a> for  setting neighborhood values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.offsets" href="#DynamicGrids.offsets"><code>DynamicGrids.offsets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">offsets(x::Union{Neighborhood,NeighborhoodRule}}) =&gt; iterable</code></pre><p>Returns an iteraterable over all cells as a <code>Tuple</code> of the index  offset from the central cell.</p><p>Custom <code>Neighborhood</code>s must define this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L65">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.sumneighbors</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Manual-Rules"><a class="docs-heading-anchor" href="#Manual-Rules">Manual Rules</a><a id="Manual-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.add!" href="#DynamicGrids.add!"><code>DynamicGrids.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add!(data::WritableGridData, x, I...)</code></pre><p>Add the value <code>x</code> to a grid cell.</p><p><strong>Example useage</strong></p><pre><code class="language-julia">function applyrule!(data::SimData, rule::My{A,B}, state, cellindex) where {A,B}

    dest, is_inbounds = inbounds(jump .+ cellindex, gridsize(data))

    # Update spotted cell if it&#39;s on the grid
    is_inbounds &amp;&amp; add!(data[W], state, dest...)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sub!" href="#DynamicGrids.sub!"><code>DynamicGrids.sub!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sub!(data::WritableGridData, x, I...)</code></pre><p>Subtract the value <code>x</code> from a grid cell. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.and!" href="#DynamicGrids.and!"><code>DynamicGrids.and!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">and!(data::WritableGridData, x, I...)
and!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>c &amp; x</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.or!" href="#DynamicGrids.or!"><code>DynamicGrids.or!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">or!(data::WritableGridData, x, I...)
or!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>c | x</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.xor!" href="#DynamicGrids.xor!"><code>DynamicGrids.xor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xor!(data::WritableGridData, x, I...)
xor!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>xor(c, x)</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/interface.jl#L140">source</a></section></article><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><h3 id="Output-Types-and-Constructors"><a class="docs-heading-anchor" href="#Output-Types-and-Constructors">Output Types and Constructors</a><a id="Output-Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Output-Types-and-Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Output" href="#DynamicGrids.Output"><code>DynamicGrids.Output</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Outputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherwise manipulate the simulation grids to improve performance, reduce memory overheads or similar.</p><p>Simulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/output.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ArrayOutput" href="#DynamicGrids.ArrayOutput"><code>DynamicGrids.ArrayOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArrayOutput(init; tspan::AbstractRange, [aux, mask, padval])</code></pre><p>A simple output that stores each step of the simulation in a vector of arrays.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code> or <code>NamedTuple</code> of <code>Array</code></li></ul><p><strong>Keyword Argument:</strong></p><ul><li><code>tspan</code>: <code>AbstractRange</code> timespan for the simulation</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>get(data, Aux(:key), I...)</code>  to access from a <code>Rule</code> in a type-stable way.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/array.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ResultOutput" href="#DynamicGrids.ResultOutput"><code>DynamicGrids.ResultOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultOutput(init; tspan::AbstractRange, [aux, mask, padval])</code></pre><p>A simple output that only stores the final result, not intermediate frames.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code> or <code>NamedTuple</code> of <code>Array</code></li></ul><p><strong>Keyword Argument:</strong></p><ul><li><code>tspan</code>: <code>AbstractRange</code> timespan for the simulation</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>get(data, Aux(:key), I...)</code>  to access from a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/array.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicOutput" href="#DynamicGrids.GraphicOutput"><code>DynamicGrids.GraphicOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Outputs that display the simulation frames live.</p><p>All <code>GraphicOutputs</code> have a <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> object and provide a <a href="@ref"><code>showframe</code></a> method.</p><p><strong>Interface Methods</strong></p><ul><li><code>extent(output) =&gt; Extent</code></li><li><code>graphicconfig(output) =&gt; GraphicConfig</code></li><li><code>isasync(output) =&gt; Bool</code>: does the output need to run asynchronously,  in a separate thread.</li><li><code>showframe(grid::Union{Array,NamedTuple}, o::ThisOutput, data)</code> : in which the output generally show the frame graphically in some way.</li></ul><p>See <a href="#DynamicGrids.REPLOutput"><code>REPLOutput</code></a> for an example.</p><p><strong>Constructor Keyword Arguments:</strong></p><p>The default constructor will generate these objects from keyword arguments and pass  them to the object constructor, which must accept the following</p><ul><li><code>frames</code>: a Vector of simulation frames (<code>NamedTuple</code> or <code>Array</code>). </li><li><code>running</code>: A Bool.</li><li><code>extent</code> an <a href="#DynamicGrids.Extent"><code>Extent</code></a> object.</li><li><code>graphicconfig</code> a <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a>object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/graphic.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.REPLOutput" href="#DynamicGrids.REPLOutput"><code>DynamicGrids.REPLOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">REPLOutput(init; tspan, aux=nothing, mask=nothing, padval=zero(eltype(init)), 
    fps=25.0, store=false, color=:white, cutoff=0.5, style=Block())</code></pre><p>An output that is displayed directly in the REPL. It can either store or discard simulation frames.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation Array or NamedTuple of arrays.</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>tspan</code>: <code>AbstractRange</code> timespan for the simulation</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: <code>NamedTuple</code> of arbitrary input data. Use <code>get(data, Aux(:key), I...)</code>  to access from a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li><li><code>fps</code>: <code>Real</code> frames per second to display the simulation</li><li><code>store</code>: <code>Bool</code> whether ot store the simulation frames for later use</li><li><code>color</code>: a color from Crayons.jl</li><li><code>cutoff</code>: <code>Real</code> cutoff point to display a full or empty cell. Default is <code>0.5</code></li><li><code>style</code>: <code>CharStyle</code> <code>Block()</code> or <code>Braile()</code> printing. <code>Braile</code> uses 1/4 the screen space of <code>Block</code>.</li></ul><pre><code class="language-julia">REPLOutput(init)</code></pre><p>The default option is <code>:block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/repl.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageOutput" href="#DynamicGrids.ImageOutput"><code>DynamicGrids.ImageOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Graphic outputs that display the simulation frames as RGB images.</p><p><code>ImageOutput</code>s must have a <a href="#DynamicGrids.Extent"><code>Extent</code></a>, <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a>  and <a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> component, and define a <a href="#DynamicGrids.showimage"><code>showimage</code></a> method.</p><p>See <a href="#DynamicGrids.GifOutput"><code>GifOutput</code></a> for an example.</p><p>Although the majority of the code is maintained here to enable sharing and reuse, most <code>ImageOutput</code>s are not provided in DynamicGrids.jl to avoid heavy dependencies on graphics libraries. See <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> and <a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> for implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/image.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GifOutput" href="#DynamicGrids.GifOutput"><code>DynamicGrids.GifOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GifOutput(init; filename, tspan::AbstractRange, 
    aux=nothing, mask=nothing, padval=zero(eltype(init)),
    fps=25.0, store=false, 
    font=autofont(),
    scheme=Greyscale()
    text=TextConfig(; font=font),
    processor=autoprocessor(init, text)
    minval=nothing, maxval=nothing
)</code></pre><p>Output that stores the simulation as images and saves a Gif file on completion.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code> or <code>NamedTuple</code> of <code>Array</code></li></ul><p><strong>Keyword Argument:</strong></p><ul><li><code>tspan</code>: <code>AbstractRange</code> timespan for the simulation</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>get(data, Aux(:key), I...)</code>  to access from a <code>Rule</code> in a type-stable way.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li><li><code>font</code>: <code>String</code> font name</li><li><code>scheme</code>: ColorSchemes.jl scheme, or <code>Greyscale()</code></li><li><code>text</code>: <a href="#DynamicGrids.TextConfig"><code>TextConfig</code></a> object or <code>nothing</code>.</li><li><code>processor</code>: <a href="#DynamicGrids.GridProcessor"><code>GridProcessor</code></a></li><li><code>minval</code>: minimum value(s) to set colour maximum</li><li><code>maxval</code>: maximum values(s) to set colour minimum</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/gif.jl#L31">source</a></section></article><h3 id="Output-methods"><a class="docs-heading-anchor" href="#Output-methods">Output methods</a><a id="Output-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Output-methods" title="Permalink"></a></h3><h3 id="Grid-processors"><a class="docs-heading-anchor" href="#Grid-processors">Grid processors</a><a id="Grid-processors-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-processors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GridProcessor" href="#DynamicGrids.GridProcessor"><code>DynamicGrids.GridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type GridProcessor</code></pre><p>Grid processors convert a frame of the simulation into an <code>RGB</code> image for display. Frames may be one or multiple grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SingleGridProcessor" href="#DynamicGrids.SingleGridProcessor"><code>DynamicGrids.SingleGridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type SingleGridProcessor &lt;: GridProcessor</code></pre><p>Grid processors that convert one grid into an image array.</p><p>The first grid will be displayed if a <code>SingleGridProcessor</code> is used with a <code>NamedTuple</code> of grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SparseOptInspector" href="#DynamicGrids.SparseOptInspector"><code>DynamicGrids.SparseOptInspector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SparseOptInspector &lt;: SingleGridProcessor</code></pre><pre><code class="language-none">SparseOptInspector()</code></pre><p>A <a href="#DynamicGrids.GridProcessor"><code>GridProcessor</code></a> that checks <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> visually. Cells that do not run show in gray. Errors show in red, but if they do there&#39;s a bug.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ColorProcessor" href="#DynamicGrids.ColorProcessor"><code>DynamicGrids.ColorProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ColorProcessor(; scheme=Greyscale(), zerocolor=nothing, maskcolor=nothing)</code></pre><p>Converts output grids to a colorsheme.</p><p><strong>Arguments / Keyword Arguments</strong></p><ul><li><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.Greyscale"><code>Greyscale</code></a> or object that defines <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code> using <code>ARGB32(val)</code>.</li><li><code>zerocolor</code>: a <code>Color</code> to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</li><li><code>textconfig</code>: a <a href="#DynamicGrids.TextConfig"><code>TextConfig</code></a> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.MultiGridProcessor" href="#DynamicGrids.MultiGridProcessor"><code>DynamicGrids.MultiGridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type MultiGridProcessor &lt;: GridProcessor</code></pre><p>Processors that convert a frame containing multiple grids into a single image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L163">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ThreeColorProcessor</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayoutProcessor" href="#DynamicGrids.LayoutProcessor"><code>DynamicGrids.LayoutProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayoutProcessor(layout::Array, processors::Matrix, textconfig::TextConfig)</code></pre><p>LayoutProcessor allows displaying multiple grids in a block layout, by specifying a layout matrix and a list of <a href="#DynamicGrids.SingleGridProcessor"><code>SingleGridProcessor</code></a> to be run for each.</p><p><strong>Arguments</strong></p><ul><li><code>layout</code>: A Vector or Matrix containing the keys or numbers of grids in the locations to display them. <code>nothing</code>, <code>missing</code> or <code>0</code> values will be skipped.</li><li><code>processors</code>: tuple of SingleGridProcessor, one for each grid in the simulation. Can be <code>nothing</code> or any other value for grids not in layout.</li><li><code>textconfig</code> : [<code>TextConfig</code>] object for printing time and grid name labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Greyscale" href="#DynamicGrids.Greyscale"><code>DynamicGrids.Greyscale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Greyscale(min=nothing, max=nothing)</code></pre><p>Default colorscheme. Better performance than using a Colorschemes.jl scheme as there is array access or interpolation.</p><p><code>min</code> and <code>max</code> are values between <code>0.0</code> and <code>1.0</code> that define the range of greys used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Grayscale" href="#DynamicGrids.Grayscale"><code>DynamicGrids.Grayscale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Grayscale(min=nothing, max=nothing)</code></pre><p>Alternate name for <a href="#DynamicGrids.Greyscale"><code>Greyscale()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.TextConfig" href="#DynamicGrids.TextConfig"><code>DynamicGrids.TextConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TextConfig(; 
    font::String=autofont(), 
    namepixels=14, 
    timepixels=14,
    namepos=(timepixels+namepixels, timepixels),
    timepos=(timepixels, timepixels),
    fcolor=ARGB32(1.0), 
    bcolor=ARGB32(0.3)
)
TextConfig(face, namepixels, namepos, timepixels, timepos, fcolor, bcolor)</code></pre><p>Text configuration for printing timestep and grid name on the image.</p><p><strong>Arguments</strong></p><ul><li><code>namepixels</code> and <code>timepixels</code>: set the pixel size of the font.</li><li><code>timepos</code> and <code>namepos</code>: tuples that set the label positions, in pixels.</li><li><code>fcolor</code> and <code>bcolor</code>: the foreground and background colors, as <code>ARGB32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/textconfig.jl#L1">source</a></section></article><h3 id="Gifs"><a class="docs-heading-anchor" href="#Gifs">Gifs</a><a id="Gifs-1"></a><a class="docs-heading-anchor-permalink" href="#Gifs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><p>savegif(filename::String, o::Output, data; processor=processor(o), fps=fps(o), [kwargs...])</p><p>Write the output array to a gif. You must pass a processor keyword argument for any <code>Output</code> objects not in <code>ImageOutput</code> (which allready have a processor attached).</p><p>Saving very large gifs may trigger a bug in Imagemagick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/gif.jl#L1">source</a></section></article><h3 id="Internal-components-and-methods-for-outputs"><a class="docs-heading-anchor" href="#Internal-components-and-methods-for-outputs">Internal components and methods for outputs</a><a id="Internal-components-and-methods-for-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-components-and-methods-for-outputs" title="Permalink"></a></h3><p>These are used for defining your own outputs and <code>GridProcessors</code>,  not for general scripting.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Extent" href="#DynamicGrids.Extent"><code>DynamicGrids.Extent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Extent(init::Union{AbstractArray,NamedTuple}, 
       mask::Union{AbstractArray,Nothing}, 
       aux::Union{NamedTuple,Nothing}, 
       tspan::AbstractRange)
Extent(; init, mask=nothing, aux=nothing, tspan, kwargs...)</code></pre><p>Container for extensive variables: spatial and timeseries data. These are kept separate from rules to allow application of rules to alternate spatial and temporal contexts.</p><p>Extent is not usually constructed directly by users, but it can be passed to <code>Output</code> constructors instead of <code>init</code>, <code>mask</code>, <code>aux</code> and <code>tspan</code>.</p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from  a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>precalc</code> methods</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/extent.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicConfig" href="#DynamicGrids.GraphicConfig"><code>DynamicGrids.GraphicConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphicConfig(; fps=25.0, store=false, kwargs...) =
GraphicConfig(fps, timestamp, stampframe, store)</code></pre><p>Config and variables for graphic outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/graphic.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageConfig" href="#DynamicGrids.ImageConfig"><code>DynamicGrids.ImageConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImageConfig(processor, minval, maxval) 
ImageConfig(; 
    init=nothing, 
    font=autofont(), 
    scheme=Greyscale(), 
    text=TextConfig(; font=font)
    processor=autoprocessor(init),
    minval=nothing, 
    maxval=nothing
)</code></pre><p>Common configuration component for all <a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a>.</p><p><code>processor</code> is any <a href="#DynamicGrids.GridProcessor"><code>GridProcessor</code></a>.  <code>minval</code> and <code>maxval</code> fields normalise grid values between zero and one, for use  with Colorshemes.jl. <code>nothing</code> values are considered to represent zero or one  respectively for <code>minval</code> and <code>maxval</code>, and will not be normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/image.jl#L1">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.storeframe!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.showframe</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.showimage" href="#DynamicGrids.showimage"><code>DynamicGrids.showimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showimage(image::AbstractArray{AGRB32,2}, output::ImageOutput)</code></pre><p>Show image generated by and <code>GridProcessor</code> in an ImageOutput.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: An array of <code>Color</code></li><li><code>output</code>: the output to define the method for</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/image.jl#L118">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.isasync</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.isshowable</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.isstored</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.initialise</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.delay</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.finalise</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.grid2image</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.rendertext!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.rendertime!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.rendername!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.normalise" href="#DynamicGrids.normalise"><code>DynamicGrids.normalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise(x, min, max)</code></pre><p>Set a value to be between zero and one, before converting to Color. min and max of <code>nothing</code> are assumed to be 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.rgb" href="#DynamicGrids.rgb"><code>DynamicGrids.rgb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rgb(val)</code></pre><p>Convert a number, tuple or color to an ARGB32 value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L298">source</a></section><section><div><pre><code class="language-none">rgb(scheme, val)</code></pre><p>Convert a color scheme and value to an RGB value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/outputs/processors.jl#L309">source</a></section></article><h2 id="Ruleset-config"><a class="docs-heading-anchor" href="#Ruleset-config">Ruleset config</a><a id="Ruleset-config-1"></a><a class="docs-heading-anchor-permalink" href="#Ruleset-config" title="Permalink"></a></h2><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Boundary" href="#DynamicGrids.Boundary"><code>DynamicGrids.Boundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Boundary</code></pre><p>Singleton types for choosing the grid boundary rule used in <a href="#DynamicGrids.inbounds"><code>inbounds</code></a> and <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> buffers. These determine what is done when a neighborhood or jump extends outside of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Wrap" href="#DynamicGrids.Wrap"><code>DynamicGrids.Wrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Wrap &lt;: Boundary</code></pre><pre><code class="language-none">Wrap()</code></pre><p>Wrap cordinates that boundary boundaries back to the opposite side of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Remove" href="#DynamicGrids.Remove"><code>DynamicGrids.Remove</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Remove &lt;: Boundary</code></pre><pre><code class="language-none">Remove()</code></pre><p>Remove coordinates that boundary grid boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L70">source</a></section></article><h3 id="Optimisation"><a class="docs-heading-anchor" href="#Optimisation">Optimisation</a><a id="Optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#Optimisation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PerformanceOpt" href="#DynamicGrids.PerformanceOpt"><code>DynamicGrids.PerformanceOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PerformanceOpt</code></pre><p>Performance optimisations to use in the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NoOpt" href="#DynamicGrids.NoOpt"><code>DynamicGrids.NoOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NoOpt &lt;: PerformanceOpt</code></pre><pre><code class="language-none">NoOpt()</code></pre><p>Run the simulation without performance optimisations besides basic high performance programming.</p><p>This is still very fast, but not intelligent about the work that it does.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SparseOpt" href="#DynamicGrids.SparseOpt"><code>DynamicGrids.SparseOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseOpt()</code></pre><p>An optimisation that ignores all zero values in the grid.</p><p>For low-density simulations performance may improve by orders of magnitude, as only used cells are run.</p><p>This is complicated for optimising neighborhoods - they must run if they contain just one non-zero cell.</p><p>This is best demonstrated with this simulation, where the grey areas do not run except where the neighborhood partially hangs over an area that is not grey.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/complexlife_spareseopt.gif" alt="SparseOpt demonstration"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/flags.jl#L6">source</a></section></article><h2 id="Internal-data-handling"><a class="docs-heading-anchor" href="#Internal-data-handling">Internal data handling</a><a id="Internal-data-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-data-handling" title="Permalink"></a></h2><p><a href="#DynamicGrids.SimData"><code>SimData</code></a> and <a href="#DynamicGrids.GridData"><code>GridData</code></a> objects are used to  manage the simulation and provide rules with any data they need.</p><p>These methods and objects are all subject to change until version 1.0.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GridData" href="#DynamicGrids.GridData"><code>DynamicGrids.GridData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simulation data specific to a single grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/grid.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ReadableGridData" href="#DynamicGrids.ReadableGridData"><code>DynamicGrids.ReadableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReadableGridData(grid::GridData)
ReadableGridData{Y,X,R}(init::AbstractArray, mask, opt, boundary, padval)</code></pre><p>Simulation data and storage passed to rules for each timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/grid.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.WritableGridData" href="#DynamicGrids.WritableGridData"><code>DynamicGrids.WritableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WritableGridData(grid::GridData)</code></pre><p>Passed to rules <code>&lt;:</code>, and can be written to directly as an array. This handles updates to SparseOpt() and writing to the correct source/dest array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/grid.jl#L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.runsim!" href="#DynamicGrids.runsim!"><code>DynamicGrids.runsim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">runsim!(output::Output, args...)</code></pre><p>Simulation runner. Runs a simulation synchonously or asynchonously depending on the return value of <code>isasync(output)</code> - which may be a fixed trait or a field value depending on the output type.</p><p>This allows interfaces with interactive components to update during the simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/framework.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.simloop!" href="#DynamicGrids.simloop!"><code>DynamicGrids.simloop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simloop!(output::Output, simdata, ruleset, fspan::UnitRange)</code></pre><p>Loop over the frames in <code>fspan</code>, running the ruleset and displaying the output.</p><p>Operations on outputs and rulesets are allways mutable and in-place.</p><p>Operations on <a href="#DynamicGrids.Rule"><code>Rule</code></a>s and <a href="#DynamicGrids.SimData"><code>SimData</code></a> objects are in a functional style, as they are used in inner loops where immutability improves performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/framework.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sequencerules!" href="#DynamicGrids.sequencerules!"><code>DynamicGrids.sequencerules!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sequencerules!(simdata::AbstractSimData)</code></pre><p>Sequence rules over the <a href="#DynamicGrids.SimData"><code>SimData</code></a> object, calling <a href="#DynamicGrids.maprule!"><code>maprule!</code></a> for each individual <code>Rule</code>.</p><p>If a Vector of <code>SimData</code> is used replicates will be run with <code>Threads.@threads</code>.</p><p>TODO: use the new threading method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/sequencerules.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.maprule!" href="#DynamicGrids.maprule!"><code>DynamicGrids.maprule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maprule!(simdata::SimData, rule::Rule)</code></pre><p>Map a rule over the grids it reads from and updating the grids it writes to.</p><p>This is broken into a setup method and an application method to introduce a function barrier, for type stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/maprules.jl#L4">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.optmap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.readgrids</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.writegrids</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ismasked" href="#DynamicGrids.ismasked"><code>DynamicGrids.ismasked</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ismasked(data, I...)</code></pre><p>Check if a cell is masked, using the <code>mask</code> array.</p><p>Used used internally during simulations to skip masked cells.</p><p>If <code>mask</code> was not passed to the <code>Output</code> constructor or <code>sim!</code> it defaults to <code>nothing</code> and <code>false</code> is always returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/dfab07bd83f7bdb73f32695acdd7fb3426b006b7/src/utils.jl#L2">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.getreadgrids</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.combinegrids</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.replacegrids</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.filter_readstate</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.filter_writestate</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DynamicGrids.update_chainstate</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 22 January 2021 04:47">Friday 22 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
