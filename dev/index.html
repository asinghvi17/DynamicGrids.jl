<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicGrids · DynamicGrids.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DynamicGrids.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicGrids</a><ul class="internal"><li><a class="tocitem" href="#Running-simulations"><span>Running simulations</span></a></li><li><a class="tocitem" href="#Rulesets"><span>Rulesets</span></a></li><li><a class="tocitem" href="#Options/Flags"><span>Options/Flags</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Neighborhoods"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule"><span>Atomic methods for SetCellRule and SetNeighborhoodRule</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Custom-grid-element-types"><span>Custom grid element types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicGrids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicGrids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicGrids"><a class="docs-heading-anchor" href="#DynamicGrids">DynamicGrids</a><a id="DynamicGrids-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicGrids" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids" href="#DynamicGrids"><code>DynamicGrids</code></a> — <span class="docstring-category">Module</span></header><section><div><p><img src="https://repository-images.githubusercontent.com/136250713/956b0c00-5cc7-11eb-9814-eed48441d013" alt="DynamicGrids"/></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://cesaraustralia.github.io/DynamicGrids.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://github.com/cesaraustralia/DynamicGrids.jl/actions/workflows/ci.yml"><img src="https://github.com/cesaraustralia/DynamicGrids.jl/actions/workflows/ci.yml/badge.svg" alt="CI"/></a> <a href="http://codecov.io/github/cesaraustralia/DynamicGrids.jl?branch=master"><img src="http://codecov.io/github/cesaraustralia/DynamicGrids.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DynamicGrids is a generalised framework for building high-performance grid-based spatial simulations, including cellular automata, but also allowing a wider range of behaviours like random jumps and interactions between multiple grids. It is extended by <a href="https://github.com/cesaraustralia/Dispersal.jl">Dispersal.jl</a> for modelling organism dispersal processes.</p><p><a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> provides a simple live  interface, while <a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a>  also has live control over model parameters while the simulation runs: real-time visual feedback for manual parametrisation and model exploration.</p><p>DynamicGrids can run rules on single CPUs, threaded CPUs, and on CUDA GPUs.  Simulation run-time is usually measured in fractions of a second.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif" alt="Dispersal quarantine"/></p><p><em>A dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk</a>.  Note that this is indicative of the real-time frame-rate on a laptop.</em></p><p>A DynamicGrids.jl simulation is run with a script like this one running the included game of life model <code>Life()</code>:</p><pre><code class="language-julia hljs">using DynamicGrids, Crayons

init = rand(Bool, 150, 200)
output = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))
sim!(output, Life())

# Or define it from scratch (yes this is actually the whole implementation!)
life = Neighbors(Moore(1)) do data, hood, state, I
    born_survive = (false, false, false, true, false, false, false, false, false), 
                   (false, false, true, true,  false, false, false, false, false)
    born_survive[state + 1][sum(hood) + 1]
end
sim!(output, life)</code></pre><p><img src="https://github.com/cesaraustralia/DynamicGrids.jl/blob/media/life.gif?raw=true" alt="REPL life"/></p><p><em>A game of life simulation being displayed directly in a terminal.</em></p><p><strong>Concepts</strong></p><p>The framework is highly customisable, but there are some central ideas that define how a simulation works: <em>grids</em>, <em>rules</em>, and <em>outputs</em>.</p><p><strong>Grids</strong></p><p>Simulations run over one or many grids, derived from <code>init</code> of a single <code>AbstractArray</code> or a <code>NamedTuple</code> of multiple <code>AbstractArray</code>. Grids (<code>GridData</code> types) are, however not a single array but both source and destination arrays, to maintain independence between cell reads and writes where required. These may be padded or otherwise altered for specific performance optimisations. However, broadcasted <code>getindex</code> operations are guaranteed to work on them as if the grid is a regular array. This may be useful running simulations manually with <code>step!</code>.</p><p><strong>Grid contents</strong></p><p>Often grids contain simple values of some kind of <code>Number</code>, but other types are possible, such as <code>SArray</code>, <code>FieldVector</code> or other custom structs. Grids are updated by <code>Rule</code>s that are run for every cell, at every timestep. </p><p>NOTE: Grids of mutable objects (e.g <code>Array</code> or any <code>mutable struct</code> have undefined behaviour. DynamicGrids.jl does not <code>deepcopy</code> grids between frames as it is expensive, so successive frames will contain the same objects. Mutable objects will not work at all on GPUs, and are relatively slow on CPUs. Instead, use regular immutable structs and <code>StaticArrays.jl</code> if you need arrays. Update them using <code>@set</code> from Setfield.jl or Accessors.jl, and generally use functional programming approaches over object-oriented ones.</p><p><strong>Init</strong></p><p>The <code>init</code> grid/s contain whatever initialisation data is required to start a simulation: the array type, size and element type, as well as providing the initial conditions:</p><pre><code class="language-julia hljs">init = rand(Float32, 100, 100)</code></pre><p>An <code>init</code> grid can be attached to an <code>Output</code>: </p><pre><code class="language-julia hljs">output = ArrayOutput(init; tspan=1:100)</code></pre><p>or passed in to <code>sim!</code>, where it will take preference over the <code>init</code> attached to the <code>Output</code>, but must be the same type and size:</p><pre><code class="language-julia hljs">sim!(output, ruleset; init=init)</code></pre><p>For multiple grids, <code>init</code> is a <code>NamedTuple</code> of equal-sized arrays matching the names used in each <code>Ruleset</code> :</p><pre><code class="language-julia hljs">init = (predator=rand(100, 100), prey=(rand(100, 100))</code></pre><p>Handling and passing of the correct grids to a <code>Rule</code> is automated by DynamicGrids.jl, as a no-cost abstraction. <code>Rule</code>s specify which grids they require in what order using the first two (<code>R</code> and <code>W</code>) type parameters.</p><p>Dimensional or spatial <code>init</code> grids from <a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> or <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a> will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, to which shape files and observation points can be easily added.</p><p><strong>Non-Number Grids</strong></p><p>Grids containing custom and non-<code>Number</code> types are possible, with some caveats. They must define <code>Base.zero</code> for their element type, and should be a bitstype for performance.  Tuple does not define <code>zero</code>. <code>Array</code> is not a bitstype, and does not define <code>zero</code>.  <code>SArray</code> from StaticArrays.jl is both, and can be used as the contents of a grid.  Custom structs that defne <code>zero</code> should also work. </p><p>However, for any multi-values grid element type, you will need to define a method of  <code>DynamicGrids.to_rgb</code> that returns an <code>ARGB32</code> for them to work in <code>ImageOutput</code>s, and  <code>isless</code> for the <code>REPLoutput</code> to work. A definition for multiplication by a scalar <code>Real</code>  and addition are required to use <code>Convolution</code> kernels.</p><p><strong>Rules</strong></p><p>Rules hold the parameters for running a simulation, and are applied in <code>applyrule</code> method that is called for each of the active cells in the grid. Rules come in a number of flavours (outlined in the <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Rules-1">docs</a>). This allows using specialised methods for different types of rules, ecoding assumtions  about their behaviours that can greatly improve performance through more efficient  use of caches and parallelisation. Rules can be collected in a <code>Ruleset</code>, with some  additional arguments to control the simulation:</p><pre><code class="language-julia hljs">ruleset = Ruleset(Life(2, 3); opt=SparseOpt(), proc=CuGPU())</code></pre><p>Multiple rules can be combined in a <code>Ruleset</code> or simply passed to <code>sim!</code> directly. Each rule  will be run for the whole grid, in sequence, using appropriate optimisations depending  on the parent types of each rule:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt(), proc=ThreadedCPU())</code></pre><p><strong>Output</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Output-1">Outputs</a> are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: <code>ArrayOutput</code> is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the <code>init</code> array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.</p><pre><code class="language-julia hljs">output = ArrayOutput(init; tspan=1:10)</code></pre><p>The <code>REPLOutput</code> shown above is a <code>GraphicOutput</code> that can be useful for checking a simulation when working in a terminal or over ssh:</p><pre><code class="language-julia hljs">output = REPLOutput(init; tspan=1:100)</code></pre><p><code>ImageOutput</code> is the most complex class of outputs, allowing full color visual simulations using ColorSchemes.jl. It can also display multiple grids using color  composites or layouts, as shown above in the quarantine simulation.</p><p><a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters, using  <a href="https://github.com/rafaqz/ModelParameters.jl">ModelParameters.jl</a>. <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. </p><p>Outputs are also easy to write, and high performance applications may benefit from writing a custom output to reduce memory use, or using <code>TransformedOuput</code>.  Performance of DynamicGrids.jl is dominated by cache interactions, so reducing  memory use has positive effects.</p><p><strong>Example: Forest Fire</strong></p><p>This example implements the classic stochastic forest fire model in a few different ways, and benchmarks them. Note you will need ImageMagick.jl installed for <code>.gif</code> output to work.</p><p>First we will define a Forest Fire algorithm that sets the current cell to burning, if a neighbor is burning. Dead cells can come back to life, and living cells can spontaneously catch fire:</p><pre><code class="language-julia hljs">using DynamicGrids, ColorSchemes, Colors, BenchmarkTools

const DEAD, ALIVE, BURNING = 1, 2, 3

neighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01
    Neighbors(Moore(1)) do data, neighborhood, cell, I
        if cell == ALIVE
            if BURNING in neighborhood
                BURNING
            else
                rand() &lt;= prob_combustion ? BURNING : ALIVE
            end
        elseif cell == BURNING
            DEAD
        else
            rand() &lt;= prob_regrowth ? ALIVE : DEAD
        end
    end
end

# Set up the init array and output (using a Gtk window)
init = fill(ALIVE, 400, 400)
output = GifOutput(init; 
    filename=&quot;forestfire.gif&quot;, 
    tspan=1:200, 
    fps=25, 
    minval=DEAD, maxval=BURNING, 
    scheme=ColorSchemes.rainbow,
    zerocolor=RGB24(0.0)
)

# Run the simulation, which will save a gif when it completes
sim!(output, neighbors_rule)</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif" alt="forestfire"/></p><p>Timing the simulation for 200 steps, the performance is quite good. This particular CPU has six cores, and we get a 5.25x speedup by using all of them, which indicates good scaling:</p><pre><code class="language-julia hljs">bench_output = ResultOutput(init; tspan=1:200)

julia&gt; 
@btime sim!($bench_output, $neighbors_rule);
  477.183 ms (903 allocations: 2.57 MiB)

julia&gt; @btime sim!($bench_output, $neighbors_rule; proc=ThreadedCPU());
  91.321 ms (15188 allocations: 4.07 MiB)</code></pre><p>We can also <em>invert</em> the algorithm, setting cells in the neighborhood to burning if the current cell is burning, by using the <code>SetNeighbors</code> rule:</p><pre><code class="language-julia hljs">setneighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01
    SetNeighbors(Moore(1)) do data, neighborhood, cell, I
        if cell == DEAD
            if rand() &lt;= prob_regrowth
                data[I...] = ALIVE
            end
        elseif cell == BURNING
            for pos in positions(neighborhood, I)
                if data[pos...] == ALIVE
                    data[pos...] = BURNING
                end
            end
            data[I...] = DEAD
        elseif cell == ALIVE
            if rand() &lt;= prob_combustion 
                data[I...] = BURNING
            end
        end
    end
end</code></pre><p><em>Note: we are not using <code>add!</code>, instead we just set the grid value directly. This usually risks errors if multiple cells set different values. Here they only ever set a currently living cell to burning in the next timestep. It doesn&#39;t matter if this happens multiple times, the result is the same.</em></p><p>And in this case (a fairly sparse simulation), this rule is faster:</p><pre><code class="language-julia hljs">julia&gt; @btime sim!($bench_output, $setneighbors_rule);
  261.969 ms (903 allocations: 2.57 MiB)

julia&gt; @btime sim!($bench_output, $setneighbors_rule; proc=ThreadedCPU());
  65.489 ms (7154 allocations: 3.17 MiB)</code></pre><p>But the scaling is not quite as good, at 3.9x for 6 cores. The first method may be better on a machine with a lot of cores.</p><p>Last, we slightly rewrite these rules for GPU, as <code>rand</code> was not available within a GPU kernel. It is now, but it turns out that this method is faster! and interesting to demonstrate using multiple grids and <code>SetGrid</code>.</p><p>This way we call <code>CUDA.rand!</code> on the entire parent array of the <code>:rand</code> grid, using a <code>SetGrid</code> rule:</p><pre><code class="language-julia hljs">using CUDAKernels, CUDA

randomiser = SetGrid{Tuple{},:rand}() do randgrid
    CUDA.rand!(parent(randgrid))
end</code></pre><p>Now we define a Neighbors version for GPU, using the <code>:rand</code> grid values instead of <code>rand()</code>:</p><pre><code class="language-julia hljs">neighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01
    Neighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do data, neighborhood, (cell, rand), I
        if cell == ALIVE
            if BURNING in neighborhood
                BURNING
            else
                rand &lt;= prob_combustion ? BURNING : ALIVE
            end
        elseif cell == BURNING
            DEAD
        else
            rand &lt;= prob_regrowth ? ALIVE : DEAD
        end
    end
end</code></pre><p>And a SetNeighbors version for GPU:</p><pre><code class="language-julia hljs">setneighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01
    SetNeighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do data, neighborhood, (cell, rand), I
        if cell == DEAD
            if rand &lt;= prob_regrowth
                data[:ff][I...] = ALIVE
            end
        elseif cell == BURNING
            for pos in positions(neighborhood, I)
                if data[:ff][pos...] == ALIVE
                    data[:ff][pos...] = BURNING
                end
            end
            data[:ff][I...] = DEAD
        elseif cell == ALIVE
            if rand &lt;= prob_combustion 
                data[:ff][I...] = BURNING
            end
        end
    end
end</code></pre><p>Now benchmark both version on a GTX 1080 GPU. Despite the overhead of reading and writing two grids, this turns out to be even faster again:</p><pre><code class="language-julia hljs">bench_output_rand = ResultOutput((ff=init, rand=zeros(size(init))); tspan=1:200)

julia&gt; @btime sim!($bench_output_rand, $randomiser, $neighbors_gpu; proc=CuGPU());
  30.621 ms (186284 allocations: 17.19 MiB)

julia&gt; @btime sim!($bench_output_rand, $randomiser, $setneighbors_gpu; proc=CuGPU());
  22.685 ms (147339 allocations: 15.61 MiB)</code></pre><p>That is, we are running the rule at a rate of <em>1.4 billion times per second</em>. These timings could be improved (maybe 10-20%) by using grids of <code>Int32</code> or <code>Int16</code> to use less memory and cache. But we will stop here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/DynamicGrids.jl#L3-L386">source</a></section></article><h2 id="Running-simulations"><a class="docs-heading-anchor" href="#Running-simulations">Running simulations</a><a id="Running-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Running-simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sim!" href="#DynamicGrids.sim!"><code>DynamicGrids.sim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim!(output, rules::Rule...; kw...)
sim!(output, rules::Tuple{&lt;:Rule,Vararg}; kw...)
sim!(output, [ruleset::Ruleset=ruleset(output)]; kw...)</code></pre><p>Runs the simulation rules over the <code>output</code> <code>tspan</code>, writing the destination array to <code>output</code> for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one or more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s. If the output has a <code>Ruleset</code> attached, it will be used.</li></ul><p><strong>Keywords</strong></p><p>Theses are the taken from the <code>output</code> argument by default:</p><ul><li><code>init</code>: optional array or NamedTuple of arrays.</li><li><code>mask</code>: a <code>Bool</code> array matching the init array size. <code>false</code> cells do not run.</li><li><code>aux</code>: a <code>NamedTuple</code> of auxilary data to be used by rules.</li><li><code>tspan</code>: a tuple holding the start and end of the timespan the simulaiton will run for.</li><li><code>fps</code>: the frames per second to display. Will be taken from the output if not passed in.</li></ul><p>Theses are the taken from the <code>ruleset</code> argument by default:</p><ul><li><code>proc</code>: a <a href="#DynamicGrids.Processor"><code>Processor</code></a> to specificy the hardware to run simulations on,    like <a href="#DynamicGrids.SingleCPU"><code>SingleCPU</code></a>, <a href="#DynamicGrids.ThreadedCPU"><code>ThreadedCPU</code></a> or <a href="#DynamicGrids.CuGPU"><code>CuGPU</code></a> when    KernelAbstractions.jl and a CUDA gpu is available. </li><li><code>opt</code>: a <a href="#DynamicGrids.PerformanceOpt"><code>PerformanceOpt</code></a> to specificy optimisations like   <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> or <a href="#DynamicGrids.NoOpt"><code>NoOpt</code></a>. Defaults to <code>NoOpt()</code>.</li><li><code>boundary</code>: what to do with boundary of grid edges.  Options are <a href="#DynamicGrids.Remove"><code>Remove</code></a> or <a href="#DynamicGrids.Wrap"><code>Wrap</code></a>, defaulting to <code>Remove()</code>.</li><li><code>cellsize</code>: the size of cells, which may be accessed by rules.</li><li><code>timestep</code>: fixed timestep where this is required for some rules.   eg. <code>Month(1)</code> or <code>1u&quot;s&quot;</code>.</li></ul><p>Other:</p><ul><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can reduce memory allocation a little, when that is important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/framework.jl#L2-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.resume!" href="#DynamicGrids.resume!"><code>DynamicGrids.resume!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resume!(output::GraphicOutput, ruleset::Ruleset=ruleset(output); tstop, kw...)</code></pre><p>Restart the simulation from where you stopped last time. For arguments see <a href="#DynamicGrids.sim!"><code>sim!</code></a>. The keyword arg <code>tstop</code> can be used to extend the length of the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one ore more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s.   These will each be run in sequence.</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>tstop</code>: the new stop time for the simulation. Taken from the output length by default.</li><li><code>fps</code>: the frames per second to display. Taken from the output by default.</li><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can improve performance   when that is important</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/framework.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.step!" href="#DynamicGrids.step!"><code>DynamicGrids.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step!(sd::AbstractSimData)</code></pre><p>Allows stepping a simulation one frame at a time, for a more manual approach to simulation that <code>sim!</code>. This may be useful if other processes need to be run  between steps, or the simulation is of variable length. <code>step!</code> also removes the use of <code>Output</code>s, meaning storing of grid data must be handled manually, if that is  required. Of course, an output can also be updated manually, using:</p><pre><code class="language-julia hljs">DynmicGrids.storeframe!(output, simdata)</code></pre><p>Instead of an <code>Output</code>, the internal <a href="#DynamicGrids.SimData"><code>SimData</code></a> objects are used directly,  and can be defined using a <a href="#DynamicGrids.Extent"><code>Extent</code></a> object and a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DynmicGrids, Plots
ruleset = Ruleset(Life(); proc=ThreadedCPU())
extent = Extent(; init=(a=A, b=B), aux=aux, tspan=tspan)
simdata = SimData(extent, ruleset)

# Run a single step, which returns an updated `SimData` object
simdata = step!(simdata)
# Get a view of the grid without padding
grid = DynmicGrids.gridview(simdata[:a])
heatmap(grid)</code></pre><p>This example returns a <code>GridData</code> object for the <code>:a</code> grid, which is <code>&lt;: AbstractAray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/framework.jl#L192-L224">source</a></section></article><h2 id="Rulesets"><a class="docs-heading-anchor" href="#Rulesets">Rulesets</a><a id="Rulesets-1"></a><a class="docs-heading-anchor-permalink" href="#Rulesets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractRuleset" href="#DynamicGrids.AbstractRuleset"><code>DynamicGrids.AbstractRuleset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRuleset &lt;: ModelParameters.AbstractModel</code></pre><p>Abstract supertype for <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> objects and variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rulesets.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Ruleset" href="#DynamicGrids.Ruleset"><code>DynamicGrids.Ruleset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rulseset &lt;: AbstractRuleset

Ruleset(rules...; kw...)
Ruleset(rules, settings)</code></pre><p>A container for holding a sequence of <code>Rule</code>s and simulation details like boundary handing and optimisation. Rules will be run in the order they are passed, ie. <code>Ruleset(rule1, rule2, rule3)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>proc</code>: a <a href="#DynamicGrids.Processor"><code>Processor</code></a> to specificy the hardware to run simulations on,    like <a href="#DynamicGrids.SingleCPU"><code>SingleCPU</code></a>, <a href="#DynamicGrids.ThreadedCPU"><code>ThreadedCPU</code></a> or <a href="#DynamicGrids.CuGPU"><code>CuGPU</code></a> when    KernelAbstractions.jl and a CUDA gpu is available. </li><li><code>opt</code>: a <a href="#DynamicGrids.PerformanceOpt"><code>PerformanceOpt</code></a> to specificy optimisations like   <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a>. Defaults to <a href="#DynamicGrids.NoOpt"><code>NoOpt</code></a>.</li><li><code>boundary</code>: what to do with boundary of grid edges.   Options are <code>Remove()</code> or <code>Wrap()</code>, defaulting to <a href="#DynamicGrids.Remove"><code>Remove</code></a>.</li><li><code>cellsize</code>: size of cells.</li><li><code>timestep</code>: fixed timestep where this is required for some rules.    eg. <code>Month(1)</code> or <code>1u&quot;s&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rulesets.jl#L26-L48">source</a></section></article><h2 id="Options/Flags"><a class="docs-heading-anchor" href="#Options/Flags">Options/Flags</a><a id="Options/Flags-1"></a><a class="docs-heading-anchor-permalink" href="#Options/Flags" title="Permalink"></a></h2><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.BoundaryCondition" href="#DynamicGrids.BoundaryCondition"><code>DynamicGrids.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition</code></pre><p>Abstract supertype for flags that specify the boundary conditions used in the simulation, used in <a href="#DynamicGrids.inbounds"><code>inbounds</code></a> and to update <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> grid padding. These determine what happens when a neighborhood or jump extends outside of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Wrap" href="#DynamicGrids.Wrap"><code>DynamicGrids.Wrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wrap &lt;: BoundaryCondition

Wrap()</code></pre><p><a href="#DynamicGrids.BoundaryCondition"><code>BoundaryCondition</code></a> flag to wrap cordinates that boundary boundaries back to the opposite side of the grid.</p><p>Specifiy with:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule; boundary=Wrap())
# or
output = sim!(output, rule; boundary=Wrap())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L84-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Remove" href="#DynamicGrids.Remove"><code>DynamicGrids.Remove</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Remove &lt;: BoundaryCondition

Remove()</code></pre><p><a href="#DynamicGrids.BoundaryCondition"><code>BoundaryCondition</code></a> flag that specifies to assign <code>padval</code> to cells that overflow  grid boundaries. <code>padval</code> defaults to <code>zero(eltype(grid))</code> but can be assigned as a keyword argument to an <a href="#DynamicGrids.Output"><code>Output</code></a>.</p><p>Specifiy with:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule; boundary=Remove())
# or
output = sim!(output, rule; boundary=Remove())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L102-L118">source</a></section></article><h3 id="Hardware-selection"><a class="docs-heading-anchor" href="#Hardware-selection">Hardware selection</a><a id="Hardware-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Hardware-selection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Processor" href="#DynamicGrids.Processor"><code>DynamicGrids.Processor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Processor</code></pre><p>Abstract supertype for selecting a hardware processor, such as ia CPU or GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CPU" href="#DynamicGrids.CPU"><code>DynamicGrids.CPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPU &lt;: Processor</code></pre><p>Abstract supertype for CPU processors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SingleCPU" href="#DynamicGrids.SingleCPU"><code>DynamicGrids.SingleCPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleCPU &lt;: CPU

SingleCPU()</code></pre><p><a href="#DynamicGrids.Processor"><code>Processor</code></a> flag that specifies to use a single thread on a single CPU.</p><p>Specifiy with:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule; proc=SingleCPU())
# or
output = sim!(output, rule; proc=SingleCPU())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ThreadedCPU" href="#DynamicGrids.ThreadedCPU"><code>DynamicGrids.ThreadedCPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadedCPU &lt;: CPU

ThreadedCPU()</code></pre><p><a href="#DynamicGrids.Processor"><code>Processor</code></a> flag that specifies to use a <code>Threads.nthreads()</code> CPUs.</p><p>Specifiy with:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule; proc=ThreadedCPU())
# or
output = sim!(output, rule; proc=ThreadedCPU())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GPU" href="#DynamicGrids.GPU"><code>DynamicGrids.GPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GPU &lt;: Processor</code></pre><p>Abstract supertype for GPU processors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/gpu.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CuGPU" href="#DynamicGrids.CuGPU"><code>DynamicGrids.CuGPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CuGPU &lt;: GPU

CuGPU()
CuGPU{threads_per_block}()</code></pre><pre><code class="language-julia hljs">ruleset = Ruleset(rule; proc=CuGPU())
# or
output = sim!(output, rule; proc=CuGPU())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/cuda.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CPUGPU" href="#DynamicGrids.CPUGPU"><code>DynamicGrids.CPUGPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPUGPU &lt;: GPU

CPUGPU()</code></pre><p>Uses the CUDA GPU code on CPU using KernelAbstractions, to test it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/gpu.jl#L8-L14">source</a></section></article><h3 id="Performance-optimisation"><a class="docs-heading-anchor" href="#Performance-optimisation">Performance optimisation</a><a id="Performance-optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-optimisation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PerformanceOpt" href="#DynamicGrids.PerformanceOpt"><code>DynamicGrids.PerformanceOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PerformanceOpt</code></pre><p>Abstract supertype for performance optimisation flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NoOpt" href="#DynamicGrids.NoOpt"><code>DynamicGrids.NoOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoOpt &lt;: PerformanceOpt

NoOpt()</code></pre><p>Flag to run a simulation without performance optimisations besides basic high performance programming. Still fast, but not intelligent about the work that it does: all cells are run for all rules.</p><p><code>NoOpt</code> is the default <code>opt</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/flags.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SparseOpt" href="#DynamicGrids.SparseOpt"><code>DynamicGrids.SparseOpt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseOpt &lt;: PerformanceOpt

SparseOpt()</code></pre><p>An optimisation flag that ignores all padding valuesin the grid, by default zeros.</p><p>For low-density simulations performance may improve by orders of magnitude, as only used cells are run.</p><p>Specifiy with:</p><pre><code class="language-julia hljs">ruleset = Ruleset(rule; opt=SparseOpt())
# or
output = sim!(output, rule; opt=SparseOpt())</code></pre><p><code>SparseOpt</code> is best demonstrated with this simulation, where the grey areas do not run except where the neighborhood partially hangs over an area that is not grey:</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/complexlife_spareseopt.gif" alt="SparseOpt demonstration"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/sparseopt.jl#L2-L25">source</a></section></article><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Rule" href="#DynamicGrids.Rule"><code>DynamicGrids.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule</code></pre><p>A <code>Rule</code> object contains the information required to apply an <code>applyrule</code> method to every cell of every timestep of a simulation.</p><p>The <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> method follows the form:</p><pre><code class="language-julia hljs">@inline applyrule(data::AbstractSimData, rule::MyRule, state, I::Tuple{Int,Int}) = ...</code></pre><p>Where <code>I</code> is the cell index, and <code>state</code> is a single value, or a <code>NamedTuple</code> if multiple grids are requested. the <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object can be used to access  current timestep and other simulation data and metadata.</p><p>Rules can be updated from the original rule before each timestep, in <a href="#DynamicGrids.modifyrule"><code>modifyrule</code></a>. Here a paremeter depends on the sum of a grid:</p><pre><code class="language-julia hljs">using DynamicGrids, Setfield
struct MySummedRule{R,W,T} &lt;: CellRule{R,W}
    gridsum::T
end
function modifyrule(rule::MySummedRule{R,W}, data::AbstractSimData) where {R,W}
    Setfield.@set rule.gridsum = sum(data[R])
end

# output
modifyrule (generic function with 1 method)</code></pre><p>Rules can also be run in sequence, as a <code>Tuple</code> or in a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>s.</p><p>DynamicGrids guarantees that:</p><ul><li><code>modifyrule</code> is run once for every rule for every timestep.   The result is passed to <code>applyrule</code>, but not retained after that.</li><li><code>applyrule</code> is run once for every rule, for every cell, for every timestep, unless an   optimisation like <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> is used to skip empty cells.</li><li>the output of running a rule for any cell does not affect the input of the   same rule running anywhere else in the grid.</li><li>rules later in the sequence are passed grid state updated by the earlier rules.</li><li>masked areas, and wrapped or removed <code>boundary</code> regions are updated between rules when   they have changed.</li></ul><p><strong>Multiple grids</strong></p><p>The keys of the init <code>NamedTuple</code> will be match the grid keys used in <code>R</code> and <code>W</code> for each rule, which is a type like <code>Tuple{:key1,:key1}</code>. Note that the names are user-specified, and should never be fixed by a <code>Rule</code>.</p><p>Read grid names are retrieved from the type here as <code>R1</code> and <code>R2</code>, while write grids are <code>W1</code> and <code>W2</code>.</p><pre><code class="language-julia hljs">using DynamicGrids
struct MyMultiSetRule{R,W} &lt;: SetCellRule{R,W} end
function applyrule(
    data::AbstractSimData, rule::MyMultiSetRule{Tuple{R1,R2},Tuple{W1,W2}}, (r1, r2), I
) where {R1,R2,W1,W2}
    add!(data[W1], 1, I) 
    add!(data[W2], 1, I) 
end

# output
applyrule (generic function with 1 method)</code></pre><p>The return value of an <code>applyrule</code> is written to the current cell in the specified <code>W</code> write grid/s. <code>Rule</code>s writing to multiple grids simply return a <code>Tuple</code> in the order specified by the <code>W</code> type params.</p><p><strong>Rule Performance</strong></p><p>Rules may run many millions of times during a simulation. They need to be fast. Some basic guidlines for writing rules are:</p><ul><li>Never allocate memory in a <code>Rule</code> if you can help it.</li><li>Type stability is essential. <a href="#DynamicGrids.isinferred"><code>isinferred</code></a> is useful to check   if your rule is type-stable.</li><li>Using the <code>@inline</code> macro on <code>applyrule</code> can help force inlining your   code into the simulation.</li><li>Reading and writing from multiple grids is expensive due to additional load   on fast cahce memory. Try to limit the number of grids you use.</li><li>Use a graphical profiler, like ProfileView.jl, to check your rules overall   performance when run with <code>sim!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L2-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetRule" href="#DynamicGrids.SetRule"><code>DynamicGrids.SetRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetRule &lt;: Rule</code></pre><p>Abstract supertype for rules that manually write to the grid in some way.</p><p>These must define methods of <a href="#DynamicGrids.applyrule!"><code>applyrule!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L247-L253">source</a></section></article><h3 id="CellRule"><a class="docs-heading-anchor" href="#CellRule">CellRule</a><a id="CellRule-1"></a><a class="docs-heading-anchor-permalink" href="#CellRule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CellRule" href="#DynamicGrids.CellRule"><code>DynamicGrids.CellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cellrule &lt;: Rule</code></pre><p>A <code>Rule</code> that only writes and uses a state from single cell of the read grids, and has its return value written back to the same cell(s).</p><p>This limitation can be useful for performance optimisation, such as wrapping rules in <a href="#DynamicGrids.Chain"><code>Chain</code></a> so that no writes occur between rules.</p><p><code>CellRule</code> is defined with :</p><pre><code class="language-julia hljs">using DynamicGrids
struct MyCellRule{R,W} &lt;: CellRule{R,W} end
# output</code></pre><p>And applied as:</p><pre><code class="language-julia hljs">function applyrule(data, rule::MyCellRule, state, I)
    state * 2
end
# output
applyrule (generic function with 1 method)</code></pre><p>As the index <code>I</code> is provided in <code>applyrule</code>, you can use it to look up <a href="#DynamicGrids.Aux"><code>Aux</code></a> data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L155-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Cell" href="#DynamicGrids.Cell"><code>DynamicGrids.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Call &lt;: CellRule

Cell(f)
Cell{R,W}(f)</code></pre><p>A <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> that applies a function <code>f</code> to the <code>R</code> grid value,  or <code>Tuple</code> of values, and returns the <code>W</code> grid value or <code>Tuple</code> of values.</p><p>Especially convenient with <code>do</code> notation.</p><p><strong>Example</strong></p><p>Double the cell value in grid <code>:a</code>:</p><pre><code class="language-julia hljs">using DynamicGrids
simplerule = Cell{:a}() do data, a, I
    2a
end
# output
Cell{:a,:a}(
    f = var&quot;#1#2&quot;
)</code></pre><p><code>data</code> is an <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object, <code>a</code> is the cell value, and <code>I</code> is a <code>Tuple</code> holding the cell index.</p><p>If you need to use multiple grids (a and b), use the <code>R</code> and <code>W</code> type parameters. If you want to use external variables, wrap the whole thing in a <code>let</code> block, for performance. This rule sets the new value of <code>b</code> to the value of <code>a</code> to <code>b</code> times scalar <code>y</code>:</p><pre><code class="language-julia hljs">y = 0.7
rule = let y = y
    rule = Cell{Tuple{:a,:b},:b}() do data, (a, b), I
        a + b * y
    end
end
# output
Cell{Tuple{:a, :b},:b}(
    f = var&quot;#3#4&quot;{Float64}
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L188-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CopyTo" href="#DynamicGrids.CopyTo"><code>DynamicGrids.CopyTo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CopyTo &lt;: CellRule

CopyTo{W}(from)
CopyTo{W}(; from)</code></pre><p>A simple rule that copies aux array slices to a grid over time. This can be used for comparing simulation dynamics to aux data dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/copyto.jl#L1-L9">source</a></section></article><h3 id="NeighborhoodRule"><a class="docs-heading-anchor" href="#NeighborhoodRule">NeighborhoodRule</a><a id="NeighborhoodRule-1"></a><a class="docs-heading-anchor-permalink" href="#NeighborhoodRule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NeighborhoodRule" href="#DynamicGrids.NeighborhoodRule"><code>DynamicGrids.NeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NeighborhoodRule &lt;: Rule</code></pre><p>A Rule that only accesses a neighborhood centered around the current cell. <code>NeighborhoodRule</code> is applied with the method:</p><pre><code class="language-julia hljs">applyrule(data::AbstractSimData, rule::MyNeighborhoodRule, state, I::Tuple{Int,Int})</code></pre><p><code>NeighborhoodRule</code> must have a <code>neighborhood</code> method or field, that holds a <a href="#DynamicGrids.Neighborhoods.Neighborhood"><code>Neighborhood</code></a> object. <code>neighbors(rule)</code> returns an iterator over the surrounding cell pattern defined by the <code>Neighborhood</code>.</p><p>For each cell in the grids the neighborhood buffer will be updated for use in the <code>applyrule</code> method, managed to minimise array reads.</p><p>This allows memory optimisations and the use of high-perforance routines on the neighborhood buffer. It also means that and no bounds checking is required in neighborhood code.</p><p>For neighborhood rules with multiple read grids, the first is always the one used for the neighborhood, the others are passed in as additional state for the cell. Any grids can be written to, but only for the current cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L360-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighbors" href="#DynamicGrids.Neighbors"><code>DynamicGrids.Neighbors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Neighbors &lt;: NeighborhoodRule

Neighbors(f, neighborhood=Moor(1))
Neighbors{R,W}(f, neighborhood=Moore())</code></pre><p>A <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> that receives a <a href="#DynamicGrids.Neighborhoods.Neighborhood"><code>Neighborhood</code></a> object  for the first <code>R</code> grid, followed by the cell value/s for the required grids,  as with <a href="#DynamicGrids.Cell"><code>Cell</code></a>.</p><p>Returned value(s) are written to the <code>W</code> grid/s.</p><p>As with all <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a>, you do not have to check bounds at grid edges, that is handled for you internally.</p><p>Using <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> may improve neighborhood performance when a specific value (often zero) is common and can be safely ignored.</p><p><strong>Example</strong></p><p>Runs a game of life glider on grid <code>:a</code>:</p><pre><code class="language-julia hljs">using DynamicGrids
const sum_states = (0, 0, 1, 0, 0, 0, 0, 0, 0), 
                   (0, 0, 1, 1, 0, 0, 0, 0, 0)
life = Neighbors{:a}(Moore(1)) do data, hood, a, I
    sum_states[a + 1][sum(hood) + 1]
end
init = Bool[
     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 1 1 1 0 0 0 0 0 0 0
     0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
     0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
]
output = REPLOutput((; a=init); fps=25, tspan=1:50)
sim!(output, Life{:a}(); boundary=Wrap())
output[end][:a]

# output
5×15 Matrix{Bool}:
 0  0  1  0  1  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  1  0  0  0  0  0  0  0  0  0  0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L409-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Convolution" href="#DynamicGrids.Convolution"><code>DynamicGrids.Convolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Convolution &lt;: NeighborhoodRule

Convolution(kernel::AbstractArray)
Convolution{R,W}(kernel::AbstractArray)</code></pre><p>A <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> that runs a convolution kernel over the grid.</p><p><code>kernel</code> must be a square matrix.</p><p><strong>Performance</strong></p><p>Small radius convolutions in DynamicGrids.jl will be comparable or even faster than using DSP.jl or ImageConvolutions.jl. As the radius increases these packages will be a lot faster.</p><p>But <code>Convolution</code> is convenient to chain into a simulation, and combined with some other rules. It should perform reasonably well with all but very large kernels.</p><p>Values are not normalised, so make sure the kernel sums to <code>1</code> if you need that.</p><p><strong>Example</strong></p><p>A streaking convolution that looks a bit like sand blowing.</p><p>Swap out the matrix values to change the pattern.</p><pre><code class="language-julia hljs">using DynamicGrids, DynamicGridsGtk
streak = Convolution([0.0 0.01 0.48; 
                      0.0 0.5  0.01; 
                      0.0 0.0  0.0])
output = GtkOutput(rand(500, 500); tspan = 1:1000, fps=100)
sim!(output, streak; boundary=Wrap())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L475-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Life" href="#DynamicGrids.Life"><code>DynamicGrids.Life</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Life &lt;: NeighborhoodRule

Life(neighborhood, born=3, survive=(2, 3))</code></pre><p>Rule for game-of-life style cellular automata. This is a demonstration of Cellular Automata more than a seriously optimised game of life rule.</p><p>Cells becomes active if it is empty and the number of neightbors is a number in the <code>born</code>, and remains active the cell is active and the number of neightbors is in <code>survive</code>.</p><p><strong>Examples (gleaned from CellularAutomata.jl)</strong></p><pre><code class="language-julia hljs">using DynamicGrids, Distributions

# Use `Binomial` to tweak the density random true values
init = Bool.(rand(Binomial(1, 0.5), 70, 70))
output = REPLOutput(init; tspan=1:100, fps=25, color=:red)

# Morley
sim!(output, Ruleset(Life(born=[3, 6, 8], survive=[2, 4, 5])))

# 2x2
sim!(output, Ruleset(Life(born=[3, 6], survive=[1, 2, 5])))

# Dimoeba
init = rand(Bool, 400, 300)
init[:, 100:200] .= 0
output = REPLOutput(init; tspan=1:100, fps=25, color=:blue, style=Braile())
sim!(output, Life(born=(3, 5, 6, 7, 8),  survive=(5, 6, 7, 8)))

## No death
sim!(output, Life(born=(3,),  survive=(0, 1, 2, 3, 4, 5, 6, 7, 8)))

## 34 life
sim!(output, Life(born=(3, 4), survive=(3, 4)))

# Replicator
init = fill(true, 300,300)
init[:, 100:200] .= false
init[10, :] .= 0
output = REPLOutput(init; tspan=1:100, fps=25, color=:yellow)
sim!(output, Life(born=(1, 3, 5, 7),  survive=(1, 3, 5, 7)))
nothing

# output
</code></pre><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/life.gif" alt="REPL Life"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/life.jl#L1-L53">source</a></section></article><h3 id="SetCellRule"><a class="docs-heading-anchor" href="#SetCellRule">SetCellRule</a><a id="SetCellRule-1"></a><a class="docs-heading-anchor-permalink" href="#SetCellRule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetCellRule" href="#DynamicGrids.SetCellRule"><code>DynamicGrids.SetCellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetCellRule &lt;: Rule</code></pre><p>Abstract supertype for rules that can manually write to any cells of the grid that they need to.</p><p>For example, <code>SetCellRule</code> is applied with like this, here simply adding 1 to the current cell:</p><pre><code class="language-julia hljs">using DynamicGrids
struct MySetCellRule{R,W} &lt;: SetCellRule{R,W} end

function applyrule!(data::AbstractSimData, rule::MySetCellRule{R,W}, state, I) where {R,W}
    # Add 1 to the cell 10 up and 10 accross
    I, isinbounds = inbounds(I .+ 10)
    isinbounds &amp;&amp; add!(data[W], 1, I...)
    return nothing
end
# output
applyrule! (generic function with 1 method)</code></pre><p>Note the <code>!</code> bang - this method alters the state of <code>data</code>.</p><p>To update the grid, you can use atomic operators <a href="#DynamicGrids.add!"><code>add!</code></a>, <a href="#DynamicGrids.sub!"><code>sub!</code></a>, <a href="#DynamicGrids.min!"><code>min!</code></a>, <a href="#DynamicGrids.max!"><code>max!</code></a>, and <a href="#DynamicGrids.and!"><code>and!</code></a>, <a href="#DynamicGrids.or!"><code>or!</code></a> for <code>Bool</code>. These methods safely combined writes from all grid cells - directly using <code>setindex!</code> would cause bugs.</p><p>It there are multiple write grids, you will need to get the grid keys from type parameters, here <code>W1</code> and <code>W2</code>:</p><pre><code class="language-julia hljs">function applyrule(data, rule::MySetCellRule{R,Tuple{W1,W2}}, state, I) where {R,W1,W2}
    add!(data[W1], 1, I...)
    add!(data[W2], 2, I...)
    return nothing
end
# output
applyrule (generic function with 1 method)</code></pre><p>DynamicGrids guarantees that:</p><ul><li>values written to anywhere on the grid do not affect other cells in   the same rule at the same timestep.</li><li>values written to anywhere on the grid are available to the next rule in the   sequence, or in the next timestep if there are no remaining rules.</li><li>if atomic operators like <code>add!</code> and <code>sub!</code> are always used to write to the grid,   race conditions will not occur on any hardware.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L258-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetCell" href="#DynamicGrids.SetCell"><code>DynamicGrids.SetCell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetCell &lt;: SetCellRule

SetCell(f)
SetCell{R,W}(f)</code></pre><p>A <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a> to manually write to the array where you need to. <code>f</code> is passed a <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object, the grid state or <code>Tuple</code> of grid  states for the cell and a <code>Tuple{Int,Int}</code> index of the current cell.</p><p>To update the grid, you can use: <a href="#DynamicGrids.add!"><code>add!</code></a>, <a href="#DynamicGrids.sub!"><code>sub!</code></a> for <code>Number</code>, and <a href="#DynamicGrids.and!"><code>and!</code></a>, <a href="#DynamicGrids.or!"><code>or!</code></a> for <code>Bool</code>. These methods safely combined writes from all grid cells - directly using <code>setindex!</code> would cause bugs.</p><p><strong>Example</strong></p><p>Choose a destination cell and if it is in the grid, update it based on the  state of both grids:</p><pre><code class="language-julia hljs">using DynamicGrids
rule = SetCell{Tuple{:a,:b},:b}() do data, (a, b), I 
    dest = your_dest_pos_func(I)
    if isinbounds(data, dest)
        destval = your_dest_val_func(a, b)
        add!(data[:b], destval, dest...)
    end
end

# output
SetCell{Tuple{:a, :b},:b}(
    f = var&quot;#1#2&quot;
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L313-L347">source</a></section></article><h3 id="SetNeighborhoodRule"><a class="docs-heading-anchor" href="#SetNeighborhoodRule">SetNeighborhoodRule</a><a id="SetNeighborhoodRule-1"></a><a class="docs-heading-anchor-permalink" href="#SetNeighborhoodRule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetNeighborhoodRule" href="#DynamicGrids.SetNeighborhoodRule"><code>DynamicGrids.SetNeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetNeighborhoodRule &lt;: SetRule</code></pre><p>A <a href="#DynamicGrids.SetRule"><code>SetRule</code></a> that only writes to its neighborhood, and does not need to bounds-check.</p><p><a href="#DynamicGrids.Neighborhoods.positions"><code>positions</code></a> and <a href="#DynamicGrids.Neighborhoods.offsets"><code>offsets</code></a> are useful iterators for modifying neighborhood values. </p><p><code>SetNeighborhoodRule</code> rules must return a <a href="#DynamicGrids.Neighborhoods.Neighborhood"><code>Neighborhood</code></a> object from the function  <code>neighborhood(rule)</code>. By default this is <code>rule.neighborhood</code>. If this property exists,  no interface methods are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L519-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetNeighbors" href="#DynamicGrids.SetNeighbors"><code>DynamicGrids.SetNeighbors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetNeighbors &lt;: SetNeighborhoodRule

SetNeighbors(f, neighborhood=Moor(1))
SetNeighbors{R,W}(f, neighborhood=Moor(1))</code></pre><p>A <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a> to manually write to the array with the specified neighborhood. Indexing outside the neighborhood is undefined behaviour.</p><p>Function <code>f</code> is passed four arguments: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object, the specified <a href="#DynamicGrids.Neighborhoods.Neighborhood"><code>Neighborhood</code></a> object, the grid state or <code>Tuple</code> of grid states for the cell,  and the <code>Tuple{Int,Int}</code> index of the current cell.</p><p>To update the grid, you can use: <a href="#DynamicGrids.add!"><code>add!</code></a>, <a href="#DynamicGrids.sub!"><code>sub!</code></a> for <code>Number</code>, and <a href="#DynamicGrids.and!"><code>and!</code></a>, <a href="#DynamicGrids.or!"><code>or!</code></a> for <code>Bool</code>. These methods can be safely combined writes from all grid cells.</p><p>Directly using <code>setindex!</code> is possible, but may cause bugs as multiple cells may write to the same location in an unpredicatble order. As a rule, directly setting a neighborhood index should only be done if it always sets the samevalue - then it can be guaranteed that any writes from othe grid cells reach the same result.</p><p><a href="#DynamicGrids.Neighborhoods.neighbors"><code>neighbors</code></a>, <a href="#DynamicGrids.Neighborhoods.offsets"><code>offsets</code></a> and <a href="#DynamicGrids.Neighborhoods.positions"><code>positions</code></a> are useful methods for <code>SetNeighbors</code> rules.</p><p><strong>Example</strong></p><p>This example adds a value to all neighbors:</p><pre><code class="language-julia hljs">using DynamicGrids

rule = SetNeighbors{:a}() do data, neighborhood, a, I
    add_to_neighbors = your_func(a)
    for pos in positions(neighborhood)
        add!(data[:b], add_to_neighbors, pos...)
    end
end
# output
SetNeighbors{:a,:a}(
    f = var&quot;#1#2&quot;
    neighborhood = Moore{1, 2, 8, Nothing}
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L543-L587">source</a></section></article><h3 id="SetGridRule"><a class="docs-heading-anchor" href="#SetGridRule">SetGridRule</a><a id="SetGridRule-1"></a><a class="docs-heading-anchor-permalink" href="#SetGridRule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetGridRule" href="#DynamicGrids.SetGridRule"><code>DynamicGrids.SetGridRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetGridRule &lt;: Rule</code></pre><p>A <code>Rule</code> applies to whole grids. This is used for operations that don&#39;t benefit from having neighborhood buffering or looping over the grid handled for them, or any specific optimisations. Best suited to simple functions like <code>rand!(grid)</code> or using convolutions from other packages like DSP.jl. They may also be useful for doing other custom things that don&#39;t fit into the DynamicGrids.jl framework during the simulation.</p><p>Grid rules specify the grids they want and are sequenced just like any other grid.</p><pre><code class="language-julia hljs">struct MySetGridRule{R,W} &lt;: SetGridRule{R,W} end</code></pre><p>And applied as:</p><pre><code class="language-julia hljs">function applyrule!(data::AbstractSimData, rule::MySetGridRule{R,W}) where {R,W}
    rand!(data[W])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L603-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SetGrid" href="#DynamicGrids.SetGrid"><code>DynamicGrids.SetGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetGrid{R,W}(f)</code></pre><p>Apply a function <code>f</code> to fill whole grid/s.</p><p>Broadcasting is a good way to update values.</p><p><strong>Example</strong></p><p>This example simply sets grid <code>a</code> to equal grid <code>b</code>:</p><pre><code class="language-julia hljs">using DynamicGrids
rule = SetGrid{:a,:b}() do a, b
    b .= a
end

# output
SetGrid{:a,:b}(
    f = var&quot;#1#2&quot;
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L630-L652">source</a></section></article><h3 id="Rule-wrappers"><a class="docs-heading-anchor" href="#Rule-wrappers">Rule wrappers</a><a id="Rule-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-wrappers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RuleWrapper" href="#DynamicGrids.RuleWrapper"><code>DynamicGrids.RuleWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RuleWrapper &lt;: Rule</code></pre><p>A <code>Rule</code> that wraps other rules, altering their behaviour or how they are run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/rules.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Chain" href="#DynamicGrids.Chain"><code>DynamicGrids.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chain(rules...)
Chain(rules::Tuple)</code></pre><p><code>Chain</code>s allow chaining rules together to be completed in a single processing step, without intermediate reads or writes from grids.</p><p>They are potentially compiled together into a single function call, especially if you use <code>@inline</code> on all <code>applyrule</code> methods. <code>Chain</code> can hold either all <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> or <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>.</p><p><a href="#DynamicGrids.SetRule"><code>SetRule</code></a> can&#39;t be used in <code>Chain</code>, as it doesn&#39;t have a return value.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/Chain.png" alt="Chain rule diagram"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/chain.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RunIf" href="#DynamicGrids.RunIf"><code>DynamicGrids.RunIf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RunIf(f, rule)</code></pre><p><code>RunIf</code>s allows wrapping a rule in a condition, passed the <code>SimData</code> object and the cell state and index.</p><p>`<span>$julia RunIf(dispersal) do data, state, I     state &gt;= oneunit(state) end$</span> `</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/condition.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RunAt" href="#DynamicGrids.RunAt"><code>DynamicGrids.RunAt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RunAt(rules...)
RunAt(rules::Tuple)</code></pre><p><code>RunAt</code>s allow running a <code>Rule</code> or multiple <code>Rule</code>s at a lower frequeny than the main simulation, using a <code>range</code> matching the main <code>tspan</code> but with a larger span, or specific events - by using a vector of arbitrary times in <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/condition.jl#L57-L64">source</a></section></article><h3 id="Parameter-sources"><a class="docs-heading-anchor" href="#Parameter-sources">Parameter sources</a><a id="Parameter-sources-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-sources" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ParameterSource" href="#DynamicGrids.ParameterSource"><code>DynamicGrids.ParameterSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterSource</code></pre><p>Abstract supertypes for parameter source wrappers such as <a href="#DynamicGrids.Aux"><code>Aux</code></a>, <a href="#DynamicGrids.Grid"><code>Grid</code></a> and <a href="#DynamicGrids.Delay"><code>Delay</code></a>. These allow flexibility in that parameters can be retreived from various data sources not specified when the rule is written.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Aux" href="#DynamicGrids.Aux"><code>DynamicGrids.Aux</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Aux &lt;: ParameterSource

Aux{K}()
Aux(K::Symbol)</code></pre><p>Use auxilary array with key <code>K</code> as a parameter source.</p><p>Implemented in rules with:</p><pre><code class="language-julia hljs">get(data, rule.myparam, I)</code></pre><p>When an <code>Aux</code> param is specified at rule construction with:</p><pre><code class="language-julia hljs">rule = SomeRule(; myparam=Aux{:myaux})
output = ArrayOutput(init; aux=(myaux=myauxarray,))</code></pre><p>If the array is a DimensionalData.jl <code>DimArray</code> with a <code>Ti</code> (time) dimension, the correct interval will be selected automatically, precalculated for each timestep so it has no significant overhead.</p><p>Currently this is cycled by default. Note that cycling may be incorrect when the simulation timestep (e.g. <code>Week</code>) does not fit equally into the length of the time dimension (e.g. <code>Year</code>). This will reuire a <code>Cyclic</code> index mode in DimensionalData.jl in future to correct this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L25-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Grid" href="#DynamicGrids.Grid"><code>DynamicGrids.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Grid &lt;: ParameterSource

Grid{K}()
Grid(K::Symbol)</code></pre><p>Use grid with key <code>K</code> as a parameter source.</p><p>Implemented in rules with:</p><pre><code class="language-julia hljs">get(data, rule.myparam, I)</code></pre><p>And specified at rule construction with:</p><pre><code class="language-julia hljs">SomeRule(; myparam=Grid(:somegrid))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L167-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractDelay" href="#DynamicGrids.AbstractDelay"><code>DynamicGrids.AbstractDelay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDelay &lt;: ParameterSource</code></pre><p>Abstract supertype for <a href="#DynamicGrids.ParameterSource"><code>ParameterSource</code></a>s that use data from a grid with a time delay.</p><p>WARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Delay" href="#DynamicGrids.Delay"><code>DynamicGrids.Delay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Delay &lt;: AbstractDelay

Delay{K}(steps)</code></pre><p><code>Delay</code> allows using a <a href="#DynamicGrids.Grid"><code>Grid</code></a> from previous timesteps as a parameter source as a field in any <code>Rule</code> that uses <code>get</code> to retrieve it&#39;s parameters.</p><p>It must be coupled with an output that stores all frames, so that <code>@assert DynamicGrids.isstored(output) == true</code>.  With <a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a>s this may be acheived by using the keyword argument <code>store=true</code> when constructing the output object.</p><p><strong>Type Parameters</strong></p><ul><li><code>K::Symbol</code>: matching the name of a grid in <code>init</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>steps</code>: As a user supplied parameter, this is a multiple of the step size of the output   <code>tspan</code>. This is automatically replaced with an integer for each step. Used within the   code in a rule, it must be an <code>Int</code> number of frames, for performance.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">SomeRule(;
    someparam=Delay(:grid_a, Month(3))
    otherparam=1.075
)</code></pre><p>WARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L225-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Frame" href="#DynamicGrids.Frame"><code>DynamicGrids.Frame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Frame &lt;: AbstractDelay

Frame{K}(frame)</code></pre><p><code>Frame</code> allows using a <a href="#DynamicGrids.Grid"><code>Grid</code></a> from a specific previous timestep from within a rule, using <code>get</code>. It should only be used within rule code, not as a parameter.</p><p><strong>Type Parameter</strong></p><ul><li><code>K::Symbol</code>: matching the name of a grid in <code>init</code>.</li></ul><p><strong>Argument</strong></p><ul><li><code>frame::Int</code>: the exact frame number to use.</li></ul><p>WARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L320-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Lag" href="#DynamicGrids.Lag"><code>DynamicGrids.Lag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lag &lt;: AbstractDelay

Lag{K}(frames::Int)</code></pre><p><code>Lag</code> allows using a <a href="#DynamicGrids.Grid"><code>Grid</code></a> from a specific previous frame from within a rule, using <code>get</code>. It is similar to <a href="#DynamicGrids.Delay"><code>Delay</code></a>, but an integer amount of frames should be used, instead of a quantity related to the simulation <code>tspan</code>. The lower bound is the first frame.</p><p><strong>Type Parameter</strong></p><ul><li><code>K::Symbol</code>: matching the name of a grid in <code>init</code>.</li></ul><p><strong>Argument</strong></p><ul><li><code>frames::Int</code>: number of frames to lag by, 1 or larger.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">SomeRule(;
    someparam=Lag(:grid_a, Month(3))
    otherparam=1.075
)</code></pre><p>WARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L279-L307">source</a></section></article><h3 id="Custom-Rule-interface-and-helpers"><a class="docs-heading-anchor" href="#Custom-Rule-interface-and-helpers">Custom Rule interface and helpers</a><a id="Custom-Rule-interface-and-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Rule-interface-and-helpers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule" href="#DynamicGrids.applyrule"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">applyrule(data::AbstractSimData, rule::Rule{R,W}, state, index::Tuple{Int,Int}) -&gt; cell value(s)</code></pre><p>Apply a rule to the cell state and return values to write to the grid(s).</p><p>This is called in <code>maprule!</code> methods during the simulation, not by the user. Custom <code>Rule</code> implementations must define this method.</p><p><strong>Arguments</strong></p><ul><li><code>data</code> : <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a></li><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>state</code>: the value(s) of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates</li></ul><p>Returns the value(s) to be written to the current cell(s) of the grids specified by the <code>W</code> type parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule!" href="#DynamicGrids.applyrule!"><code>DynamicGrids.applyrule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">applyrule!(data::AbstractSimData, rule::{R,W}, state, index::Tuple{Int,Int}) -&gt; Nothing</code></pre><p>Apply a rule to the cell state and manually write to the grid data array. Used in all rules inheriting from <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a>.</p><p>This is called in internal <code>maprule!</code> methods during the simulation, not by the user. Custom <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a> implementations must define this method.</p><p>Only grids specified with the <code>W</code> type parameter will be writable from <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code> : <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a></li><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>state</code>: the value(s) of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates - <code>t</code>: the current time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.modifyrule" href="#DynamicGrids.modifyrule"><code>DynamicGrids.modifyrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modifyrule(rule::Rule, data::AbstractSimData) -&gt; Rule</code></pre><p>Precalculates rule fields at each timestep. Define this method if a <a href="#DynamicGrids.Rule"><code>Rule</code></a> has fields that need to be updated over time.</p><p><code>Rule</code>s are immutable (it&#39;s faster and works on GPU), so <code>modifyrule</code> is expected to return a new rule object with changes applied to it. Setfield.jl or Acessors.jl may help with updating the immutable struct.</p><p>The default behaviour is to return the existing rule without change. Updated rules are discarded after use, and the <code>rule</code> argument is always the original object passed in.</p><p><strong>Example</strong></p><p>We define a rule with a parameter that is the total sum of the grids current, and update it for each time-step using <code>modifyrule</code>.</p><p>This could be used to simulate top-down control e.g. a market mechanism in a geographic model that includes agricultural economics.</p><pre><code class="language-julia hljs">using DynamicGrids, Setfield
struct MySummedRule{R,W,T} &lt;: CellRule{R,W}
    gridsum::T
end
function modifyrule(rule::MySummedRule{R,W}, data::AbstractSimData) where {R,W}
    Setfield.@set rule.gridsum = sum(data[R])
end

# output
modifyrule (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L41-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isinferred" href="#DynamicGrids.isinferred"><code>DynamicGrids.isinferred</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isinferred(output::Output, ruleset::Ruleset)
isinferred(output::Output, rules::Rule...)</code></pre><p>Test if a custom rule is inferred and the return type is correct when <code>applyrule</code> or <code>applyrule!</code> is run.</p><p>Type-stability can give orders of magnitude improvements in performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/utils.jl#L17-L25">source</a></section></article><h3 id="Methods-and-objects-for-use-in-applyrule-and/or-modifyrule"><a class="docs-heading-anchor" href="#Methods-and-objects-for-use-in-applyrule-and/or-modifyrule">Methods and objects for use in <code>applyrule</code> and/or <code>modifyrule</code></a><a id="Methods-and-objects-for-use-in-applyrule-and/or-modifyrule-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-and-objects-for-use-in-applyrule-and/or-modifyrule" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(data::AbstractSimData, source::ParameterSource, I...)
get(data::AbstractSimData, source::ParameterSource, I::Union{Tuple,CartesianIndex})</code></pre><p>Allows parameters to be taken from a single value or a <a href="#DynamicGrids.ParameterSource"><code>ParameterSource</code></a> such as another <a href="#DynamicGrids.Grid"><code>Grid</code></a>, an <a href="#DynamicGrids.Aux"><code>Aux</code></a> array, or a <a href="#DynamicGrids.Delay"><code>Delay</code></a>.</p><p>Other <code>source</code> objects are used as-is without indexing with <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/parametersources.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isinbounds" href="#DynamicGrids.isinbounds"><code>DynamicGrids.isinbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isinbounds(data, I::Tuple) -&gt; Bool
isinbounds(data, I...) -&gt; Bool</code></pre><p>Check that a coordinate is within the grid, usually in <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a>.</p><p>Unlike <a href="#DynamicGrids.inbounds"><code>inbounds</code></a>, <a href="#DynamicGrids.BoundaryCondition"><code>BoundaryCondition</code></a> status is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L163-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.inbounds" href="#DynamicGrids.inbounds"><code>DynamicGrids.inbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inbounds(data::AbstractSimData, I::Tuple) -&gt; Tuple{NTuple{2,Int}, Bool}
inbounds(data::AbstractSimData, I...) -&gt; Tuple{NTuple{2,Int}, Bool}</code></pre><p>Check grid boundaries for a coordinate before writing in <a href="#DynamicGrids.SetCellRule"><code>SetCellRule</code></a>.</p><p>Returns a <code>Tuple</code> containing a coordinates <code>Tuple</code> and a <code>Bool</code> - <code>true</code> if the cell is inside the grid bounds, <code>false</code> if not.</p><p><a href="#DynamicGrids.BoundaryCondition"><code>BoundaryCondition</code></a> of type <a href="#DynamicGrids.Remove"><code>Remove</code></a> returns the coordinate and <code>false</code>  to skip coordinates that boundary outside of the grid.</p><p><a href="#DynamicGrids.Wrap"><code>Wrap</code></a> returns a tuple with the current position or it&#39;s wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L146-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ismasked" href="#DynamicGrids.ismasked"><code>DynamicGrids.ismasked</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ismasked(data, I...)</code></pre><p>Check if a cell is masked, using the <code>mask</code> array.</p><p>Used used internally during simulations to skip masked cells.</p><p>If <code>mask</code> was not passed to the <code>Output</code> constructor or <code>sim!</code> it defaults to <code>nothing</code> and <code>false</code> is always returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/utils.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.init" href="#DynamicGrids.init"><code>DynamicGrids.init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init(obj) -&gt; Union{AbstractArray,NamedTUple}</code></pre><p>Retrieve the mask from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.aux" href="#DynamicGrids.aux"><code>DynamicGrids.aux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aux(obj, [key])</code></pre><p>Retrieve auxilary data <code>NamedTuple</code> from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p><p>Given <code>key</code> specific data will be returned. <code>key</code> should be a <code>Val{:symbol}</code> for type stability and zero-cost access inside rules. <code>Symbol</code> will also work, but may be slow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L187-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.mask" href="#DynamicGrids.mask"><code>DynamicGrids.mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mask(obj) -&gt; AbstractArray</code></pre><p>Retrieve the mask from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.tspan" href="#DynamicGrids.tspan"><code>DynamicGrids.tspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tspan(obj) -&gt; AbstractRange</code></pre><p>Retrieve the time-span <code>AbstractRange</code> from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a> or <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.timestep" href="#DynamicGrids.timestep"><code>DynamicGrids.timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timestep(obj)</code></pre><p>Retrieve the timestep size from an <a href="#DynamicGrids.Output"><code>Output</code></a>, <a href="#DynamicGrids.Extent"><code>Extent</code></a>, <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> or <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p><p>This will be in whatever type/units you specify in <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L207-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currenttimestep" href="#DynamicGrids.currenttimestep"><code>DynamicGrids.currenttimestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">currenttimestep(simdata::AbstractSimData)</code></pre><p>Retrieve the current timestep from a <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p><p>This may be different from the <code>timestep</code>. If the timestep is <code>Month</code>, <code>currenttimestep</code> will return <code>Seconds</code> for the length of the specific month.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currenttime" href="#DynamicGrids.currenttime"><code>DynamicGrids.currenttime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">currenttime(simdata::AbstractSimData)</code></pre><p>Retrieve the current simulation time from a <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p><p>This will be in whatever type/units you specify in <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currentframe" href="#DynamicGrids.currentframe"><code>DynamicGrids.currentframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">currentframe(simdata::AbstractSimData) -&gt; Int</code></pre><p>Retrieve the current simulation frame a <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractSimData" href="#DynamicGrids.AbstractSimData"><code>DynamicGrids.AbstractSimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSimData</code></pre><p>Supertype for simulation data objects. Thes hold <a href="#DynamicGrids.GridData"><code>GridData</code></a>,  <a href="#DynamicGrids.SimSettings"><code>SimSettings</code></a> and other objects needed to run the simulation,  and potentially required from within rules.</p><p>An <code>AbstractSimData</code> object is accessable in <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> as the first parameter.</p><p>Multiple grids can be indexed into using their key if you need to read from arbitrary locations:</p><pre><code class="language-julia hljs">funciton applyrule(data::AbstractSimData, rule::SomeRule{Tuple{A,B}},W}, (a, b), I) where {A,B,W}
    grid_a = data[A]
    grid_b = data[B]
    ...
end</code></pre><p>In single-grid simulations <code>AbstractSimData</code> objects can be indexed directly as  if they are a <code>Matrix</code>.</p><p><strong>Methods</strong></p><ul><li><code>currentframe(data)</code>: get the current frame number, an <code>Int</code></li><li><code>currenttime(data)</code>: the current frame time, which <code>isa eltype(tspan)</code></li><li><code>aux(data, args...)</code>: get the <code>aux</code> data <code>NamedTuple</code>, or <code>Nothing</code>.   adding a <code>Symbol</code> or <code>Val{:symbol}</code> argument will get a field of aux.</li><li><code>tspan(data)</code>: get the simulation time span, an <code>AbstractRange</code>.</li><li><code>timestep(data)</code>: get the simulaiton time step.</li><li><code>boundary(data)</code> : returns the <a href="#DynamicGrids.BoundaryCondition"><code>BoundaryCondition</code></a> - <code>Remove</code> or <code>Wrap</code>.</li><li><code>padval(data)</code> : returns the value to use as grid border padding.</li></ul><p>These are also available, but you probably shouldn&#39;t use them and their behaviour is not guaranteed in furture versions. Using them will also mean a rule is useful  only in specific contexts, which is discouraged.</p><ul><li><code>settings(data)</code>: get the simulaitons <a href="#DynamicGrids.SimSettings"><code>SimSettings</code></a> object.</li><li><code>extent(data)</code> : get the simulation <a href="#DynamicGrids.AbstractExtent"><code>AbstractExtent</code></a> object.</li><li><code>init(data)</code> : get the simulation init <code>AbstractArray</code>/<code>NamedTuple</code></li><li><code>mask(data)</code> : get the simulation mask <code>AbstractArray</code></li><li><code>source(data)</code> : get the <code>source</code> grid that is being read from.</li><li><code>dest(data)</code> : get the <code>dest</code> grid that is being written to.</li><li><code>radius(data)</code> : returns the <code>Int</code> radius used on the grid,   which is also the amount of border padding.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/simulationdata.jl#L2-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SimData" href="#DynamicGrids.SimData"><code>DynamicGrids.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimData &lt;: AbstractSimData

SimData(extent::AbstractExtent, ruleset::AbstractRuleset)</code></pre><p>Simulation dataset to hold all intermediate arrays, timesteps and frame numbers for the current frame of the simulation.</p><p>Additional methods not found in <a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a>:</p><ul><li><code>rules(d::SimData)</code> : get the simulation rules.</li><li><code>ruleset(d::SimData)</code> : get the simulation <a href="#DynamicGrids.AbstractRuleset"><code>AbstractRuleset</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/simulationdata.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RuleData" href="#DynamicGrids.RuleData"><code>DynamicGrids.RuleData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RuleData &lt;: AbstractSimData

RuleData(extent::AbstractExtent, settings::SimSettings)</code></pre><p><a href="#DynamicGrids.AbstractSimData"><code>AbstractSimData</code></a> object that is passed to rules.  Basically a trimmed-down version of <a href="#DynamicGrids.SimData"><code>SimData</code></a>.</p><p>The simplified object actually passed to rules with the current design.</p><p>Passing a smaller object than <code>SimData</code> to rules leads to faster GPU compilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/simulationdata.jl#L203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GridData" href="#DynamicGrids.GridData"><code>DynamicGrids.GridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridData &lt;: StaticArray</code></pre><p>Simulation data specific to a single grid.</p><p>These behave like arrays, but contain both source and  destination arrays as simulations need separate read and  write steps to maintain independence between cells.</p><p><code>GridData</code> objects also contain other data and settings needed for optimisations.</p><p><strong>Type parameters</strong></p><ul><li><code>S</code>: grid size type tuple</li><li><code>R</code>: grid padding radius </li><li><code>T</code>: grid data type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/grid.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ReadableGridData" href="#DynamicGrids.ReadableGridData"><code>DynamicGrids.ReadableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReadableGridData &lt;: GridData

ReadableGridData(grid::GridData)
ReadableGridData{S,R}(init::AbstractArray, mask, opt, boundary, padval)</code></pre><p><a href="#DynamicGrids.GridData"><code>GridData</code></a> object passed to rules for reading only. Reads are always from the <code>source</code> array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/grid.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.WritableGridData" href="#DynamicGrids.WritableGridData"><code>DynamicGrids.WritableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WritableGridData &lt;: GridData

WritableGridData(grid::GridData)</code></pre><p><a href="#DynamicGrids.GridData"><code>GridData</code></a> objet passed to rules as write grids, and can be written  to directly as an array, or preferably using <code>add!</code> etc. All writes handle  updates to <code>SparseOpt()</code> and writing to the correct source/dest array.</p><p>Reads are always from the <code>source</code> array, while writes are always to the  <code>dest</code> array. This is because rules application must not be sequential  between cells - the order of cells the rule is applied to does not matter.  This means that using e.g. <code>+=</code> is not supported. Instead use <code>add!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/grid.jl#L216-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractSimSettings" href="#DynamicGrids.AbstractSimSettings"><code>DynamicGrids.AbstractSimSettings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSimSettings</code></pre><p>Abstract supertype for <a href="#DynamicGrids.SimSettings"><code>SimSettings</code></a> object and variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/settings.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SimSettings" href="#DynamicGrids.SimSettings"><code>DynamicGrids.SimSettings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimSettings &lt;: AbstractSimSettings</code></pre><p>Holds settings for the simulation, inside a <code>Ruleset</code> or <code>SimData</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/settings.jl#L8-L12">source</a></section></article><h2 id="Neighborhoods"><a class="docs-heading-anchor" href="#Neighborhoods">Neighborhoods</a><a id="Neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.Neighborhood" href="#DynamicGrids.Neighborhoods.Neighborhood"><code>DynamicGrids.Neighborhoods.Neighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Neighborhood</code></pre><p>Neighborhoods define the pattern of surrounding cells in the &quot;neighborhood&quot; of the current cell. The <code>neighbors</code> function returns the surrounding cells as an iterable.</p><p>The main kinds of neighborhood are demonstrated below:</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/Neighborhoods.png" alt="Neighborhoods"/></p><p>Neighborhoods can be used in <code>NeighborhoodRule</code> and <code>SetNeighborhoodRule</code> - the same shapes with different purposes. In a <code>NeighborhoodRule</code> the neighborhood specifies which cells around the current cell are returned as an iterable from the <code>neighbors</code> function. These can be counted, summed, compared, or multiplied with a kernel in an <code>AbstractKernelNeighborhood</code>, using <a href="#DynamicGrids.Neighborhoods.kernelproduct"><code>kernelproduct</code></a>.</p><p>In <code>SetNeighborhoodRule</code> neighborhoods give the locations of cells around the central cell, as [<code>offsets</code>] and absolute <a href="#DynamicGrids.Neighborhoods.positions"><code>positions</code></a> around the index of each neighbor. These can then be written to manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.Moore" href="#DynamicGrids.Neighborhoods.Moore"><code>DynamicGrids.Neighborhoods.Moore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Moore &lt;: Neighborhood

Moore(radius::Int=1; ndims=2)
Moore(; radius=1, ndims=2)
Moore{R}(; ndims=2)
Moore{R,N}()</code></pre><p>Moore neighborhoods define the neighborhood as all cells within a horizontal or vertical distance of the central cell. The central cell is omitted.</p><p>Radius <code>R = 1</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2
 
 ▄ ▄     █▀█
         ▀▀▀</code></pre><p>Radius <code>R = 2</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

        █████
▀▀ ▀▀   ██▄██
        ▀▀▀▀▀</code></pre><p>Using <code>R</code> and <code>N</code> type parameters removes runtime cost of generating the neighborhood, compated to passing arguments/keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L155-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.VonNeumann" href="#DynamicGrids.Neighborhoods.VonNeumann"><code>DynamicGrids.Neighborhoods.VonNeumann</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VonNeumann(radius=1; ndims=2) -&gt; Positional
VonNeumann(; radius=1, ndims=2) -&gt; Positional
VonNeumann{R,N}() -&gt; Positional</code></pre><p>A Von Neuman neighborhood is a damond-shaped, omitting the central cell:</p><p>Radius <code>R = 1</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

 ▄ ▄     ▄▀▄
          ▀</code></pre><p>Radius <code>R = 2</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

         ▄█▄
▀▀ ▀▀   ▀█▄█▀
          ▀</code></pre><p>In 1 dimension it is identical to <a href="#DynamicGrids.Neighborhoods.Moore"><code>Moore</code></a>.</p><p>Using <code>R</code> and <code>N</code> type parameters removes runtime cost of generating the neighborhood, compated to passing arguments/keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L208-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.Window" href="#DynamicGrids.Neighborhoods.Window"><code>DynamicGrids.Neighborhoods.Window</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Window &lt;: Neighborhood

Window(; radius=1, ndims=2)
Window{R}(; ndims=2)
Window{R,N}()</code></pre><p>A neighboorhood of radius R that includes the central cell.</p><p>Radius <code>R = 1</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2
        
 ▄▄▄     ███
         ▀▀▀</code></pre><p>Radius <code>R = 2</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

        █████
▀▀▀▀▀   █████
        ▀▀▀▀▀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L265-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.AbstractPositionalNeighborhood" href="#DynamicGrids.Neighborhoods.AbstractPositionalNeighborhood"><code>DynamicGrids.Neighborhoods.AbstractPositionalNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPositionalNeighborhood &lt;: Neighborhood</code></pre><p>Positional neighborhoods are tuples of coordinates that are specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L405-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.Positional" href="#DynamicGrids.Neighborhoods.Positional"><code>DynamicGrids.Neighborhoods.Positional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Positional &lt;: AbstractPositionalNeighborhood

Positional(coord::Tuple{Vararg{Int}}...)
Positional(offsets::Tuple{Tuple{Vararg{Int}}})
Positional{O}()</code></pre><p>Neighborhoods that can take arbitrary shapes by specifying each coordinate, as <code>Tuple{Int,Int}</code> of the row/column distance (positive and negative) from the central point.</p><p>The neighborhood radius is calculated from the most distant coordinate. For simplicity the window read from the main grid is a square with sides <code>2r + 1</code> around the central point.</p><p>The dimensionality <code>N</code> of the neighborhood is taken from the length of the first coordinate, e.g. <code>1</code>, <code>2</code> or <code>3</code>.</p><p>Example radius <code>R = 1</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

 ▄▄      ▀▄
          ▀</code></pre><p>Example radius <code>R = 2</code>:</p><pre><code class="nohighlight hljs">N = 1   N = 2

         ▄▄
 ▀ ▀▀   ▀███
           ▀</code></pre><p>Using the <code>O</code> parameter e.g. <code>Positional{((1, 2), (1, 1))}()</code> removes any runtime cost of generating the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L417-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.LayeredPositional" href="#DynamicGrids.Neighborhoods.LayeredPositional"><code>DynamicGrids.Neighborhoods.LayeredPositional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LayeredPositional &lt;: AbstractPositional

LayeredPositional(layers::Positional...)</code></pre><p>Sets of <a href="#DynamicGrids.Neighborhoods.Positional"><code>Positional</code></a> neighborhoods that can have separate rules for each set.</p><p><code>neighbors</code> for <code>LayeredPositional</code> returns a tuple of iterators for each neighborhood layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L495-L504">source</a></section></article><h3 id="Methods-for-use-with-neighborhood-rules-and-neighborhoods"><a class="docs-heading-anchor" href="#Methods-for-use-with-neighborhood-rules-and-neighborhoods">Methods for use with neighborhood rules and neighborhoods</a><a id="Methods-for-use-with-neighborhood-rules-and-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-use-with-neighborhood-rules-and-neighborhoods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.neighborhood" href="#DynamicGrids.Neighborhoods.neighborhood"><code>DynamicGrids.Neighborhoods.neighborhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighborhood(x) -&gt; Neighborhood</code></pre><p>Returns a neighborhood object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.radius" href="#DynamicGrids.Neighborhoods.radius"><code>DynamicGrids.Neighborhoods.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radius(rule, [key]) -&gt; Int</code></pre><p>Return the radius of a rule or ruleset if it has one, otherwise zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.distances" href="#DynamicGrids.Neighborhoods.distances"><code>DynamicGrids.Neighborhoods.distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distances(hood::Neighborhood)</code></pre><p>Get the center-to-center distance of each neighborhood position from the central cell, so that horizontally or vertically adjacent cells have a distance of <code>1.0</code>, and a diagonally adjacent cell has a distance of <code>sqrt(2.0)</code>.</p><p>Vales are calculated at compile time, so <code>distances</code> can be used inside rules with little overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L98-L107">source</a></section></article><p>Useful with <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.neighbors" href="#DynamicGrids.Neighborhoods.neighbors"><code>DynamicGrids.Neighborhoods.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbors(x::Union{Neighborhood,NeighborhoodRule}}) -&gt; iterable</code></pre><p>Returns an indexable iterator for all cells in the neighborhood, either a <code>Tuple</code> of values or a range.</p><p>Custom <code>Neighborhood</code>s must define this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L61-L68">source</a></section></article><p>Useful with <a href="#DynamicGrids.SetNeighborhoodRule"><code>SetNeighborhoodRule</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.positions" href="#DynamicGrids.Neighborhoods.positions"><code>DynamicGrids.Neighborhoods.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">positions(x::Union{Neighborhood,NeighborhoodRule}}, cellindex::Tuple) -&gt; iterable</code></pre><p>Returns an indexable iterable, over all cells as <code>Tuple</code>s of each index in the main array. Useful in <code>SetNeighborhoodRule</code> for setting neighborhood values, or for getting values in an Aux array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.offsets" href="#DynamicGrids.Neighborhoods.offsets"><code>DynamicGrids.Neighborhoods.offsets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offsets(x) -&gt; iterable</code></pre><p>Returns an indexable iterable over all cells, containing <code>Tuple</code>s of the index offset from the central cell.</p><p>Custom <code>Neighborhood</code>s must define this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L74-L81">source</a></section></article><h3 id="Convolution-kernel-neighborhoods"><a class="docs-heading-anchor" href="#Convolution-kernel-neighborhoods">Convolution kernel neighborhoods</a><a id="Convolution-kernel-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution-kernel-neighborhoods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.AbstractKernelNeighborhood" href="#DynamicGrids.Neighborhoods.AbstractKernelNeighborhood"><code>DynamicGrids.Neighborhoods.AbstractKernelNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractKernelNeighborhood &lt;: Neighborhood</code></pre><p>Abstract supertype for kernel neighborhoods.</p><p>These can wrap any other neighborhood object, and include a kernel of the same length and positions as the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L317-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.Kernel" href="#DynamicGrids.Neighborhoods.Kernel"><code>DynamicGrids.Neighborhoods.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Kernel &lt;: AbstractKernelNeighborhood

Kernel(neighborhood, kernel)</code></pre><p>Wrap any other neighborhood object, and includes a kernel of the same length and positions as the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L375-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.kernel" href="#DynamicGrids.Neighborhoods.kernel"><code>DynamicGrids.Neighborhoods.kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel(hood::AbstractKernelNeighborhood) =&gt; iterable</code></pre><p>Returns the kernel object, an array or iterable matching the length of the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.kernelproduct" href="#DynamicGrids.Neighborhoods.kernelproduct"><code>DynamicGrids.Neighborhoods.kernelproduct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernelproduct(rule::NeighborhoodRule})
kernelproduct(hood::AbstractKernelNeighborhood)
kernelproduct(hood::Neighborhood, kernel)</code></pre><p>Returns the vector dot product of the neighborhood and the kernel, although differing from <code>dot</code> in that the dot product is not take for vector members of the neighborhood - they are treated as scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L42-L50">source</a></section></article><h3 id="Low-level-use-of-neighborhoods"><a class="docs-heading-anchor" href="#Low-level-use-of-neighborhoods">Low level use of neighborhoods</a><a id="Low-level-use-of-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-use-of-neighborhoods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.readwindow" href="#DynamicGrids.Neighborhoods.readwindow"><code>DynamicGrids.Neighborhoods.readwindow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_readwindow(hood::Neighborhood, A::AbstractArray, I) =&gt; SArray</code></pre><p>Get a single window square from an array, as an <code>SArray</code>, checking bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L561-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.unsafe_readwindow" href="#DynamicGrids.Neighborhoods.unsafe_readwindow"><code>DynamicGrids.Neighborhoods.unsafe_readwindow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_readwindow(hood::Neighborhood, A::AbstractArray, I) =&gt; SArray</code></pre><p>Get a single window square from an array, as an <code>SArray</code>, without checking bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L575-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.updatewindow" href="#DynamicGrids.Neighborhoods.updatewindow"><code>DynamicGrids.Neighborhoods.updatewindow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updatewindow(x, A::AbstractArray, I...) =&gt; Neighborhood</code></pre><p>Set the window of a neighborhood to values from the array A around index <code>I</code>.</p><p>Bounds checks will reduce performance, aim to use <code>unsafe_setwindow</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L641-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.unsafe_updatewindow" href="#DynamicGrids.Neighborhoods.unsafe_updatewindow"><code>DynamicGrids.Neighborhoods.unsafe_updatewindow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_setwindow(x, A::AbstractArray, I...) =&gt; Neighborhood</code></pre><p>Set the window of a neighborhood to values from the array A around index <code>I</code>.</p><p>No bounds checks occur, ensure that A has padding of at least the neighborhood radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L652-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.pad_axes" href="#DynamicGrids.Neighborhoods.pad_axes"><code>DynamicGrids.Neighborhoods.pad_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pad_axes(A, hood::Neighborhood{R})
pad_axes(A, radius::Int)</code></pre><p>Add padding to axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L720-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.unpad_axes" href="#DynamicGrids.Neighborhoods.unpad_axes"><code>DynamicGrids.Neighborhoods.unpad_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unpad_axes(A, hood::Neighborhood{R})
unpad_axes(A, radius::Int)</code></pre><p>Remove padding from axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L732-L737">source</a></section></article><h3 id="Generic-neighborhood-applicators"><a class="docs-heading-anchor" href="#Generic-neighborhood-applicators">Generic neighborhood applicators</a><a id="Generic-neighborhood-applicators-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-neighborhood-applicators" title="Permalink"></a></h3><p>These can be used without the full simulation mechanisms, like <code>broadcast</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.broadcast_neighborhood" href="#DynamicGrids.Neighborhoods.broadcast_neighborhood"><code>DynamicGrids.Neighborhoods.broadcast_neighborhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">broadcast_neighborhood(f, hood::Neighborhood, As...)</code></pre><p>Simple neighborhood application, where <code>f</code> is passed  each neighborhood in <code>A</code>, returning a new array.</p><p>The result is smaller than <code>A</code> on all sides, by the neighborhood radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L663-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhoods.broadcast_neighborhood!" href="#DynamicGrids.Neighborhoods.broadcast_neighborhood!"><code>DynamicGrids.Neighborhoods.broadcast_neighborhood!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">broadcast_neighborhood!(f, hood::Neighborhood{R}, dest, sources...)</code></pre><p>Simple neighborhood broadcast where <code>f</code> is passed each neighborhood of <code>src</code> (except padding), writing the result of <code>f</code> to <code>dest</code>.</p><p><code>dest</code> must either be smaller than <code>src</code> by the neighborhood radius on all sides, or be the same size, in which case it is assumed to also be padded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/Neighborhoods/Neighborhoods.jl#L680-L688">source</a></section></article><h2 id="Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule"><a class="docs-heading-anchor" href="#Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule">Atomic methods for SetCellRule and SetNeighborhoodRule</a><a id="Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-methods-for-SetCellRule-and-SetNeighborhoodRule" title="Permalink"></a></h2><p>Using these methods to modify grid values ensures cell independence, and also prevent race conditions with <a href="#DynamicGrids.ThreadedCPU"><code>ThreadedCPU</code></a> or [<code>CuGPU</code>].</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.add!" href="#DynamicGrids.add!"><code>DynamicGrids.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add!(data::WritableGridData, x, I...)</code></pre><p>Add the value <code>x</code> to a grid cell.</p><p><strong>Example useage</strong></p><pre><code class="language-julia hljs">using DynamicGrids
rule = SetCell{:a}() do data, a, cellindex
    dest, is_inbounds = inbounds(data, (jump .+ cellindex)...)

    # Update spotted cell if it&#39;s on the grid
    is_inbounds &amp;&amp; add!(data[:a], state, dest...)
end

# output
SetCell{:a,:a}(
    f = var&quot;#1#2&quot;
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L77-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sub!" href="#DynamicGrids.sub!"><code>DynamicGrids.sub!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sub!(data::WritableGridData, x, I...)</code></pre><p>Subtract the value <code>x</code> from a grid cell. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.min!" href="#DynamicGrids.min!"><code>DynamicGrids.min!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min!(data::WritableGridData, x, I...)</code></pre><p>Set a gride cell to the minimum of <code>x</code> and the current value. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.max!" href="#DynamicGrids.max!"><code>DynamicGrids.max!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max!(data::WritableGridData, x, I...)</code></pre><p>Set a gride cell to the maximum of <code>x</code> and the current value. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.and!" href="#DynamicGrids.and!"><code>DynamicGrids.and!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">and!(data::WritableGridData, x, I...)
and!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>c &amp; x</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.or!" href="#DynamicGrids.or!"><code>DynamicGrids.or!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">or!(data::WritableGridData, x, I...)
or!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>c | x</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.xor!" href="#DynamicGrids.xor!"><code>DynamicGrids.xor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">xor!(data::WritableGridData, x, I...)
xor!(A::AbstractArray, x, I...)</code></pre><p>Set the grid cell <code>c</code> to <code>xor(c, x)</code>. See <code>add!</code> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/interface.jl#L138-L143">source</a></section></article><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><h3 id="Output-Types-and-Constructors"><a class="docs-heading-anchor" href="#Output-Types-and-Constructors">Output Types and Constructors</a><a id="Output-Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Output-Types-and-Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Output" href="#DynamicGrids.Output"><code>DynamicGrids.Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Output</code></pre><p>Abstract supertype for simulation outputs.</p><p>Outputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherwise manipulate the simulation grids to improve performance, reduce memory overheads or similar.</p><p>Simulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/output.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ArrayOutput" href="#DynamicGrids.ArrayOutput"><code>DynamicGrids.ArrayOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArrayOutput &lt;: Output

ArrayOutput(init; tspan::AbstractRange, [aux, mask, padval])</code></pre><p>A simple output that stores each step of the simulation in a vector of arrays.</p><p><strong>Arguments</strong></p><ul><li><code>init</code>: initialisation <code>AbstractArrayArray</code> or <code>NamedTuple</code> of <code>AbstractArrayArray</code>.</li></ul><p><strong>Keywords (passed to <a href="#DynamicGrids.Extent"><code>Extent</code></a>)</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/array.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ResultOutput" href="#DynamicGrids.ResultOutput"><code>DynamicGrids.ResultOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResultOutput &lt;: Output

ResultOutput(init; tspan::AbstractRange, kw...)</code></pre><p>A simple output that only stores the final result, not intermediate frames.</p><p><strong>Arguments</strong></p><ul><li><code>init</code>: initialisation <code>Array</code> or <code>NamedTuple</code> of <code>Array</code></li></ul><p><strong>Keywords (passed to <a href="#DynamicGrids.Extent"><code>Extent</code></a>)</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/array.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.TransformedOutput" href="#DynamicGrids.TransformedOutput"><code>DynamicGrids.TransformedOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformedOutput(f, init; tspan::AbstractRange, kw...)</code></pre><p>An output that stores the result of some function <code>f</code> of the grid/s.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: a function or functor that accepts an <code>AbstractArray</code> or <code>NamedTuple</code> of   <code>AbstractArray</code> with names matching <code>init</code>. The <code>AbstractArray</code> will be a view into    the grid the same size as the init grids, removing any padding that has been added.</li><li><code>init</code>: initialisation <code>Array</code> or <code>NamedTuple</code> of <code>Array</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>tspan</code>: <code>AbstractRange</code> timespan for the simulation</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>get(data, Aux(:key), I...)</code>    to access from a <code>Rule</code> in a type-stable way.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is <code>zero(eltype(init))</code>.</li></ul><p>WARNING: This feature is experimental. It may change in future versions,  and may not be 100% reliable in all cases. Please file github issues if problems occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/transformed.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicOutput" href="#DynamicGrids.GraphicOutput"><code>DynamicGrids.GraphicOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphicOutput &lt;: Output</code></pre><p>Abstract supertype for <a href="#DynamicGrids.Output"><code>Output</code></a>s that display the simulation frames.</p><p>All <code>GraphicOutputs</code> must have a <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> object and define a <a href="#DynamicGrids.showframe"><code>showframe</code></a> method.</p><p>See <a href="#DynamicGrids.REPLOutput"><code>REPLOutput</code></a> for an example.</p><p><strong>User Arguments for all <code>GraphicOutput</code>:</strong></p><ul><li><code>init</code>: initialisation <code>AbstractArray</code> or <code>NamedTuple</code> of <code>AbstractArray</code></li></ul><p><strong>Minimum user keywords for all <code>GraphicOutput</code>:</strong></p><p><strong><a href="#DynamicGrids.Extent"><code>Extent</code></a> keywords:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> keywords:</strong></p><ul><li><code>fps::Real</code>: Frames per second.</li><li><code>store::Bool</code>: Whether to store frames like <code>ArrayOutput</code> or to disgard   them after visualising. Very long simulation runs may fill available    memory when <code>store=true</code>.</li></ul><p>A <code>GraphicConfig</code> object can be also passed to the <code>graphicconfig</code> keyword, and other keywords will be ignored.</p><p><strong>Internal keywords for constructors of objects extending <code>GraphicOutput</code>:</strong></p><p>The default constructor will generate these objects and pass them to the inheriting  object constructor, which must accept the following keywords:</p><ul><li><code>frames</code>: a <code>Vector</code> of simulation frames (<code>NamedTuple</code> or <code>Array</code>). </li><li><code>running</code>: A <code>Bool</code>.</li><li><code>extent</code> an <a href="#DynamicGrids.Extent"><code>Extent</code></a> object.</li><li><code>graphicconfig</code> a <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a>object.</li></ul><p>Users can also pass in these entire objects if required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/graphic.jl#L54-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.REPLOutput" href="#DynamicGrids.REPLOutput"><code>DynamicGrids.REPLOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">REPLOutput &lt;: GraphicOutput

REPLOutput(init; tspan, kw...)</code></pre><p>An output that is displayed directly in the REPL. It can either store or discard simulation frames.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation <code>AbstractArrayArray</code> or <code>NamedTuple</code> of <code>AbstractArrayArray</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>color</code>: a color from Crayons.jl</li><li><code>cutoff</code>: <code>Real</code> cutoff point to display a full or empty cell. Default is <code>0.5</code></li><li><code>style</code>: <code>CharStyle</code> <code>Block()</code> or <code>Braile()</code> printing. <code>Braile</code> uses 1/4 the screen space of <code>Block</code>.</li></ul><p><strong><a href="#DynamicGrids.Extent"><code>Extent</code></a> keywords:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> keywords:</strong></p><ul><li><code>fps::Real</code>: Frames per second.</li><li><code>store::Bool</code>: Whether to store frames like <code>ArrayOutput</code> or to disgard   them after visualising. Very long simulation runs may fill available    memory when <code>store=true</code>.</li></ul><p>A <code>GraphicConfig</code> object can be also passed to the <code>graphicconfig</code> keyword, and other keywords will be ignored.</p><p>e <code>GraphicConfig</code> object can be also passed to the <code>graphicconfig</code> keyword, and other keywords will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/repl.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageOutput" href="#DynamicGrids.ImageOutput"><code>DynamicGrids.ImageOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageOutput &lt;: GraphicOutput</code></pre><p>Abstract supertype for Graphic outputs that display the simulation frames as RGB images.</p><p><code>ImageOutput</code>s must have <a href="#DynamicGrids.Extent"><code>Extent</code></a>, <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a>  and <a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> components, and define a <a href="#DynamicGrids.showimage"><code>showimage</code></a> method.</p><p>See <a href="#DynamicGrids.GifOutput"><code>GifOutput</code></a> for an example.</p><p>Although the majority of the code is maintained here to enable sharing and reuse, most <code>ImageOutput</code>s are not provided in DynamicGrids.jl to avoid heavy dependencies on graphics libraries. See <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> and <a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> for implementations.</p><p><strong>User Arguments for all <code>GraphicOutput</code>:</strong></p><ul><li><code>init</code>: initialisation <code>AbstractArray</code> or <code>NamedTuple</code> of <code>AbstractArray</code></li></ul><p><strong>Minimum user keywords for all <code>ImageOutput</code>:</strong></p><p><strong><a href="#DynamicGrids.Extent"><code>Extent</code></a> keywords:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> keywords:</strong></p><ul><li><code>fps::Real</code>: Frames per second.</li><li><code>store::Bool</code>: Whether to store frames like <code>ArrayOutput</code> or to disgard   them after visualising. Very long simulation runs may fill available    memory when <code>store=true</code>.</li></ul><p>A <code>GraphicConfig</code> object can be also passed to the <code>graphicconfig</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> keywords:</strong></p><ul><li><p><code>minval</code>: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>0</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>maxval</code>: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>1</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>font</code>: <code>String</code> name of font to search for. A default will be guessed.</p></li><li><p><code>text</code>: <code>TextConfig()</code> or <code>nothing</code> for no text. Default is <code>TextConfig(; font=font)</code>.</p></li><li><p><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.ObjectScheme"><code>ObjectScheme</code></a> or object that defines   <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code>   using <code>ARGB32(val)</code>.</p></li><li><p><code>zerocolor</code>: a <code>Col</code> to use when values are zero, or <code>nothing</code> to ignore.</p></li><li><p><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</p></li><li><p><code>renderer</code>: <a href="#DynamicGrids.Renderer"><code>Renderer</code></a> like <a href="#DynamicGrids.Image"><code>Image</code></a> or <a href="#DynamicGrids.Layout"><code>Layout</code></a>. Will be detected    automatically, and use <code>scheme</code>, <code>zerocolor</code> and <code>maskcolor</code> keywords if available.   Can be a <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array. </p></li></ul><p>An <code>ImageConfig</code> object can be also passed to the <code>imageconfig</code> keyword, and other keywords will be ignored.</p><p><strong>Internal keywords for constructors of objects extending <code>GraphicOutput</code>:</strong></p><p>The default constructor will generate these objects and pass them to the inheriting  object constructor, which must accept the following keywords:</p><ul><li><code>frames</code>: a <code>Vector</code> of simulation frames (<code>NamedTuple</code> or <code>Array</code>). </li><li><code>running</code>: A <code>Bool</code>.</li><li><code>extent</code> an <a href="#DynamicGrids.Extent"><code>Extent</code></a> object.</li><li><code>graphicconfig</code> a <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a>object.</li><li><code>imageconfig</code> a <a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a>object.</li></ul><p>Users can also pass in these entire objects if required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/image.jl#L65-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GifOutput" href="#DynamicGrids.GifOutput"><code>DynamicGrids.GifOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GifOutput &lt;: ImageOutput

GifOutput(init; filename, tspan, kw...)</code></pre><p>Output that stores the simulation as images and saves a Gif file on completion.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: initialisation <code>AbstractArrayArray</code> or <code>NamedTuple</code> of <code>AbstractArrayArray</code>.</li></ul><p><strong>Keywords</strong></p><p>Storing the gif:</p><ul><li><code>filename</code>: File path to save the gif file to.</li></ul><p><strong><a href="#DynamicGrids.Extent"><code>Extent</code></a> keywords:</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul><p>An <code>Extent</code> object can be also passed to the <code>extent</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> keywords:</strong></p><ul><li><code>fps::Real</code>: Frames per second.</li><li><code>store::Bool</code>: Whether to store frames like <code>ArrayOutput</code> or to disgard   them after visualising. Very long simulation runs may fill available    memory when <code>store=true</code>.</li></ul><p>A <code>GraphicConfig</code> object can be also passed to the <code>graphicconfig</code> keyword, and other keywords will be ignored.</p><p><strong><a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> keywords:</strong></p><ul><li><p><code>minval</code>: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>0</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>maxval</code>: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>1</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>font</code>: <code>String</code> name of font to search for. A default will be guessed.</p></li><li><p><code>text</code>: <code>TextConfig()</code> or <code>nothing</code> for no text. Default is <code>TextConfig(; font=font)</code>.</p></li><li><p><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.ObjectScheme"><code>ObjectScheme</code></a> or object that defines   <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code>   using <code>ARGB32(val)</code>.</p></li><li><p><code>zerocolor</code>: a <code>Col</code> to use when values are zero, or <code>nothing</code> to ignore.</p></li><li><p><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</p></li><li><p><code>renderer</code>: <a href="#DynamicGrids.Renderer"><code>Renderer</code></a> like <a href="#DynamicGrids.Image"><code>Image</code></a> or <a href="#DynamicGrids.Layout"><code>Layout</code></a>. Will be detected    automatically, and use <code>scheme</code>, <code>zerocolor</code> and <code>maskcolor</code> keywords if available.   Can be a <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array. </p></li></ul><p>An <code>ImageConfig</code> object can be also passed to the <code>imageconfig</code> keyword, and other keywords will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/gif.jl#L44-L61">source</a></section></article><h3 id="Renderers"><a class="docs-heading-anchor" href="#Renderers">Renderers</a><a id="Renderers-1"></a><a class="docs-heading-anchor-permalink" href="#Renderers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Renderer" href="#DynamicGrids.Renderer"><code>DynamicGrids.Renderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Renderer</code></pre><p>Abstract supertype for objects that convert a frame of the simulation into an <code>ARGB32</code> image for display. Frames may be a single grid or a <code>NamedTuple</code> of multiple grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/render.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SingleGridRenderer" href="#DynamicGrids.SingleGridRenderer"><code>DynamicGrids.SingleGridRenderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleGridRenderer &lt;: Renderer</code></pre><p>Abstract supertype for <a href="#DynamicGrids.Renderer"><code>Renderer</code></a>s that convert a single grid into an image array.</p><p>The first grid will be displayed if a <code>SingleGridRenderer</code> is used with a <code>NamedTuple</code> of grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/render.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Image" href="#DynamicGrids.Image"><code>DynamicGrids.Image</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Image &lt;: SingleGridRenderer

Image(f=identity; scheme=ObjectScheme(), zerocolor=nothing, maskcolor=nothing)</code></pre><p>Converts output grids to a colorsheme.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: a function to convert value from the grid to <code>Real</code>   oran <code>RGB</code>. <code>Real</code> will be scaled by minval/maxval and be colored by the <code>scheme</code>.   <code>RGB</code> is used directly in the output. This is useful for grids of complex objects,   but not necessary for numbers. The default is <code>identity</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.ObjectScheme"><code>ObjectScheme</code></a> or object that defines   <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code>   using <code>ARGB32(val)</code>.</li><li><code>zerocolor</code>: a <code>Col</code> to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/render.jl#L101-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.MultiGridRenderer" href="#DynamicGrids.MultiGridRenderer"><code>DynamicGrids.MultiGridRenderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiGridRenderer &lt;: Renderer</code></pre><p>Abstract type for <code>Renderer</code>s that convert a frame containing multiple grids into a single image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/render.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Layout" href="#DynamicGrids.Layout"><code>DynamicGrids.Layout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Layout &lt;: MultiGridRenderer

Layout(layout::Array, renderer::Matrix)</code></pre><p>Layout allows displaying multiple grids in a block layout, by specifying a layout matrix and a list of <a href="#DynamicGrids.Image"><code>Image</code></a>s to be run for each.</p><p><strong>Arguments</strong></p><ul><li><code>layout</code>: A <code>Vector</code> or <code>Matrix</code> containing the keys or numbers of grids in the   locations to display them. <code>nothing</code>, <code>missing</code> or <code>0</code> values will be skipped.</li><li><code>renderers</code>: <code>Vector/Matrix</code> of <a href="#DynamicGrids.Image"><code>Image</code></a>, matching the <code>layout</code>.   Can be <code>nothing</code> or any other value for grids not in layout.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/render.jl#L166-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SparseOptInspector" href="#DynamicGrids.SparseOptInspector"><code>DynamicGrids.SparseOptInspector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseOptInspector()</code></pre><p>A <a href="#DynamicGrids.Renderer"><code>Renderer</code></a> that checks <a href="#DynamicGrids.SparseOpt"><code>SparseOpt</code></a> visually. Cells that do not run show in gray. Errors show in red, but if they do there&#39;s a bug.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/sparseopt.jl#L270-L275">source</a></section></article><h3 id="Color-schemes"><a class="docs-heading-anchor" href="#Color-schemes">Color schemes</a><a id="Color-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Color-schemes" title="Permalink"></a></h3><p>Schemes from Colorschemes.jl can be used for the <code>scheme</code> argument to <code>ImageOutput</code>,  <code>Renderer</code>s. <code>Greyscale</code> control over the band of grey used, and is very fast.  <code>ObjectScheme</code> is the default.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ObjectScheme" href="#DynamicGrids.ObjectScheme"><code>DynamicGrids.ObjectScheme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectScheme

ObjectScheme()</code></pre><p>Default colorscheme. Similar to <code>GreyScale</code> for <code>Number</code>.</p><p>Other grid objects can define a custom method to return colors from composite objects:</p><pre><code class="language-julia hljs">DynamicGrids.to_rgb(::ObjectScheme, obj::MyObjectType) = ...</code></pre><p>Which must return an <code>ARGB32</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/schemes.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Greyscale" href="#DynamicGrids.Greyscale"><code>DynamicGrids.Greyscale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Greyscale

Greyscale(min=nothing, max=nothing)</code></pre><p>A greeyscale scheme ith better performance than using a  Colorschemes.jl scheme as there is not array access or interpolation.</p><p><code>min</code> and <code>max</code> are values between <code>0.0</code> and <code>1.0</code> that define the range of greys used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/schemes.jl#L1-L10">source</a></section></article><h3 id="Text-labels"><a class="docs-heading-anchor" href="#Text-labels">Text labels</a><a id="Text-labels-1"></a><a class="docs-heading-anchor-permalink" href="#Text-labels" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.TextConfig" href="#DynamicGrids.TextConfig"><code>DynamicGrids.TextConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TextConfig

TextConfig(; kw...)
TextConfig(face, namepixels, namepos, timepixels, timepos, fcolor, bcolor)</code></pre><p>Text configuration for printing timestep and grid name on the image.</p><p><strong>Arguments / Keywords</strong></p><ul><li><code>font</code>: A <code>FreeTypeAbstraction.FTFont</code>, or a <code>String</code> with the font name to look for. The <code>FTFont</code> may load more quickly.</li><li><code>namepixels</code> and <code>timepixels</code>: the pixel size of the font.</li><li><code>timepos</code> and <code>namepos</code>: tuples that set the label positions, in <code>Int</code> pixels.</li><li><code>fcolor</code> and <code>bcolor</code>: the foreground and background colors, as <code>ARGB32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/textconfig.jl#L1-L15">source</a></section></article><h3 id="Saving-gifs"><a class="docs-heading-anchor" href="#Saving-gifs">Saving gifs</a><a id="Saving-gifs-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-gifs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savegif(filename::String, o::Output; kw...)</code></pre><p>Write the output array to a gif.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: File path to save the gif file to.</li><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> object. Note that to make a gif, the output should stores   frames, and run with <code>store=true</code>, and <code>@assert DynamicGrids.istored(o)</code> should pass.</li></ul><p><strong>Keywords</strong></p><p><a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> keywords:</p><ul><li><p><code>minval</code>: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>0</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>maxval</code>: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>1</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>font</code>: <code>String</code> name of font to search for. A default will be guessed.</p></li><li><p><code>text</code>: <code>TextConfig()</code> or <code>nothing</code> for no text. Default is <code>TextConfig(; font=font)</code>.</p></li><li><p><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.ObjectScheme"><code>ObjectScheme</code></a> or object that defines   <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code>   using <code>ARGB32(val)</code>.</p></li><li><p><code>zerocolor</code>: a <code>Col</code> to use when values are zero, or <code>nothing</code> to ignore.</p></li><li><p><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</p></li><li><p><code>renderer</code>: <a href="#DynamicGrids.Renderer"><code>Renderer</code></a> like <a href="#DynamicGrids.Image"><code>Image</code></a> or <a href="#DynamicGrids.Layout"><code>Layout</code></a>. Will be detected    automatically, and use <code>scheme</code>, <code>zerocolor</code> and <code>maskcolor</code> keywords if available.   Can be a <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/gif.jl#L1-L17">source</a></section></article><h3 id="Output-interface"><a class="docs-heading-anchor" href="#Output-interface"><code>Output</code> interface</a><a id="Output-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Output-interface" title="Permalink"></a></h3><p>These are used for defining your own outputs and <code>GridProcessors</code>, not for general scripting.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractExtent" href="#DynamicGrids.AbstractExtent"><code>DynamicGrids.AbstractExtent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractExtent</code></pre><p>Abstract supertype for <code>Extent</code> objects, that hold all variables related to space and time in a simulation. Usually the field of an output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/extent.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Extent" href="#DynamicGrids.Extent"><code>DynamicGrids.Extent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Extent &lt;: AbstractExtent

Extent(init, mask, aux, padval, tspan)
Extent(; init, tspan, mask=nothing, aux=nothing, padval=zero(eltype(init)), kw...)</code></pre><p>Container for extensive variables: spatial and timeseries data. These are kept separate from rules to allow application of rules to alternate spatial and temporal contexts.</p><p>Extent is not usually constructed directly by users, but it can be passed to <code>Output</code> constructors instead of <code>init</code>, <code>mask</code>, <code>aux</code> and <code>tspan</code>.</p><p><strong>Arguments/Keywords</strong></p><ul><li><code>init</code>: initialisation <code>Array</code>/<code>NamedTuple</code> for grid/s.</li><li><code>mask</code>: <code>BitArray</code> for defining cells that will/will not be run.</li><li><code>aux</code>: NamedTuple of arbitrary input data. Use <code>aux(data, Aux(:key))</code> to access from   a <code>Rule</code> in a type-stable way.</li><li><code>padval</code>: padding value for grids with neighborhood rules. The default is    <code>zero(eltype(init))</code>.</li><li><code>tspan</code>: Time span range. Never type-stable, only access this in <code>modifyrule</code> methods</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/extent.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.extent" href="#DynamicGrids.extent"><code>DynamicGrids.extent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extent(o::Output) =&gt; Extent</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method. Return and <a href="#DynamicGrids.Extent"><code>Extent</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isasync" href="#DynamicGrids.isasync"><code>DynamicGrids.isasync</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isasync(o::Output) =&gt; Bool</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Check if the output should run asynchonously. Default is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.storeframe!" href="#DynamicGrids.storeframe!"><code>DynamicGrids.storeframe!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">storeframe!(o::Output, data::AbstractSimData)</code></pre><p>Store the current simulaiton frame in the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isrunning" href="#DynamicGrids.isrunning"><code>DynamicGrids.isrunning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isrunning(o::Output) =&gt; Bool</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Check if the output is running. Prevents multiple versions of <code>sim!</code>  running on the same output for asynchronous outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isshowable" href="#DynamicGrids.isshowable"><code>DynamicGrids.isshowable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isshowable(o::Output, f::Int) =&gt; Bool</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Check if the output can be shown visually, where f is the frame number. Default is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isstored" href="#DynamicGrids.isstored"><code>DynamicGrids.isstored</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isastored(o::Output) =&gt; Bool</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Check if the output is storing each frame, or just the the current one. Default is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initialise!" href="#DynamicGrids.initialise!"><code>DynamicGrids.initialise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialise!(o::Output)</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Initialise the output at the start of the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.finalise!" href="#DynamicGrids.finalise!"><code>DynamicGrids.finalise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finalise!(o::Output, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Finalise the output at the end of the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.frameindex" href="#DynamicGrids.frameindex"><code>DynamicGrids.frameindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frameindex(o::Output, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.Output"><code>Output</code></a> interface method.</p><p>Get the index of the current frame in the output. Every frame has an index of 1 if the simulation isn&#39;t stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L65-L72">source</a></section></article><h3 id="GraphicOutput-interface"><a class="docs-heading-anchor" href="#GraphicOutput-interface"><code>GraphicOutput</code> interface</a><a id="GraphicOutput-interface-1"></a><a class="docs-heading-anchor-permalink" href="#GraphicOutput-interface" title="Permalink"></a></h3><p>Also includes <code>Output</code> interface.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicConfig" href="#DynamicGrids.GraphicConfig"><code>DynamicGrids.GraphicConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphicConfig

GraphicConfig(; fps=25.0, store=false)</code></pre><p>Config and variables for graphic outputs.</p><p><strong>Keywords</strong></p><ul><li><code>fps::Real</code>: Frames per second.</li><li><code>store::Bool</code>: Whether to store frames like <code>ArrayOutput</code> or to disgard   them after visualising. Very long simulation runs may fill available    memory when <code>store=true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/graphic.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.graphicconfig" href="#DynamicGrids.graphicconfig"><code>DynamicGrids.graphicconfig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">graphicconfig(output::GraphicOutput) =&gt; GraphicConfig</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method. Return an <a href="#DynamicGrids.GraphicConfig"><code>GraphicConfig</code></a> object. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.fps" href="#DynamicGrids.fps"><code>DynamicGrids.fps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fps(o::Output) =&gt; Real</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method.</p><p>Get the frames per second the output will run at. The default is <code>nothing</code> - the simulation runs at full speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L100-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.setfps!" href="#DynamicGrids.setfps!"><code>DynamicGrids.setfps!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setfps!(o::Output, x)</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method.</p><p>Set the frames per second the output will run at.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.showframe" href="#DynamicGrids.showframe"><code>DynamicGrids.showframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showframe(o::Output, data::AbstractSimData)
showframe(frame::NamedTuple, o::Output, data::AbstractSimData)
showframe(frame::AbstractArray, o::Output, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method.</p><p>Display the grid/s somehow in the output, if it can do that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initialisegraphics" href="#DynamicGrids.initialisegraphics"><code>DynamicGrids.initialisegraphics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initalisegraphics(o::Output, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method.</p><p>Initialise the output graphics at the start of the simulation, if it has graphics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.finalisegraphics" href="#DynamicGrids.finalisegraphics"><code>DynamicGrids.finalisegraphics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finalisegraphics(o::Output, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> interface method.</p><p>Finalise the output graphics at the end of the simulation, if it has graphics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L128-L134">source</a></section></article><h3 id="ImageOutput-components-and-interface"><a class="docs-heading-anchor" href="#ImageOutput-components-and-interface"><code>ImageOutput</code> components and interface</a><a id="ImageOutput-components-and-interface-1"></a><a class="docs-heading-anchor-permalink" href="#ImageOutput-components-and-interface" title="Permalink"></a></h3><p>Also uses <code>Output</code> and <code>GraphicOutput</code> interfaces.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageConfig" href="#DynamicGrids.ImageConfig"><code>DynamicGrids.ImageConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageConfig

ImageConfig(init; kw...)</code></pre><p>Common configuration component for all <a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>init</code> output init object, used to generate other arguments automatically.</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>minval</code>: Minimum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>0</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>maxval</code>: Maximum value in the grid(s) to normalise for conversion to an RGB pixel.    A <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array.    Note: The default is <code>1</code>, and will not be updated automatically for the simulation.</p></li><li><p><code>font</code>: <code>String</code> name of font to search for. A default will be guessed.</p></li><li><p><code>text</code>: <code>TextConfig()</code> or <code>nothing</code> for no text. Default is <code>TextConfig(; font=font)</code>.</p></li><li><p><code>scheme</code>: a ColorSchemes.jl colorscheme, <a href="#DynamicGrids.ObjectScheme"><code>ObjectScheme</code></a> or object that defines   <code>Base.get(obj, val)</code> and returns a <code>Color</code> or a value that can be converted to <code>Color</code>   using <code>ARGB32(val)</code>.</p></li><li><p><code>zerocolor</code>: a <code>Col</code> to use when values are zero, or <code>nothing</code> to ignore.</p></li><li><p><code>maskcolor</code>: a <code>Color</code> to use when cells are masked, or <code>nothing</code> to ignore.</p></li><li><p><code>renderer</code>: <a href="#DynamicGrids.Renderer"><code>Renderer</code></a> like <a href="#DynamicGrids.Image"><code>Image</code></a> or <a href="#DynamicGrids.Layout"><code>Layout</code></a>. Will be detected    automatically, and use <code>scheme</code>, <code>zerocolor</code> and <code>maskcolor</code> keywords if available.   Can be a <code>Vector/Matrix</code> for multiple grids, matching the <code>layout</code> array. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/image.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.imageconfig" href="#DynamicGrids.imageconfig"><code>DynamicGrids.imageconfig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imageconfig(output::ImageOutput) =&gt; ImageConfig</code></pre><p><code>ImageOutpu</code> interface method. Return an <a href="#DynamicGrids.ImageConfig"><code>ImageConfig</code></a> object. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.showimage" href="#DynamicGrids.showimage"><code>DynamicGrids.showimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showimage(image::AbstractArray, o::ImageOutput)
showimage(image::AbstractArray, o::ImageOutput, data::AbstractSimData)</code></pre><p><a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a> interface method.</p><p>Display an image generated from the grid, a required method for all <code>ImageOutput</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.render!" href="#DynamicGrids.render!"><code>DynamicGrids.render!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">render!(o::ImageOutput, data::AbstractSimData)
render!(imbuf, renderer::Renderer, o::ImageOutput, data::AbstractSimData, grids)</code></pre><p>Convert a grid or <code>NamedRuple</code> of grids to an <code>ARGB32</code> image, using an  <a href="#DynamicGrids.Renderer"><code>Renderer</code></a>.</p><p>Rendered pixels are written to the image buffer matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.to_rgb" href="#DynamicGrids.to_rgb"><code>DynamicGrids.to_rgb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_rgb(val) =&gt; ARGB32
to_rgb(scheme, val) =&gt; ARGB32</code></pre><p><code>ImageOutput</code> interface method.</p><p>Display an image generated from the grid, a required method for all <a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a>.</p><p>Custom grid object will need to add methods for converting the object to a color,</p><pre><code class="language-julia hljs">to_rgb(::ObjectScheme, obj::CustomObj) = ...`</code></pre><p>For use with other colorschemes, a method that calls <code>get</code> with a <code>Real</code> value obtained from the object will be required:</p><pre><code class="language-julia hljs">to_rgb(scheme, obj::CustomObj) = ARGB32(get(scheme, real_from_obj(obj)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/b0c8d16f58ecbf0f0c1dae792c45d171a3f09e6a/src/outputs/interface.jl#L165-L184">source</a></section></article><h2 id="Custom-grid-element-types"><a class="docs-heading-anchor" href="#Custom-grid-element-types">Custom grid element types</a><a id="Custom-grid-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-grid-element-types" title="Permalink"></a></h2><p>It is common to use <code>Bool</code>, <code>Int</code> or <code>Float64</code> as the contents of a grid. But a range of object types can be used if they meet the interface criteria.</p><p>Immutable, <code>isbits</code> objects are usually better and the only type officially to work - as they are loaded directly in the simulation. Mutable objects, especially containing pointers, may lead to incorrect stored results, and wont work at all on GPUs.</p><p>Methods to define are: </p><ul><li><code>zero</code>: define zero of the object type</li><li><code>oneunit</code>: define one of the object type</li><li><code>isless</code>: define comparison between two of the objects</li><li><code>*</code>: multiplication by a <code>Real</code> scalar.</li><li><code>/</code>: division by a <code>Real</code> scalar.</li><li><code>+</code>: addition to another object of the same type</li><li><code>-</code>: subtraction from another object of the same type</li><li><code>to_rgb</code>: return and <code>ARGB32</code> to visualise the object as a pixel </li></ul><p>In this example we define a struct with two fields. You will need to determine the correct behaviours for your own types, but hopefully this will get you started.</p><pre><code class="language-julia hljs">struct MYStruct{A,B}
    a::A
    b::B
end

Base.isless(a::MyStruct, b::MyStruct) = isless(a.a, b.a)
Base.zero(::Type{&lt;:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(zero(T1), zero(T2))
Base.oneunit(::Type{&lt;:MyStruct{T1,T2}}) where {T1,T2} = MyStruct(one(T1), one(T2))

Base.:*(x::MyStruct, x::Number) = MyStruct(x.a * x, x.b * x)
Base.:*(x::Number, x::MyStruct) = MyStruct(x * x.a, x * x.b)
Base.:/(x::MyStruct, x::Number) = MyStruct(x.a / x, x.b / x)
Base.:+(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a + x2.a, x1.b + x2.b)
Base.:-(x1::MyStruct, x2::MyStruct) = MyStruct(x1.a - x2.a, x1.b - x2.b)</code></pre><p>To generate rgb colors for an <code>ImageOuput</code>, you must define <code>to_rgb</code>,  at least for the default <code>ObjectScheme</code>, but this can also be done for other  schemes such as ColorSchemes.jl, or <code>GreyScale</code>, by calling <code>get</code> on the scheme and a  <code>Real</code> value. Note that the objects will be normalised to values between zero and one by <code>minval</code> and <code>maxval</code> scalars prior to this, using the division operators defined  above. It is preferable to use <code>minval</code> and <code>maxval</code> over normalising in <code>to_rgb</code> -  as this will not be as flexible for scripting.</p><pre><code class="language-julia hljs">DynamicGrids.to_rgb(::ObjectScheme, obj::MyStruct) = ARGB32(obj.a, obj.b, 0)
DynamicGrids.to_rgb(scheme, obj::MyStruct) = get(scheme, obj.a)</code></pre><p>See the <code>test/objectgrids.jl</code> tests for more details on using complex objects in grids.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 21 February 2022 21:36">Monday 21 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
